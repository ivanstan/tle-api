text
"<s>[INST] __construct [/INST]         parent::__construct();
 <\s>
"
"<s>[INST] execute [/INST]         $this->repository->removeBefore(
            (new \DateTime())->sub(new \DateInterval('P2M'))
        );

        return Command::SUCCESS;
 <\s>
"
"<s>[INST] get default name [/INST]         $class = static::class;

        if ($attribute = (new \ReflectionClass($class))->getAttributes(AsCommand::class)) {
            return $attribute[0]->newInstance()->name;
        }

        $r = new \ReflectionProperty($class, 'defaultName');

        if ($class !== $r->class || null === static::$defaultName) {
            return null;
        }

        trigger_deprecation('symfony/console', '6.1', 'Relying on the static property ""$defaultName"" for setting a command name is deprecated. Add the ""%s"" attribute to the ""%s"" class instead.', AsCommand::class, static::class);

        return static::$defaultName;
 <\s>
"
"<s>[INST] get default description [/INST]         $class = static::class;

        if ($attribute = (new \ReflectionClass($class))->getAttributes(AsCommand::class)) {
            return $attribute[0]->newInstance()->description;
        }

        $r = new \ReflectionProperty($class, 'defaultDescription');

        if ($class !== $r->class || null === static::$defaultDescription) {
            return null;
        }

        trigger_deprecation('symfony/console', '6.1', 'Relying on the static property ""$defaultDescription"" for setting a command description is deprecated. Add the ""%s"" attribute to the ""%s"" class instead.', AsCommand::class, static::class);

        return static::$defaultDescription;
 <\s>
"
"<s>[INST] ignore validation errors [/INST]         $this->ignoreValidationErrors = true;
 <\s>
"
"<s>[INST] set application [/INST]         if (1 > \func_num_args()) {
            trigger_deprecation('symfony/console', '6.2', 'Calling ""%s()"" without any arguments is deprecated, pass null explicitly instead.', __METHOD__);
        }
        $this->application = $application;
        if ($application) {
            $this->setHelperSet($application->getHelperSet());
        } else {
            $this->helperSet = null;
        }

        $this->fullDefinition = null;
 <\s>
"
"<s>[INST] set helper set [/INST]         $this->helperSet = $helperSet;
 <\s>
"
"<s>[INST] get helper set [/INST]         return $this->helperSet;
 <\s>
"
"<s>[INST] get application [/INST]         return $this->application;
 <\s>
"
"<s>[INST] is enabled [/INST]         return true;
 <\s>
"
"<s>[INST] configure [/INST]  <\s>
"
"<s>[INST] interact [/INST]  <\s>
"
"<s>[INST] initialize [/INST]  <\s>
"
"<s>[INST] run [/INST]         // add the application arguments and options
        $this->mergeApplicationDefinition();

        // bind the input against the command specific arguments/options
        try {
            $input->bind($this->getDefinition());
        } catch (ExceptionInterface $e) {
            if (!$this->ignoreValidationErrors) {
                throw $e;
            }
        }

        $this->initialize($input, $output);

        if (null !== $this->processTitle) {
            if (\function_exists('cli_set_process_title')) {
                if (!@cli_set_process_title($this->processTitle)) {
                    if ('Darwin' === \PHP_OS) {
                        $output->writeln('<comment>Running ""cli_set_process_title"" as an unprivileged user is not supported on MacOS.</comment>', OutputInterface::VERBOSITY_VERY_VERBOSE);
                    } else {
                        cli_set_process_title($this->processTitle);
                    }
                }
            } elseif (\function_exists('setproctitle')) {
                setproctitle($this->processTitle);
            } elseif (OutputInterface::VERBOSITY_VERY_VERBOSE === $output->getVerbosity()) {
                $output->writeln('<comment>Install the proctitle PECL to be able to change the process title.</comment>');
            }
        }

        if ($input->isInteractive()) {
            $this->interact($input, $output);
        }

        // The command name argument is often omitted when a command is executed directly with its run() method.
        // It would fail the validation if we didn't make sure the command argument is present,
        // since it's required by the application.
        if ($input->hasArgument('command') && null === $input->getArgument('command')) {
            $input->setArgument('command', $this->getName());
        }

        $input->validate();

        if ($this->code) {
            $statusCode = ($this->code)($input, $output);
        } else {
            $statusCode = $this->execute($input, $output);

            if (!\is_int($statusCode)) {
                throw new \TypeError(sprintf('Return value of ""%s::execute()"" must be of the type int, ""%s"" returned.', static::class, get_debug_type($statusCode)));
            }
        }

        return is_numeric($statusCode) ? (int) $statusCode : 0;
 <\s>
"
"<s>[INST] complete [/INST]         $definition = $this->getDefinition();
        if (CompletionInput::TYPE_OPTION_VALUE === $input->getCompletionType() && $definition->hasOption($input->getCompletionName())) {
            $definition->getOption($input->getCompletionName())->complete($input, $suggestions);
        } elseif (CompletionInput::TYPE_ARGUMENT_VALUE === $input->getCompletionType() && $definition->hasArgument($input->getCompletionName())) {
            $definition->getArgument($input->getCompletionName())->complete($input, $suggestions);
        }
 <\s>
"
"<s>[INST] set code [/INST]         if ($code instanceof \Closure) {
            $r = new \ReflectionFunction($code);
            if (null === $r->getClosureThis()) {
                set_error_handler(static function () {});
                try {
                    if ($c = \Closure::bind($code, $this)) {
                        $code = $c;
                    }
                } finally {
                    restore_error_handler();
                }
            }
        } else {
            $code = $code(...);
        }

        $this->code = $code;

        return $this;
 <\s>
"
"<s>[INST] merge application definition [/INST]         if (null === $this->application) {
            return;
        }

        $this->fullDefinition = new InputDefinition();
        $this->fullDefinition->setOptions($this->definition->getOptions());
        $this->fullDefinition->addOptions($this->application->getDefinition()->getOptions());

        if ($mergeArgs) {
            $this->fullDefinition->setArguments($this->application->getDefinition()->getArguments());
            $this->fullDefinition->addArguments($this->definition->getArguments());
        } else {
            $this->fullDefinition->setArguments($this->definition->getArguments());
        }
 <\s>
"
"<s>[INST] set definition [/INST]         if ($definition instanceof InputDefinition) {
            $this->definition = $definition;
        } else {
            $this->definition->setDefinition($definition);
        }

        $this->fullDefinition = null;

        return $this;
 <\s>
"
"<s>[INST] get definition [/INST]         return $this->fullDefinition ?? $this->getNativeDefinition();
 <\s>
"
"<s>[INST] get native definition [/INST]         return $this->definition ?? throw new LogicException(sprintf('Command class ""%s"" is not correctly initialized. You probably forgot to call the parent constructor.', static::class));
 <\s>
"
"<s>[INST] add argument [/INST]         $suggestedValues = 5 <= \func_num_args() ? func_get_arg(4) : [];
        if (!\is_array($suggestedValues) && !$suggestedValues instanceof \Closure) {
            throw new \TypeError(sprintf('Argument 5 passed to ""%s()"" must be array or \Closure, ""%s"" given.', __METHOD__, get_debug_type($suggestedValues)));
        }
        $this->definition->addArgument(new InputArgument($name, $mode, $description, $default, $suggestedValues));
        $this->fullDefinition?->addArgument(new InputArgument($name, $mode, $description, $default, $suggestedValues));

        return $this;
 <\s>
"
"<s>[INST] add option [/INST]         $suggestedValues = 6 <= \func_num_args() ? func_get_arg(5) : [];
        if (!\is_array($suggestedValues) && !$suggestedValues instanceof \Closure) {
            throw new \TypeError(sprintf('Argument 5 passed to ""%s()"" must be array or \Closure, ""%s"" given.', __METHOD__, get_debug_type($suggestedValues)));
        }
        $this->definition->addOption(new InputOption($name, $shortcut, $mode, $description, $default, $suggestedValues));
        $this->fullDefinition?->addOption(new InputOption($name, $shortcut, $mode, $description, $default, $suggestedValues));

        return $this;
 <\s>
"
"<s>[INST] set name [/INST]         $this->validateName($name);

        $this->name = $name;

        return $this;
 <\s>
"
"<s>[INST] set process title [/INST]         $this->processTitle = $title;

        return $this;
 <\s>
"
"<s>[INST] get name [/INST]         return $this->name;
 <\s>
"
"<s>[INST] set hidden [/INST]         $this->hidden = $hidden;

        return $this;
 <\s>
"
"<s>[INST] is hidden [/INST]         return $this->hidden;
 <\s>
"
"<s>[INST] set description [/INST]         $this->description = $description;

        return $this;
 <\s>
"
"<s>[INST] get description [/INST]         return $this->description;
 <\s>
"
"<s>[INST] set help [/INST]         $this->help = $help;

        return $this;
 <\s>
"
"<s>[INST] get help [/INST]         return $this->help;
 <\s>
"
"<s>[INST] get processed help [/INST]         $name = $this->name;
        $isSingleCommand = $this->application?->isSingleCommand();

        $placeholders = [
            '%command.name%',
            '%command.full_name%',
        ];
        $replacements = [
            $name,
            $isSingleCommand ? $_SERVER['PHP_SELF'] : $_SERVER['PHP_SELF'].' '.$name,
        ];

        return str_replace($placeholders, $replacements, $this->getHelp() ?: $this->getDescription());
 <\s>
"
"<s>[INST] set aliases [/INST]         $list = [];

        foreach ($aliases as $alias) {
            $this->validateName($alias);
            $list[] = $alias;
        }

        $this->aliases = \is_array($aliases) ? $aliases : $list;

        return $this;
 <\s>
"
"<s>[INST] get aliases [/INST]         return $this->aliases;
 <\s>
"
"<s>[INST] get synopsis [/INST]         $key = $short ? 'short' : 'long';

        if (!isset($this->synopsis[$key])) {
            $this->synopsis[$key] = trim(sprintf('%s %s', $this->name, $this->definition->getSynopsis($short)));
        }

        return $this->synopsis[$key];
 <\s>
"
"<s>[INST] add usage [/INST]         if (!str_starts_with($usage, $this->name)) {
            $usage = sprintf('%s %s', $this->name, $usage);
        }

        $this->usages[] = $usage;

        return $this;
 <\s>
"
"<s>[INST] get usages [/INST]         return $this->usages;
 <\s>
"
"<s>[INST] get helper [/INST]         if (null === $this->helperSet) {
            throw new LogicException(sprintf('Cannot retrieve helper ""%s"" because there is no HelperSet defined. Did you forget to add your command to the application or to set the application on the command using the setApplication() method? You can also set the HelperSet directly using the setHelperSet() method.', $name));
        }

        return $this->helperSet->get($name);
 <\s>
"
"<s>[INST] __construct [/INST]         parent::__construct();
 <\s>
"
"<s>[INST] configure [/INST]         $this->addOption(self::OPTION_NO_PROGRESS, null, InputOption::VALUE_OPTIONAL, 'Hide progress bar', false);
 <\s>
"
"<s>[INST] execute [/INST]         $showProgress = false === $input->getOption(self::OPTION_NO_PROGRESS);

        $this->satellites = $this->repository->fetchAllIndexed();

        $totalInsert = 0;
        $totalUpdate = 0;

        $sources = Yaml::parseFile($this->getProjectDir().self::SOURCE);

        if ($showProgress) {
            $progressBar = new ProgressBar($output, \count($sources));
            $progressBar->start();
        }

        $validator = new Validator();

        foreach ($sources as $uri) {
            /* @noinspection DisconnectedForeachInstructionInspection */
            if (isset($progressBar)) {
                $progressBar->advance();
            }

            try {
                $response = (new Client())->request('GET', $uri);
            } catch (\Exception $exception) {
                $message = \sprintf('Unable to fetch resource ""%s"" with exception message ""%s""', $uri, $exception->getMessage());

                $this->logger->error($message);
                $output->writeln($message);
                continue;
            }

            if (!$response->getBody()) {
                $message = \sprintf('URI ""%s"" returned empty body, skipping', $uri);

                $this->logger->error($message);
                $output->writeln($message);
                continue;
            }

            $file = new TleFile($response->getBody());

            $insert = [];
            $update = [];

            foreach ($file->parse() as $tle) {
                if (!$validator->validate($tle)) {
                    continue;
                }

                if (null === $tle) {
                    continue;
                }

                if (\array_key_exists($tle->getId(), $this->satellites)) {
                    $update[$tle->getId()] = $tle;
                } else {
                    $insert[$tle->getId()] = $tle;
                }
            }

            $totalInsert += \count($insert);
            $totalUpdate += \count($update);

            $this->flush($insert, true);
            $this->flush($update);
        }

        if (isset($progressBar)) {
            $progressBar->finish();
        }
        $output->writeln('');
        $output->writeln('');

        $table = new Table($output);
        $table
            ->setHeaders(
                [
                    'Output',
                ]
            )
            ->setStyle('box')
            ->setRows(
                [
                    [
                        'TLE records persisted to database',
                        $totalInsert,
                    ],
                    [
                        'TLE records updated in database',
                        $totalUpdate,
                    ],
                ]
            );
        $table->render();

        return Command::SUCCESS;
 <\s>
"
"<s>[INST] to persistent [/INST]         $tle = new Tle();
        $tle->setId($model->getId());
        $tle->setLine1($model->getLine1());
        $tle->setLine2($model->getLine2());
        $tle->setName($model->getName());

        return $tle;
 <\s>
"
"<s>[INST] flush [/INST]         $counter = 0;
        /** @var TleModel $model */
        foreach ($queue as $model) {
            if (!$persistNew) {
                /** @var Tle $existing */
                $existing = $this->satellites[$model->getId()];
                $existing->setName($model->getName());
                $existing->setId($model->getId());
                $existing->setLine1($model->getLine1());
                $existing->setLine2($model->getLine2());
            }

            if ($persistNew) {
                $tle = $this->toPersistent($model);
                $this->satellites[$model->getId()] = $tle;
                $this->em->persist($tle);
            }

            if (($counter % self::BATCH_SIZE) === 0) {
                $this->em->flush();
            }
            ++$counter;
        }
        $this->em->flush();
 <\s>
"
"<s>[INST] get default name [/INST]         $class = static::class;

        if ($attribute = (new \ReflectionClass($class))->getAttributes(AsCommand::class)) {
            return $attribute[0]->newInstance()->name;
        }

        $r = new \ReflectionProperty($class, 'defaultName');

        if ($class !== $r->class || null === static::$defaultName) {
            return null;
        }

        trigger_deprecation('symfony/console', '6.1', 'Relying on the static property ""$defaultName"" for setting a command name is deprecated. Add the ""%s"" attribute to the ""%s"" class instead.', AsCommand::class, static::class);

        return static::$defaultName;
 <\s>
"
"<s>[INST] get default description [/INST]         $class = static::class;

        if ($attribute = (new \ReflectionClass($class))->getAttributes(AsCommand::class)) {
            return $attribute[0]->newInstance()->description;
        }

        $r = new \ReflectionProperty($class, 'defaultDescription');

        if ($class !== $r->class || null === static::$defaultDescription) {
            return null;
        }

        trigger_deprecation('symfony/console', '6.1', 'Relying on the static property ""$defaultDescription"" for setting a command description is deprecated. Add the ""%s"" attribute to the ""%s"" class instead.', AsCommand::class, static::class);

        return static::$defaultDescription;
 <\s>
"
"<s>[INST] ignore validation errors [/INST]         $this->ignoreValidationErrors = true;
 <\s>
"
"<s>[INST] set application [/INST]         if (1 > \func_num_args()) {
            trigger_deprecation('symfony/console', '6.2', 'Calling ""%s()"" without any arguments is deprecated, pass null explicitly instead.', __METHOD__);
        }
        $this->application = $application;
        if ($application) {
            $this->setHelperSet($application->getHelperSet());
        } else {
            $this->helperSet = null;
        }

        $this->fullDefinition = null;
 <\s>
"
"<s>[INST] set helper set [/INST]         $this->helperSet = $helperSet;
 <\s>
"
"<s>[INST] get helper set [/INST]         return $this->helperSet;
 <\s>
"
"<s>[INST] get application [/INST]         return $this->application;
 <\s>
"
"<s>[INST] is enabled [/INST]         return true;
 <\s>
"
"<s>[INST] interact [/INST]  <\s>
"
"<s>[INST] initialize [/INST]  <\s>
"
"<s>[INST] run [/INST]         // add the application arguments and options
        $this->mergeApplicationDefinition();

        // bind the input against the command specific arguments/options
        try {
            $input->bind($this->getDefinition());
        } catch (ExceptionInterface $e) {
            if (!$this->ignoreValidationErrors) {
                throw $e;
            }
        }

        $this->initialize($input, $output);

        if (null !== $this->processTitle) {
            if (\function_exists('cli_set_process_title')) {
                if (!@cli_set_process_title($this->processTitle)) {
                    if ('Darwin' === \PHP_OS) {
                        $output->writeln('<comment>Running ""cli_set_process_title"" as an unprivileged user is not supported on MacOS.</comment>', OutputInterface::VERBOSITY_VERY_VERBOSE);
                    } else {
                        cli_set_process_title($this->processTitle);
                    }
                }
            } elseif (\function_exists('setproctitle')) {
                setproctitle($this->processTitle);
            } elseif (OutputInterface::VERBOSITY_VERY_VERBOSE === $output->getVerbosity()) {
                $output->writeln('<comment>Install the proctitle PECL to be able to change the process title.</comment>');
            }
        }

        if ($input->isInteractive()) {
            $this->interact($input, $output);
        }

        // The command name argument is often omitted when a command is executed directly with its run() method.
        // It would fail the validation if we didn't make sure the command argument is present,
        // since it's required by the application.
        if ($input->hasArgument('command') && null === $input->getArgument('command')) {
            $input->setArgument('command', $this->getName());
        }

        $input->validate();

        if ($this->code) {
            $statusCode = ($this->code)($input, $output);
        } else {
            $statusCode = $this->execute($input, $output);

            if (!\is_int($statusCode)) {
                throw new \TypeError(sprintf('Return value of ""%s::execute()"" must be of the type int, ""%s"" returned.', static::class, get_debug_type($statusCode)));
            }
        }

        return is_numeric($statusCode) ? (int) $statusCode : 0;
 <\s>
"
"<s>[INST] complete [/INST]         $definition = $this->getDefinition();
        if (CompletionInput::TYPE_OPTION_VALUE === $input->getCompletionType() && $definition->hasOption($input->getCompletionName())) {
            $definition->getOption($input->getCompletionName())->complete($input, $suggestions);
        } elseif (CompletionInput::TYPE_ARGUMENT_VALUE === $input->getCompletionType() && $definition->hasArgument($input->getCompletionName())) {
            $definition->getArgument($input->getCompletionName())->complete($input, $suggestions);
        }
 <\s>
"
"<s>[INST] set code [/INST]         if ($code instanceof \Closure) {
            $r = new \ReflectionFunction($code);
            if (null === $r->getClosureThis()) {
                set_error_handler(static function () {});
                try {
                    if ($c = \Closure::bind($code, $this)) {
                        $code = $c;
                    }
                } finally {
                    restore_error_handler();
                }
            }
        } else {
            $code = $code(...);
        }

        $this->code = $code;

        return $this;
 <\s>
"
"<s>[INST] merge application definition [/INST]         if (null === $this->application) {
            return;
        }

        $this->fullDefinition = new InputDefinition();
        $this->fullDefinition->setOptions($this->definition->getOptions());
        $this->fullDefinition->addOptions($this->application->getDefinition()->getOptions());

        if ($mergeArgs) {
            $this->fullDefinition->setArguments($this->application->getDefinition()->getArguments());
            $this->fullDefinition->addArguments($this->definition->getArguments());
        } else {
            $this->fullDefinition->setArguments($this->definition->getArguments());
        }
 <\s>
"
"<s>[INST] set definition [/INST]         if ($definition instanceof InputDefinition) {
            $this->definition = $definition;
        } else {
            $this->definition->setDefinition($definition);
        }

        $this->fullDefinition = null;

        return $this;
 <\s>
"
"<s>[INST] get definition [/INST]         return $this->fullDefinition ?? $this->getNativeDefinition();
 <\s>
"
"<s>[INST] get native definition [/INST]         return $this->definition ?? throw new LogicException(sprintf('Command class ""%s"" is not correctly initialized. You probably forgot to call the parent constructor.', static::class));
 <\s>
"
"<s>[INST] add argument [/INST]         $suggestedValues = 5 <= \func_num_args() ? func_get_arg(4) : [];
        if (!\is_array($suggestedValues) && !$suggestedValues instanceof \Closure) {
            throw new \TypeError(sprintf('Argument 5 passed to ""%s()"" must be array or \Closure, ""%s"" given.', __METHOD__, get_debug_type($suggestedValues)));
        }
        $this->definition->addArgument(new InputArgument($name, $mode, $description, $default, $suggestedValues));
        $this->fullDefinition?->addArgument(new InputArgument($name, $mode, $description, $default, $suggestedValues));

        return $this;
 <\s>
"
"<s>[INST] add option [/INST]         $suggestedValues = 6 <= \func_num_args() ? func_get_arg(5) : [];
        if (!\is_array($suggestedValues) && !$suggestedValues instanceof \Closure) {
            throw new \TypeError(sprintf('Argument 5 passed to ""%s()"" must be array or \Closure, ""%s"" given.', __METHOD__, get_debug_type($suggestedValues)));
        }
        $this->definition->addOption(new InputOption($name, $shortcut, $mode, $description, $default, $suggestedValues));
        $this->fullDefinition?->addOption(new InputOption($name, $shortcut, $mode, $description, $default, $suggestedValues));

        return $this;
 <\s>
"
"<s>[INST] set name [/INST]         $this->validateName($name);

        $this->name = $name;

        return $this;
 <\s>
"
"<s>[INST] set process title [/INST]         $this->processTitle = $title;

        return $this;
 <\s>
"
"<s>[INST] get name [/INST]         return $this->name;
 <\s>
"
"<s>[INST] set hidden [/INST]         $this->hidden = $hidden;

        return $this;
 <\s>
"
"<s>[INST] is hidden [/INST]         return $this->hidden;
 <\s>
"
"<s>[INST] set description [/INST]         $this->description = $description;

        return $this;
 <\s>
"
"<s>[INST] get description [/INST]         return $this->description;
 <\s>
"
"<s>[INST] set help [/INST]         $this->help = $help;

        return $this;
 <\s>
"
"<s>[INST] get help [/INST]         return $this->help;
 <\s>
"
"<s>[INST] get processed help [/INST]         $name = $this->name;
        $isSingleCommand = $this->application?->isSingleCommand();

        $placeholders = [
            '%command.name%',
            '%command.full_name%',
        ];
        $replacements = [
            $name,
            $isSingleCommand ? $_SERVER['PHP_SELF'] : $_SERVER['PHP_SELF'].' '.$name,
        ];

        return str_replace($placeholders, $replacements, $this->getHelp() ?: $this->getDescription());
 <\s>
"
"<s>[INST] set aliases [/INST]         $list = [];

        foreach ($aliases as $alias) {
            $this->validateName($alias);
            $list[] = $alias;
        }

        $this->aliases = \is_array($aliases) ? $aliases : $list;

        return $this;
 <\s>
"
"<s>[INST] get aliases [/INST]         return $this->aliases;
 <\s>
"
"<s>[INST] get synopsis [/INST]         $key = $short ? 'short' : 'long';

        if (!isset($this->synopsis[$key])) {
            $this->synopsis[$key] = trim(sprintf('%s %s', $this->name, $this->definition->getSynopsis($short)));
        }

        return $this->synopsis[$key];
 <\s>
"
"<s>[INST] add usage [/INST]         if (!str_starts_with($usage, $this->name)) {
            $usage = sprintf('%s %s', $this->name, $usage);
        }

        $this->usages[] = $usage;

        return $this;
 <\s>
"
"<s>[INST] get usages [/INST]         return $this->usages;
 <\s>
"
"<s>[INST] get helper [/INST]         if (null === $this->helperSet) {
            throw new LogicException(sprintf('Cannot retrieve helper ""%s"" because there is no HelperSet defined. Did you forget to add your command to the application or to set the application on the command using the setApplication() method? You can also set the HelperSet directly using the setHelperSet() method.', $name));
        }

        return $this->helperSet->get($name);
 <\s>
"
"<s>[INST] set parameter bag [/INST]         $this->parameters = $parameters;
 <\s>
"
"<s>[INST] get project dir [/INST]         return $this->parameters->get('kernel.project_dir');
 <\s>
"
"<s>[INST] __construct [/INST]         parent::__construct();
 <\s>
"
"<s>[INST] configure [/INST]         $this->addOption(self::OPTION_TLE, 't', InputOption::VALUE_REQUIRED, 'Calculate only for specified record');
 <\s>
"
"<s>[INST] execute [/INST]         $builder = $this->entityManager
            ->createQueryBuilder()
            ->select('tle')
            ->from(Tle::class, 'tle');

        $tle = $input->getOption(self::OPTION_TLE);

        if (null !== $tle) {
            $builder->andWhere('tle.id = :tle');
            $builder->setParameter('tle', $tle);
        }

        $repository = $this->entityManager->getRepository(TleInformation::class);

        /** @var Tle $tle */
        foreach ($builder->getQuery()->toIterable() as $i => $tle) {
            $exists = true;

            $tleInformation = $repository->find($tle->getId());

            if (null === $tleInformation) {
                $exists = false;
                $tleInformation = new TleInformation($tle);
            }

            $tleModel = new \Ivanstan\Tle\Model\Tle($tle->getLine1(), $tle->getLine2(), $tle->getName());

            $tleInformation->inclination = $tleModel->getInclination();
            $tleInformation->eccentricity = $tleModel->eccentricity();
            $tleInformation->period = $tleModel->period();

            if ($tleModel->meanMotion() > 0) {
                $tleInformation->period = $tleModel->period();
            } else {
                $output->writeln(sprintf('Satellite %d has mean motion problem', $tle->getId()));
            }

            $tleInformation->geostationary = (new GeostationaryOrbitTleSpecification())->isSatisfiedBy($tleModel);
            $tleInformation->raan = $tleModel->raan();
            $tleInformation->semiMajorAxis = $tleModel->semiMajorAxis();

            if (!$exists) {
                $this->entityManager->persist($tleInformation);
            }

            if (($i % self::BATCH_SIZE) === 0) {
                $this->entityManager->flush();
                $this->entityManager->clear();
            }
        }

        $this->entityManager->flush();

        $this->calculateStats();

        return Command::SUCCESS;
 <\s>
"
"<s>[INST] calculate stats [/INST]         $this->statRepository->update(TleStat::MAX_E, $this->infoRepository->getMaxEccentricity());
        $this->statRepository->update(TleStat::MAX_I, $this->infoRepository->getMaxInclination());
        $this->statRepository->update(TleStat::MAX_P, $this->infoRepository->getMaxPeriod());
        $this->statRepository->update(TleStat::MIN_P, $this->infoRepository->getMinPeriod());
 <\s>
"
"<s>[INST] get default name [/INST]         $class = static::class;

        if ($attribute = (new \ReflectionClass($class))->getAttributes(AsCommand::class)) {
            return $attribute[0]->newInstance()->name;
        }

        $r = new \ReflectionProperty($class, 'defaultName');

        if ($class !== $r->class || null === static::$defaultName) {
            return null;
        }

        trigger_deprecation('symfony/console', '6.1', 'Relying on the static property ""$defaultName"" for setting a command name is deprecated. Add the ""%s"" attribute to the ""%s"" class instead.', AsCommand::class, static::class);

        return static::$defaultName;
 <\s>
"
"<s>[INST] get default description [/INST]         $class = static::class;

        if ($attribute = (new \ReflectionClass($class))->getAttributes(AsCommand::class)) {
            return $attribute[0]->newInstance()->description;
        }

        $r = new \ReflectionProperty($class, 'defaultDescription');

        if ($class !== $r->class || null === static::$defaultDescription) {
            return null;
        }

        trigger_deprecation('symfony/console', '6.1', 'Relying on the static property ""$defaultDescription"" for setting a command description is deprecated. Add the ""%s"" attribute to the ""%s"" class instead.', AsCommand::class, static::class);

        return static::$defaultDescription;
 <\s>
"
"<s>[INST] ignore validation errors [/INST]         $this->ignoreValidationErrors = true;
 <\s>
"
"<s>[INST] set application [/INST]         if (1 > \func_num_args()) {
            trigger_deprecation('symfony/console', '6.2', 'Calling ""%s()"" without any arguments is deprecated, pass null explicitly instead.', __METHOD__);
        }
        $this->application = $application;
        if ($application) {
            $this->setHelperSet($application->getHelperSet());
        } else {
            $this->helperSet = null;
        }

        $this->fullDefinition = null;
 <\s>
"
"<s>[INST] set helper set [/INST]         $this->helperSet = $helperSet;
 <\s>
"
"<s>[INST] get helper set [/INST]         return $this->helperSet;
 <\s>
"
"<s>[INST] get application [/INST]         return $this->application;
 <\s>
"
"<s>[INST] is enabled [/INST]         return true;
 <\s>
"
"<s>[INST] interact [/INST]  <\s>
"
"<s>[INST] initialize [/INST]  <\s>
"
"<s>[INST] run [/INST]         // add the application arguments and options
        $this->mergeApplicationDefinition();

        // bind the input against the command specific arguments/options
        try {
            $input->bind($this->getDefinition());
        } catch (ExceptionInterface $e) {
            if (!$this->ignoreValidationErrors) {
                throw $e;
            }
        }

        $this->initialize($input, $output);

        if (null !== $this->processTitle) {
            if (\function_exists('cli_set_process_title')) {
                if (!@cli_set_process_title($this->processTitle)) {
                    if ('Darwin' === \PHP_OS) {
                        $output->writeln('<comment>Running ""cli_set_process_title"" as an unprivileged user is not supported on MacOS.</comment>', OutputInterface::VERBOSITY_VERY_VERBOSE);
                    } else {
                        cli_set_process_title($this->processTitle);
                    }
                }
            } elseif (\function_exists('setproctitle')) {
                setproctitle($this->processTitle);
            } elseif (OutputInterface::VERBOSITY_VERY_VERBOSE === $output->getVerbosity()) {
                $output->writeln('<comment>Install the proctitle PECL to be able to change the process title.</comment>');
            }
        }

        if ($input->isInteractive()) {
            $this->interact($input, $output);
        }

        // The command name argument is often omitted when a command is executed directly with its run() method.
        // It would fail the validation if we didn't make sure the command argument is present,
        // since it's required by the application.
        if ($input->hasArgument('command') && null === $input->getArgument('command')) {
            $input->setArgument('command', $this->getName());
        }

        $input->validate();

        if ($this->code) {
            $statusCode = ($this->code)($input, $output);
        } else {
            $statusCode = $this->execute($input, $output);

            if (!\is_int($statusCode)) {
                throw new \TypeError(sprintf('Return value of ""%s::execute()"" must be of the type int, ""%s"" returned.', static::class, get_debug_type($statusCode)));
            }
        }

        return is_numeric($statusCode) ? (int) $statusCode : 0;
 <\s>
"
"<s>[INST] complete [/INST]         $definition = $this->getDefinition();
        if (CompletionInput::TYPE_OPTION_VALUE === $input->getCompletionType() && $definition->hasOption($input->getCompletionName())) {
            $definition->getOption($input->getCompletionName())->complete($input, $suggestions);
        } elseif (CompletionInput::TYPE_ARGUMENT_VALUE === $input->getCompletionType() && $definition->hasArgument($input->getCompletionName())) {
            $definition->getArgument($input->getCompletionName())->complete($input, $suggestions);
        }
 <\s>
"
"<s>[INST] set code [/INST]         if ($code instanceof \Closure) {
            $r = new \ReflectionFunction($code);
            if (null === $r->getClosureThis()) {
                set_error_handler(static function () {});
                try {
                    if ($c = \Closure::bind($code, $this)) {
                        $code = $c;
                    }
                } finally {
                    restore_error_handler();
                }
            }
        } else {
            $code = $code(...);
        }

        $this->code = $code;

        return $this;
 <\s>
"
"<s>[INST] merge application definition [/INST]         if (null === $this->application) {
            return;
        }

        $this->fullDefinition = new InputDefinition();
        $this->fullDefinition->setOptions($this->definition->getOptions());
        $this->fullDefinition->addOptions($this->application->getDefinition()->getOptions());

        if ($mergeArgs) {
            $this->fullDefinition->setArguments($this->application->getDefinition()->getArguments());
            $this->fullDefinition->addArguments($this->definition->getArguments());
        } else {
            $this->fullDefinition->setArguments($this->definition->getArguments());
        }
 <\s>
"
"<s>[INST] set definition [/INST]         if ($definition instanceof InputDefinition) {
            $this->definition = $definition;
        } else {
            $this->definition->setDefinition($definition);
        }

        $this->fullDefinition = null;

        return $this;
 <\s>
"
"<s>[INST] get definition [/INST]         return $this->fullDefinition ?? $this->getNativeDefinition();
 <\s>
"
"<s>[INST] get native definition [/INST]         return $this->definition ?? throw new LogicException(sprintf('Command class ""%s"" is not correctly initialized. You probably forgot to call the parent constructor.', static::class));
 <\s>
"
"<s>[INST] add argument [/INST]         $suggestedValues = 5 <= \func_num_args() ? func_get_arg(4) : [];
        if (!\is_array($suggestedValues) && !$suggestedValues instanceof \Closure) {
            throw new \TypeError(sprintf('Argument 5 passed to ""%s()"" must be array or \Closure, ""%s"" given.', __METHOD__, get_debug_type($suggestedValues)));
        }
        $this->definition->addArgument(new InputArgument($name, $mode, $description, $default, $suggestedValues));
        $this->fullDefinition?->addArgument(new InputArgument($name, $mode, $description, $default, $suggestedValues));

        return $this;
 <\s>
"
"<s>[INST] add option [/INST]         $suggestedValues = 6 <= \func_num_args() ? func_get_arg(5) : [];
        if (!\is_array($suggestedValues) && !$suggestedValues instanceof \Closure) {
            throw new \TypeError(sprintf('Argument 5 passed to ""%s()"" must be array or \Closure, ""%s"" given.', __METHOD__, get_debug_type($suggestedValues)));
        }
        $this->definition->addOption(new InputOption($name, $shortcut, $mode, $description, $default, $suggestedValues));
        $this->fullDefinition?->addOption(new InputOption($name, $shortcut, $mode, $description, $default, $suggestedValues));

        return $this;
 <\s>
"
"<s>[INST] set name [/INST]         $this->validateName($name);

        $this->name = $name;

        return $this;
 <\s>
"
"<s>[INST] set process title [/INST]         $this->processTitle = $title;

        return $this;
 <\s>
"
"<s>[INST] get name [/INST]         return $this->name;
 <\s>
"
"<s>[INST] set hidden [/INST]         $this->hidden = $hidden;

        return $this;
 <\s>
"
"<s>[INST] is hidden [/INST]         return $this->hidden;
 <\s>
"
"<s>[INST] set description [/INST]         $this->description = $description;

        return $this;
 <\s>
"
"<s>[INST] get description [/INST]         return $this->description;
 <\s>
"
"<s>[INST] set help [/INST]         $this->help = $help;

        return $this;
 <\s>
"
"<s>[INST] get help [/INST]         return $this->help;
 <\s>
"
"<s>[INST] get processed help [/INST]         $name = $this->name;
        $isSingleCommand = $this->application?->isSingleCommand();

        $placeholders = [
            '%command.name%',
            '%command.full_name%',
        ];
        $replacements = [
            $name,
            $isSingleCommand ? $_SERVER['PHP_SELF'] : $_SERVER['PHP_SELF'].' '.$name,
        ];

        return str_replace($placeholders, $replacements, $this->getHelp() ?: $this->getDescription());
 <\s>
"
"<s>[INST] set aliases [/INST]         $list = [];

        foreach ($aliases as $alias) {
            $this->validateName($alias);
            $list[] = $alias;
        }

        $this->aliases = \is_array($aliases) ? $aliases : $list;

        return $this;
 <\s>
"
"<s>[INST] get aliases [/INST]         return $this->aliases;
 <\s>
"
"<s>[INST] get synopsis [/INST]         $key = $short ? 'short' : 'long';

        if (!isset($this->synopsis[$key])) {
            $this->synopsis[$key] = trim(sprintf('%s %s', $this->name, $this->definition->getSynopsis($short)));
        }

        return $this->synopsis[$key];
 <\s>
"
"<s>[INST] add usage [/INST]         if (!str_starts_with($usage, $this->name)) {
            $usage = sprintf('%s %s', $this->name, $usage);
        }

        $this->usages[] = $usage;

        return $this;
 <\s>
"
"<s>[INST] get usages [/INST]         return $this->usages;
 <\s>
"
"<s>[INST] get helper [/INST]         if (null === $this->helperSet) {
            throw new LogicException(sprintf('Cannot retrieve helper ""%s"" because there is no HelperSet defined. Did you forget to add your command to the application or to set the application on the command using the setApplication() method? You can also set the HelperSet directly using the setHelperSet() method.', $name));
        }

        return $this->helperSet->get($name);
 <\s>
"
"<s>[INST] execute [/INST]         $this->io = new SymfonyStyle($input, $output);

        $sourceFile = $this->getProjectDir().ImportTleCommand::SOURCE;

        $this->sources = Yaml::parseFile($sourceFile);

        $newSources = $this->getSources();

        $diff = array_diff($newSources, $this->sources);

        if (empty($diff)) {
            $this->io->success('No new tle sources found');

            return Command::SUCCESS;
        }

        $this->io->writeln('');
        $this->io->writeln(\sprintf('Following new tle sources found and written to %s', $sourceFile));
        $this->io->writeln('');
        foreach ($diff as $url) {
            $this->io->writeln($url);
        }

        $this->io->writeln('');

        $sources = array_merge($this->sources, $diff);
        sort($sources);

        $yaml = Yaml::dump($sources);

        file_put_contents($sourceFile, $yaml);

        return Command::SUCCESS;
 <\s>
"
"<s>[INST] get sources [/INST]         $result = [];

        foreach (self::CATALOG as $catalog) {
            $response = (new Client())->request('GET', $catalog);

            $crawler = new Crawler($response->getBody()->getContents());

            /** @var DOMElement $anchor */
            foreach ($crawler->filter('a') as $anchor) {
                $href = $anchor->getAttribute('href');
                $path = parse_url($href, PHP_URL_PATH);

                if (null === $path) {
                    continue;
                }

                $extension = pathinfo($path, PATHINFO_EXTENSION);

                if ('txt' === $extension) {
                    if (null === parse_url($href, PHP_URL_HOST)) {
                        /* @noinspection PhpArrayKeyDoesNotMatchArrayShapeInspection */
                        if ('/' === $path[0]) {
                            $scheme = parse_url($catalog, PHP_URL_SCHEME);
                            $host = parse_url($catalog, PHP_URL_HOST);
                            $href = $scheme.'://'.$host.$href;
                        } else {
                            $href = $catalog.trim($href, '/');
                        }
                    }

                    if (!$this->isIgnored($href)) {
                        $this->io->writeln(\sprintf('Verifying url: %s', $href));
                        if ($this->isHealthy($href)) {
                            $result[] = $href;
                        }
                    }
                }
            }
        }

        return $result;
 <\s>
"
"<s>[INST] is ignored [/INST]         return in_array($url, self::IGNORED, false) || in_array($this->sources, self::IGNORED, false);
 <\s>
"
"<s>[INST] is healthy [/INST]         try {
            $response = (new Client())->request('GET', $url);

            return 200 === $response->getStatusCode();
        } catch (\Exception) {
            return false;
        }
 <\s>
"
"<s>[INST] get default name [/INST]         $class = static::class;

        if ($attribute = (new \ReflectionClass($class))->getAttributes(AsCommand::class)) {
            return $attribute[0]->newInstance()->name;
        }

        $r = new \ReflectionProperty($class, 'defaultName');

        if ($class !== $r->class || null === static::$defaultName) {
            return null;
        }

        trigger_deprecation('symfony/console', '6.1', 'Relying on the static property ""$defaultName"" for setting a command name is deprecated. Add the ""%s"" attribute to the ""%s"" class instead.', AsCommand::class, static::class);

        return static::$defaultName;
 <\s>
"
"<s>[INST] get default description [/INST]         $class = static::class;

        if ($attribute = (new \ReflectionClass($class))->getAttributes(AsCommand::class)) {
            return $attribute[0]->newInstance()->description;
        }

        $r = new \ReflectionProperty($class, 'defaultDescription');

        if ($class !== $r->class || null === static::$defaultDescription) {
            return null;
        }

        trigger_deprecation('symfony/console', '6.1', 'Relying on the static property ""$defaultDescription"" for setting a command description is deprecated. Add the ""%s"" attribute to the ""%s"" class instead.', AsCommand::class, static::class);

        return static::$defaultDescription;
 <\s>
"
"<s>[INST] __construct [/INST]         $this->definition = new InputDefinition();

        if (null === $name && null !== $name = static::getDefaultName()) {
            $aliases = explode('|', $name);

            if ('' === $name = array_shift($aliases)) {
                $this->setHidden(true);
                $name = array_shift($aliases);
            }

            $this->setAliases($aliases);
        }

        if (null !== $name) {
            $this->setName($name);
        }

        if ('' === $this->description) {
            $this->setDescription(static::getDefaultDescription() ?? '');
        }

        $this->configure();
 <\s>
"
"<s>[INST] ignore validation errors [/INST]         $this->ignoreValidationErrors = true;
 <\s>
"
"<s>[INST] set application [/INST]         if (1 > \func_num_args()) {
            trigger_deprecation('symfony/console', '6.2', 'Calling ""%s()"" without any arguments is deprecated, pass null explicitly instead.', __METHOD__);
        }
        $this->application = $application;
        if ($application) {
            $this->setHelperSet($application->getHelperSet());
        } else {
            $this->helperSet = null;
        }

        $this->fullDefinition = null;
 <\s>
"
"<s>[INST] set helper set [/INST]         $this->helperSet = $helperSet;
 <\s>
"
"<s>[INST] get helper set [/INST]         return $this->helperSet;
 <\s>
"
"<s>[INST] get application [/INST]         return $this->application;
 <\s>
"
"<s>[INST] is enabled [/INST]         return true;
 <\s>
"
"<s>[INST] configure [/INST]  <\s>
"
"<s>[INST] interact [/INST]  <\s>
"
"<s>[INST] initialize [/INST]  <\s>
"
"<s>[INST] run [/INST]         // add the application arguments and options
        $this->mergeApplicationDefinition();

        // bind the input against the command specific arguments/options
        try {
            $input->bind($this->getDefinition());
        } catch (ExceptionInterface $e) {
            if (!$this->ignoreValidationErrors) {
                throw $e;
            }
        }

        $this->initialize($input, $output);

        if (null !== $this->processTitle) {
            if (\function_exists('cli_set_process_title')) {
                if (!@cli_set_process_title($this->processTitle)) {
                    if ('Darwin' === \PHP_OS) {
                        $output->writeln('<comment>Running ""cli_set_process_title"" as an unprivileged user is not supported on MacOS.</comment>', OutputInterface::VERBOSITY_VERY_VERBOSE);
                    } else {
                        cli_set_process_title($this->processTitle);
                    }
                }
            } elseif (\function_exists('setproctitle')) {
                setproctitle($this->processTitle);
            } elseif (OutputInterface::VERBOSITY_VERY_VERBOSE === $output->getVerbosity()) {
                $output->writeln('<comment>Install the proctitle PECL to be able to change the process title.</comment>');
            }
        }

        if ($input->isInteractive()) {
            $this->interact($input, $output);
        }

        // The command name argument is often omitted when a command is executed directly with its run() method.
        // It would fail the validation if we didn't make sure the command argument is present,
        // since it's required by the application.
        if ($input->hasArgument('command') && null === $input->getArgument('command')) {
            $input->setArgument('command', $this->getName());
        }

        $input->validate();

        if ($this->code) {
            $statusCode = ($this->code)($input, $output);
        } else {
            $statusCode = $this->execute($input, $output);

            if (!\is_int($statusCode)) {
                throw new \TypeError(sprintf('Return value of ""%s::execute()"" must be of the type int, ""%s"" returned.', static::class, get_debug_type($statusCode)));
            }
        }

        return is_numeric($statusCode) ? (int) $statusCode : 0;
 <\s>
"
"<s>[INST] complete [/INST]         $definition = $this->getDefinition();
        if (CompletionInput::TYPE_OPTION_VALUE === $input->getCompletionType() && $definition->hasOption($input->getCompletionName())) {
            $definition->getOption($input->getCompletionName())->complete($input, $suggestions);
        } elseif (CompletionInput::TYPE_ARGUMENT_VALUE === $input->getCompletionType() && $definition->hasArgument($input->getCompletionName())) {
            $definition->getArgument($input->getCompletionName())->complete($input, $suggestions);
        }
 <\s>
"
"<s>[INST] set code [/INST]         if ($code instanceof \Closure) {
            $r = new \ReflectionFunction($code);
            if (null === $r->getClosureThis()) {
                set_error_handler(static function () {});
                try {
                    if ($c = \Closure::bind($code, $this)) {
                        $code = $c;
                    }
                } finally {
                    restore_error_handler();
                }
            }
        } else {
            $code = $code(...);
        }

        $this->code = $code;

        return $this;
 <\s>
"
"<s>[INST] merge application definition [/INST]         if (null === $this->application) {
            return;
        }

        $this->fullDefinition = new InputDefinition();
        $this->fullDefinition->setOptions($this->definition->getOptions());
        $this->fullDefinition->addOptions($this->application->getDefinition()->getOptions());

        if ($mergeArgs) {
            $this->fullDefinition->setArguments($this->application->getDefinition()->getArguments());
            $this->fullDefinition->addArguments($this->definition->getArguments());
        } else {
            $this->fullDefinition->setArguments($this->definition->getArguments());
        }
 <\s>
"
"<s>[INST] set definition [/INST]         if ($definition instanceof InputDefinition) {
            $this->definition = $definition;
        } else {
            $this->definition->setDefinition($definition);
        }

        $this->fullDefinition = null;

        return $this;
 <\s>
"
"<s>[INST] get definition [/INST]         return $this->fullDefinition ?? $this->getNativeDefinition();
 <\s>
"
"<s>[INST] get native definition [/INST]         return $this->definition ?? throw new LogicException(sprintf('Command class ""%s"" is not correctly initialized. You probably forgot to call the parent constructor.', static::class));
 <\s>
"
"<s>[INST] add argument [/INST]         $suggestedValues = 5 <= \func_num_args() ? func_get_arg(4) : [];
        if (!\is_array($suggestedValues) && !$suggestedValues instanceof \Closure) {
            throw new \TypeError(sprintf('Argument 5 passed to ""%s()"" must be array or \Closure, ""%s"" given.', __METHOD__, get_debug_type($suggestedValues)));
        }
        $this->definition->addArgument(new InputArgument($name, $mode, $description, $default, $suggestedValues));
        $this->fullDefinition?->addArgument(new InputArgument($name, $mode, $description, $default, $suggestedValues));

        return $this;
 <\s>
"
"<s>[INST] add option [/INST]         $suggestedValues = 6 <= \func_num_args() ? func_get_arg(5) : [];
        if (!\is_array($suggestedValues) && !$suggestedValues instanceof \Closure) {
            throw new \TypeError(sprintf('Argument 5 passed to ""%s()"" must be array or \Closure, ""%s"" given.', __METHOD__, get_debug_type($suggestedValues)));
        }
        $this->definition->addOption(new InputOption($name, $shortcut, $mode, $description, $default, $suggestedValues));
        $this->fullDefinition?->addOption(new InputOption($name, $shortcut, $mode, $description, $default, $suggestedValues));

        return $this;
 <\s>
"
"<s>[INST] set name [/INST]         $this->validateName($name);

        $this->name = $name;

        return $this;
 <\s>
"
"<s>[INST] set process title [/INST]         $this->processTitle = $title;

        return $this;
 <\s>
"
"<s>[INST] get name [/INST]         return $this->name;
 <\s>
"
"<s>[INST] set hidden [/INST]         $this->hidden = $hidden;

        return $this;
 <\s>
"
"<s>[INST] is hidden [/INST]         return $this->hidden;
 <\s>
"
"<s>[INST] set description [/INST]         $this->description = $description;

        return $this;
 <\s>
"
"<s>[INST] get description [/INST]         return $this->description;
 <\s>
"
"<s>[INST] set help [/INST]         $this->help = $help;

        return $this;
 <\s>
"
"<s>[INST] get help [/INST]         return $this->help;
 <\s>
"
"<s>[INST] get processed help [/INST]         $name = $this->name;
        $isSingleCommand = $this->application?->isSingleCommand();

        $placeholders = [
            '%command.name%',
            '%command.full_name%',
        ];
        $replacements = [
            $name,
            $isSingleCommand ? $_SERVER['PHP_SELF'] : $_SERVER['PHP_SELF'].' '.$name,
        ];

        return str_replace($placeholders, $replacements, $this->getHelp() ?: $this->getDescription());
 <\s>
"
"<s>[INST] set aliases [/INST]         $list = [];

        foreach ($aliases as $alias) {
            $this->validateName($alias);
            $list[] = $alias;
        }

        $this->aliases = \is_array($aliases) ? $aliases : $list;

        return $this;
 <\s>
"
"<s>[INST] get aliases [/INST]         return $this->aliases;
 <\s>
"
"<s>[INST] get synopsis [/INST]         $key = $short ? 'short' : 'long';

        if (!isset($this->synopsis[$key])) {
            $this->synopsis[$key] = trim(sprintf('%s %s', $this->name, $this->definition->getSynopsis($short)));
        }

        return $this->synopsis[$key];
 <\s>
"
"<s>[INST] add usage [/INST]         if (!str_starts_with($usage, $this->name)) {
            $usage = sprintf('%s %s', $this->name, $usage);
        }

        $this->usages[] = $usage;

        return $this;
 <\s>
"
"<s>[INST] get usages [/INST]         return $this->usages;
 <\s>
"
"<s>[INST] get helper [/INST]         if (null === $this->helperSet) {
            throw new LogicException(sprintf('Cannot retrieve helper ""%s"" because there is no HelperSet defined. Did you forget to add your command to the application or to set the application on the command using the setApplication() method? You can also set the HelperSet directly using the setHelperSet() method.', $name));
        }

        return $this->helperSet->get($name);
 <\s>
"
"<s>[INST] set parameter bag [/INST]         $this->parameters = $parameters;
 <\s>
"
"<s>[INST] get project dir [/INST]         return $this->parameters->get('kernel.project_dir');
 <\s>
"
"<s>[INST] set router [/INST]         $this->router = $router;
 <\s>
"
"<s>[INST] response [/INST]         return new JsonResponse(
            $data,
            Response::HTTP_OK,
        );
 <\s>
"
"<s>[INST] set container [/INST]         $previous = $this->container;
        $this->container = $container;

        return $previous;
 <\s>
"
"<s>[INST] get parameter [/INST]         if (!$this->container->has('parameter_bag')) {
            throw new ServiceNotFoundException('parameter_bag.', null, null, [], sprintf('The ""%s::getParameter()"" method is missing a parameter bag to work properly. Did you forget to register your controller as a service subscriber? This can be fixed either by using autoconfiguration or by manually wiring a ""parameter_bag"" in the service locator passed to the controller.', static::class));
        }

        return $this->container->get('parameter_bag')->get($name);
 <\s>
"
"<s>[INST] get subscribed services [/INST]         return [
            'router' => '?'.RouterInterface::class,
            'request_stack' => '?'.RequestStack::class,
            'http_kernel' => '?'.HttpKernelInterface::class,
            'serializer' => '?'.SerializerInterface::class,
            'security.authorization_checker' => '?'.AuthorizationCheckerInterface::class,
            'twig' => '?'.Environment::class,
            'form.factory' => '?'.FormFactoryInterface::class,
            'security.token_storage' => '?'.TokenStorageInterface::class,
            'security.csrf.token_manager' => '?'.CsrfTokenManagerInterface::class,
            'parameter_bag' => '?'.ContainerBagInterface::class,
            'web_link.http_header_serializer' => '?'.HttpHeaderSerializer::class,
        ];
 <\s>
"
"<s>[INST] generate url [/INST]         return $this->container->get('router')->generate($route, $parameters, $referenceType);
 <\s>
"
"<s>[INST] forward [/INST]         $request = $this->container->get('request_stack')->getCurrentRequest();
        $path['_controller'] = $controller;
        $subRequest = $request->duplicate($query, null, $path);

        return $this->container->get('http_kernel')->handle($subRequest, HttpKernelInterface::SUB_REQUEST);
 <\s>
"
"<s>[INST] redirect [/INST]         return new RedirectResponse($url, $status);
 <\s>
"
"<s>[INST] redirect to route [/INST]         return $this->redirect($this->generateUrl($route, $parameters), $status);
 <\s>
"
"<s>[INST] json [/INST]         if ($this->container->has('serializer')) {
            $json = $this->container->get('serializer')->serialize($data, 'json', array_merge([
                'json_encode_options' => JsonResponse::DEFAULT_ENCODING_OPTIONS,
            ], $context));

            return new JsonResponse($json, $status, $headers, true);
        }

        return new JsonResponse($data, $status, $headers);
 <\s>
"
"<s>[INST] file [/INST]         $response = new BinaryFileResponse($file);
        $response->setContentDisposition($disposition, $fileName ?? $response->getFile()->getFilename());

        return $response;
 <\s>
"
"<s>[INST] add flash [/INST]         try {
            $session = $this->container->get('request_stack')->getSession();
        } catch (SessionNotFoundException $e) {
            throw new \LogicException('You cannot use the addFlash method if sessions are disabled. Enable them in ""config/packages/framework.yaml"".', 0, $e);
        }

        if (!$session instanceof FlashBagAwareSessionInterface) {
            trigger_deprecation('symfony/framework-bundle', '6.2', 'Calling ""addFlash()"" method when the session does not implement %s is deprecated.', FlashBagAwareSessionInterface::class);
        }

        $session->getFlashBag()->add($type, $message);
 <\s>
"
"<s>[INST] is granted [/INST]         if (!$this->container->has('security.authorization_checker')) {
            throw new \LogicException('The SecurityBundle is not registered in your application. Try running ""composer require symfony/security-bundle"".');
        }

        return $this->container->get('security.authorization_checker')->isGranted($attribute, $subject);
 <\s>
"
"<s>[INST] deny access unless granted [/INST]         if (!$this->isGranted($attribute, $subject)) {
            $exception = $this->createAccessDeniedException($message);
            $exception->setAttributes([$attribute]);
            $exception->setSubject($subject);

            throw $exception;
        }
 <\s>
"
"<s>[INST] render view [/INST]         if (!$this->container->has('twig')) {
            throw new \LogicException('You cannot use the ""renderView"" method if the Twig Bundle is not available. Try running ""composer require symfony/twig-bundle"".');
        }

        foreach ($parameters as $k => $v) {
            if ($v instanceof FormInterface) {
                $parameters[$k] = $v->createView();
            }
        }

        return $this->container->get('twig')->render($view, $parameters);
 <\s>
"
"<s>[INST] render [/INST]         $content = $this->renderView($view, $parameters);
        $response ??= new Response();

        if (200 === $response->getStatusCode()) {
            foreach ($parameters as $v) {
                if ($v instanceof FormInterface && $v->isSubmitted() && !$v->isValid()) {
                    $response->setStatusCode(422);
                    break;
                }
            }
        }

        $response->setContent($content);

        return $response;
 <\s>
"
"<s>[INST] render form [/INST]         trigger_deprecation('symfony/framework-bundle', '6.2', 'The ""%s::renderForm()"" method is deprecated, use ""render()"" instead.', get_debug_type($this));

        return $this->render($view, $parameters, $response);
 <\s>
"
"<s>[INST] stream [/INST]         if (!$this->container->has('twig')) {
            throw new \LogicException('You cannot use the ""stream"" method if the Twig Bundle is not available. Try running ""composer require symfony/twig-bundle"".');
        }

        $twig = $this->container->get('twig');

        $callback = function () use ($twig, $view, $parameters) {
            $twig->display($view, $parameters);
        };

        if (null === $response) {
            return new StreamedResponse($callback);
        }

        $response->setCallback($callback);

        return $response;
 <\s>
"
"<s>[INST] create not found exception [/INST]         return new NotFoundHttpException($message, $previous);
 <\s>
"
"<s>[INST] create access denied exception [/INST]         if (!class_exists(AccessDeniedException::class)) {
            throw new \LogicException('You cannot use the ""createAccessDeniedException"" method if the Security component is not available. Try running ""composer require symfony/security-bundle"".');
        }

        return new AccessDeniedException($message, $previous);
 <\s>
"
"<s>[INST] create form [/INST]         return $this->container->get('form.factory')->create($type, $data, $options);
 <\s>
"
"<s>[INST] create form builder [/INST]         return $this->container->get('form.factory')->createBuilder(FormType::class, $data, $options);
 <\s>
"
"<s>[INST] get user [/INST]         if (!$this->container->has('security.token_storage')) {
            throw new \LogicException('The SecurityBundle is not registered in your application. Try running ""composer require symfony/security-bundle"".');
        }

        if (null === $token = $this->container->get('security.token_storage')->getToken()) {
            return null;
        }

        return $token->getUser();
 <\s>
"
"<s>[INST] is csrf token valid [/INST]         if (!$this->container->has('security.csrf.token_manager')) {
            throw new \LogicException('CSRF protection is not enabled in your application. Enable it with the ""csrf_protection"" key in ""config/packages/framework.yaml"".');
        }

        return $this->container->get('security.csrf.token_manager')->isTokenValid(new CsrfToken($id, $token));
 <\s>
"
"<s>[INST] add link [/INST]         if (!class_exists(AddLinkHeaderListener::class)) {
            throw new \LogicException('You cannot use the ""addLink"" method if the WebLink component is not available. Try running ""composer require symfony/web-link"".');
        }

        if (null === $linkProvider = $request->attributes->get('_links')) {
            $request->attributes->set('_links', new GenericLinkProvider([$link]));

            return;
        }

        $request->attributes->set('_links', $linkProvider->withLink($link));
 <\s>
"
"<s>[INST] send early hints [/INST]         if (!$this->container->has('web_link.http_header_serializer')) {
            throw new \LogicException('You cannot use the ""sendEarlyHints"" method if the WebLink component is not available. Try running ""composer require symfony/web-link"".');
        }

        $response ??= new Response();

        $populatedLinks = [];
        foreach ($links as $link) {
            if ($link instanceof EvolvableLinkInterface && !$link->getRels()) {
                $link = $link->withRel('preload');
            }

            $populatedLinks[] = $link;
        }

        $response->headers->set('Link', $this->container->get('web_link.http_header_serializer')->serialize($populatedLinks), false);
        $response->sendHeaders(103);

        return $response;
 <\s>
"
"<s>[INST] __construct [/INST]  <\s>
"
"<s>[INST] docs [/INST]         return new Response(file_get_contents($this->getProjectDir().'/public/index.html'));
 <\s>
"
"<s>[INST] get json [/INST]         return new JsonResponse($this->service->get('/etc/custom/tle.json'), Response::HTTP_OK, ['Access-Control-Allow-Origin' => '*']);
 <\s>
"
"<s>[INST] set container [/INST]         $previous = $this->container;
        $this->container = $container;

        return $previous;
 <\s>
"
"<s>[INST] get parameter [/INST]         if (!$this->container->has('parameter_bag')) {
            throw new ServiceNotFoundException('parameter_bag.', null, null, [], sprintf('The ""%s::getParameter()"" method is missing a parameter bag to work properly. Did you forget to register your controller as a service subscriber? This can be fixed either by using autoconfiguration or by manually wiring a ""parameter_bag"" in the service locator passed to the controller.', static::class));
        }

        return $this->container->get('parameter_bag')->get($name);
 <\s>
"
"<s>[INST] get subscribed services [/INST]         return [
            'router' => '?'.RouterInterface::class,
            'request_stack' => '?'.RequestStack::class,
            'http_kernel' => '?'.HttpKernelInterface::class,
            'serializer' => '?'.SerializerInterface::class,
            'security.authorization_checker' => '?'.AuthorizationCheckerInterface::class,
            'twig' => '?'.Environment::class,
            'form.factory' => '?'.FormFactoryInterface::class,
            'security.token_storage' => '?'.TokenStorageInterface::class,
            'security.csrf.token_manager' => '?'.CsrfTokenManagerInterface::class,
            'parameter_bag' => '?'.ContainerBagInterface::class,
            'web_link.http_header_serializer' => '?'.HttpHeaderSerializer::class,
        ];
 <\s>
"
"<s>[INST] generate url [/INST]         return $this->container->get('router')->generate($route, $parameters, $referenceType);
 <\s>
"
"<s>[INST] forward [/INST]         $request = $this->container->get('request_stack')->getCurrentRequest();
        $path['_controller'] = $controller;
        $subRequest = $request->duplicate($query, null, $path);

        return $this->container->get('http_kernel')->handle($subRequest, HttpKernelInterface::SUB_REQUEST);
 <\s>
"
"<s>[INST] redirect [/INST]         return new RedirectResponse($url, $status);
 <\s>
"
"<s>[INST] redirect to route [/INST]         return $this->redirect($this->generateUrl($route, $parameters), $status);
 <\s>
"
"<s>[INST] json [/INST]         if ($this->container->has('serializer')) {
            $json = $this->container->get('serializer')->serialize($data, 'json', array_merge([
                'json_encode_options' => JsonResponse::DEFAULT_ENCODING_OPTIONS,
            ], $context));

            return new JsonResponse($json, $status, $headers, true);
        }

        return new JsonResponse($data, $status, $headers);
 <\s>
"
"<s>[INST] file [/INST]         $response = new BinaryFileResponse($file);
        $response->setContentDisposition($disposition, $fileName ?? $response->getFile()->getFilename());

        return $response;
 <\s>
"
"<s>[INST] add flash [/INST]         try {
            $session = $this->container->get('request_stack')->getSession();
        } catch (SessionNotFoundException $e) {
            throw new \LogicException('You cannot use the addFlash method if sessions are disabled. Enable them in ""config/packages/framework.yaml"".', 0, $e);
        }

        if (!$session instanceof FlashBagAwareSessionInterface) {
            trigger_deprecation('symfony/framework-bundle', '6.2', 'Calling ""addFlash()"" method when the session does not implement %s is deprecated.', FlashBagAwareSessionInterface::class);
        }

        $session->getFlashBag()->add($type, $message);
 <\s>
"
"<s>[INST] is granted [/INST]         if (!$this->container->has('security.authorization_checker')) {
            throw new \LogicException('The SecurityBundle is not registered in your application. Try running ""composer require symfony/security-bundle"".');
        }

        return $this->container->get('security.authorization_checker')->isGranted($attribute, $subject);
 <\s>
"
"<s>[INST] deny access unless granted [/INST]         if (!$this->isGranted($attribute, $subject)) {
            $exception = $this->createAccessDeniedException($message);
            $exception->setAttributes([$attribute]);
            $exception->setSubject($subject);

            throw $exception;
        }
 <\s>
"
"<s>[INST] render view [/INST]         if (!$this->container->has('twig')) {
            throw new \LogicException('You cannot use the ""renderView"" method if the Twig Bundle is not available. Try running ""composer require symfony/twig-bundle"".');
        }

        foreach ($parameters as $k => $v) {
            if ($v instanceof FormInterface) {
                $parameters[$k] = $v->createView();
            }
        }

        return $this->container->get('twig')->render($view, $parameters);
 <\s>
"
"<s>[INST] render [/INST]         $content = $this->renderView($view, $parameters);
        $response ??= new Response();

        if (200 === $response->getStatusCode()) {
            foreach ($parameters as $v) {
                if ($v instanceof FormInterface && $v->isSubmitted() && !$v->isValid()) {
                    $response->setStatusCode(422);
                    break;
                }
            }
        }

        $response->setContent($content);

        return $response;
 <\s>
"
"<s>[INST] render form [/INST]         trigger_deprecation('symfony/framework-bundle', '6.2', 'The ""%s::renderForm()"" method is deprecated, use ""render()"" instead.', get_debug_type($this));

        return $this->render($view, $parameters, $response);
 <\s>
"
"<s>[INST] stream [/INST]         if (!$this->container->has('twig')) {
            throw new \LogicException('You cannot use the ""stream"" method if the Twig Bundle is not available. Try running ""composer require symfony/twig-bundle"".');
        }

        $twig = $this->container->get('twig');

        $callback = function () use ($twig, $view, $parameters) {
            $twig->display($view, $parameters);
        };

        if (null === $response) {
            return new StreamedResponse($callback);
        }

        $response->setCallback($callback);

        return $response;
 <\s>
"
"<s>[INST] create not found exception [/INST]         return new NotFoundHttpException($message, $previous);
 <\s>
"
"<s>[INST] create access denied exception [/INST]         if (!class_exists(AccessDeniedException::class)) {
            throw new \LogicException('You cannot use the ""createAccessDeniedException"" method if the Security component is not available. Try running ""composer require symfony/security-bundle"".');
        }

        return new AccessDeniedException($message, $previous);
 <\s>
"
"<s>[INST] create form [/INST]         return $this->container->get('form.factory')->create($type, $data, $options);
 <\s>
"
"<s>[INST] create form builder [/INST]         return $this->container->get('form.factory')->createBuilder(FormType::class, $data, $options);
 <\s>
"
"<s>[INST] get user [/INST]         if (!$this->container->has('security.token_storage')) {
            throw new \LogicException('The SecurityBundle is not registered in your application. Try running ""composer require symfony/security-bundle"".');
        }

        if (null === $token = $this->container->get('security.token_storage')->getToken()) {
            return null;
        }

        return $token->getUser();
 <\s>
"
"<s>[INST] is csrf token valid [/INST]         if (!$this->container->has('security.csrf.token_manager')) {
            throw new \LogicException('CSRF protection is not enabled in your application. Enable it with the ""csrf_protection"" key in ""config/packages/framework.yaml"".');
        }

        return $this->container->get('security.csrf.token_manager')->isTokenValid(new CsrfToken($id, $token));
 <\s>
"
"<s>[INST] add link [/INST]         if (!class_exists(AddLinkHeaderListener::class)) {
            throw new \LogicException('You cannot use the ""addLink"" method if the WebLink component is not available. Try running ""composer require symfony/web-link"".');
        }

        if (null === $linkProvider = $request->attributes->get('_links')) {
            $request->attributes->set('_links', new GenericLinkProvider([$link]));

            return;
        }

        $request->attributes->set('_links', $linkProvider->withLink($link));
 <\s>
"
"<s>[INST] send early hints [/INST]         if (!$this->container->has('web_link.http_header_serializer')) {
            throw new \LogicException('You cannot use the ""sendEarlyHints"" method if the WebLink component is not available. Try running ""composer require symfony/web-link"".');
        }

        $response ??= new Response();

        $populatedLinks = [];
        foreach ($links as $link) {
            if ($link instanceof EvolvableLinkInterface && !$link->getRels()) {
                $link = $link->withRel('preload');
            }

            $populatedLinks[] = $link;
        }

        $response->headers->set('Link', $this->container->get('web_link.http_header_serializer')->serialize($populatedLinks), false);
        $response->sendHeaders(103);

        return $response;
 <\s>
"
"<s>[INST] set parameter bag [/INST]         $this->parameters = $parameters;
 <\s>
"
"<s>[INST] get project dir [/INST]         return $this->parameters->get('kernel.project_dir');
 <\s>
"
"<s>[INST] __construct [/INST]         protected NormalizerInterface $normalizer,
        protected FlyOverService $service
    ) {
 <\s>
"
"<s>[INST] flyover [/INST]     ): JsonResponse {
        $observer = $request->getObserver();
        $tle = $request->getTle();

        $date = $request->getDateTime();

        $this->service
            ->setObserver($observer)
            ->setTle($tle);

        $results = $this->service->getPasses($date, $request->filterVisible());

        $parameters = [
            'latitude' => $observer->latitude,
            'longitude' => $observer->longitude,
            'only_visible' => $request->filterVisible(),
            'date' => $date->format(DateTimeInterface::ATOM),
        ];

        $url = $this->router->generate(
            'tle_flyover',
            [...$request->request->all(), 'id' => $request->getId(), ...$parameters],
            UrlGeneratorInterface::ABSOLUTE_URL
        );

        $parameters['satelliteId'] = $request->getId();

        $members = $this->normalizer->normalize($results, null, ['timezone' => $observer->getTimezone()]);

        foreach ($members as $index => &$member) {
            $item = [
                '@id' => $this->generateUrl('tle_flyover_details', [
                    'id' => $request->getId(),
                    'passId' => $index + 1,
                    'latitude' => $observer->latitude,
                    'longitude' => $observer->longitude,
                    'only_visible' => $request->filterVisible(),
                    'date' => $date->format(DateTimeInterface::ATOM),
                ], UrlGeneratorInterface::ABSOLUTE_URL),
            ];

            $member = $item + $member;
        }

        return $this->response(
            [
                '@context' => self::HYDRA_CONTEXT,
                '@id' => $url,
                '@type' => 'SatelliteFlyOverCollection',
                'observer' => $this->normalizer->normalize($observer),
                'tle' => $this->normalizer->normalize($tle),
                'member' => $members,
                'parameters' => $parameters,
            ]
        );
 <\s>
"
"<s>[INST] flyover details [/INST]         FlyOverRequest $request,
    ): JsonResponse {
        $observer = $request->getObserver();
        $tle = $request->getTle();

        $this->service
            ->setObserver($observer)
            ->setTle($tle);

        $date = $request->getDateTime();

        $results = $this->service->getPasses($date, $request->filterVisible());

        $pass = $results[$passId - 1] ?? null;

        if (null === $pass) {
            throw new NotFoundHttpException('Unable to find requested flyover details');
        }

        $url = $this->router->generate(
            'tle_flyover_details',
            [
                ...$request->request->all(),
                'id' => $request->getId(),
                'passId' => $passId,
                'latitude' => $observer->latitude,
                'longitude' => $observer->longitude,
                'only_visible' => $request->filterVisible(),
                'date' => $date->format(DateTimeInterface::ATOM),
            ],
            UrlGeneratorInterface::ABSOLUTE_URL
        );

        return $this->response(
            [
                '@context' => self::HYDRA_CONTEXT,
                '@id' => $url,
                'observer' => $this->normalizer->normalize($observer),
                'tle' => $this->normalizer->normalize($tle),
                ...$this->normalizer->normalize($pass, null, ['timezone' => $observer->getTimezone(), 'details' => true]
                ),
            ]
        );
 <\s>
"
"<s>[INST] set router [/INST]         $this->router = $router;
 <\s>
"
"<s>[INST] response [/INST]         return new JsonResponse(
            $data,
            Response::HTTP_OK,
        );
 <\s>
"
"<s>[INST] set container [/INST]         $previous = $this->container;
        $this->container = $container;

        return $previous;
 <\s>
"
"<s>[INST] get parameter [/INST]         if (!$this->container->has('parameter_bag')) {
            throw new ServiceNotFoundException('parameter_bag.', null, null, [], sprintf('The ""%s::getParameter()"" method is missing a parameter bag to work properly. Did you forget to register your controller as a service subscriber? This can be fixed either by using autoconfiguration or by manually wiring a ""parameter_bag"" in the service locator passed to the controller.', static::class));
        }

        return $this->container->get('parameter_bag')->get($name);
 <\s>
"
"<s>[INST] get subscribed services [/INST]         return [
            'router' => '?'.RouterInterface::class,
            'request_stack' => '?'.RequestStack::class,
            'http_kernel' => '?'.HttpKernelInterface::class,
            'serializer' => '?'.SerializerInterface::class,
            'security.authorization_checker' => '?'.AuthorizationCheckerInterface::class,
            'twig' => '?'.Environment::class,
            'form.factory' => '?'.FormFactoryInterface::class,
            'security.token_storage' => '?'.TokenStorageInterface::class,
            'security.csrf.token_manager' => '?'.CsrfTokenManagerInterface::class,
            'parameter_bag' => '?'.ContainerBagInterface::class,
            'web_link.http_header_serializer' => '?'.HttpHeaderSerializer::class,
        ];
 <\s>
"
"<s>[INST] generate url [/INST]         return $this->container->get('router')->generate($route, $parameters, $referenceType);
 <\s>
"
"<s>[INST] forward [/INST]         $request = $this->container->get('request_stack')->getCurrentRequest();
        $path['_controller'] = $controller;
        $subRequest = $request->duplicate($query, null, $path);

        return $this->container->get('http_kernel')->handle($subRequest, HttpKernelInterface::SUB_REQUEST);
 <\s>
"
"<s>[INST] redirect [/INST]         return new RedirectResponse($url, $status);
 <\s>
"
"<s>[INST] redirect to route [/INST]         return $this->redirect($this->generateUrl($route, $parameters), $status);
 <\s>
"
"<s>[INST] json [/INST]         if ($this->container->has('serializer')) {
            $json = $this->container->get('serializer')->serialize($data, 'json', array_merge([
                'json_encode_options' => JsonResponse::DEFAULT_ENCODING_OPTIONS,
            ], $context));

            return new JsonResponse($json, $status, $headers, true);
        }

        return new JsonResponse($data, $status, $headers);
 <\s>
"
"<s>[INST] file [/INST]         $response = new BinaryFileResponse($file);
        $response->setContentDisposition($disposition, $fileName ?? $response->getFile()->getFilename());

        return $response;
 <\s>
"
"<s>[INST] add flash [/INST]         try {
            $session = $this->container->get('request_stack')->getSession();
        } catch (SessionNotFoundException $e) {
            throw new \LogicException('You cannot use the addFlash method if sessions are disabled. Enable them in ""config/packages/framework.yaml"".', 0, $e);
        }

        if (!$session instanceof FlashBagAwareSessionInterface) {
            trigger_deprecation('symfony/framework-bundle', '6.2', 'Calling ""addFlash()"" method when the session does not implement %s is deprecated.', FlashBagAwareSessionInterface::class);
        }

        $session->getFlashBag()->add($type, $message);
 <\s>
"
"<s>[INST] is granted [/INST]         if (!$this->container->has('security.authorization_checker')) {
            throw new \LogicException('The SecurityBundle is not registered in your application. Try running ""composer require symfony/security-bundle"".');
        }

        return $this->container->get('security.authorization_checker')->isGranted($attribute, $subject);
 <\s>
"
"<s>[INST] deny access unless granted [/INST]         if (!$this->isGranted($attribute, $subject)) {
            $exception = $this->createAccessDeniedException($message);
            $exception->setAttributes([$attribute]);
            $exception->setSubject($subject);

            throw $exception;
        }
 <\s>
"
"<s>[INST] render view [/INST]         if (!$this->container->has('twig')) {
            throw new \LogicException('You cannot use the ""renderView"" method if the Twig Bundle is not available. Try running ""composer require symfony/twig-bundle"".');
        }

        foreach ($parameters as $k => $v) {
            if ($v instanceof FormInterface) {
                $parameters[$k] = $v->createView();
            }
        }

        return $this->container->get('twig')->render($view, $parameters);
 <\s>
"
"<s>[INST] render [/INST]         $content = $this->renderView($view, $parameters);
        $response ??= new Response();

        if (200 === $response->getStatusCode()) {
            foreach ($parameters as $v) {
                if ($v instanceof FormInterface && $v->isSubmitted() && !$v->isValid()) {
                    $response->setStatusCode(422);
                    break;
                }
            }
        }

        $response->setContent($content);

        return $response;
 <\s>
"
"<s>[INST] render form [/INST]         trigger_deprecation('symfony/framework-bundle', '6.2', 'The ""%s::renderForm()"" method is deprecated, use ""render()"" instead.', get_debug_type($this));

        return $this->render($view, $parameters, $response);
 <\s>
"
"<s>[INST] stream [/INST]         if (!$this->container->has('twig')) {
            throw new \LogicException('You cannot use the ""stream"" method if the Twig Bundle is not available. Try running ""composer require symfony/twig-bundle"".');
        }

        $twig = $this->container->get('twig');

        $callback = function () use ($twig, $view, $parameters) {
            $twig->display($view, $parameters);
        };

        if (null === $response) {
            return new StreamedResponse($callback);
        }

        $response->setCallback($callback);

        return $response;
 <\s>
"
"<s>[INST] create not found exception [/INST]         return new NotFoundHttpException($message, $previous);
 <\s>
"
"<s>[INST] create access denied exception [/INST]         if (!class_exists(AccessDeniedException::class)) {
            throw new \LogicException('You cannot use the ""createAccessDeniedException"" method if the Security component is not available. Try running ""composer require symfony/security-bundle"".');
        }

        return new AccessDeniedException($message, $previous);
 <\s>
"
"<s>[INST] create form [/INST]         return $this->container->get('form.factory')->create($type, $data, $options);
 <\s>
"
"<s>[INST] create form builder [/INST]         return $this->container->get('form.factory')->createBuilder(FormType::class, $data, $options);
 <\s>
"
"<s>[INST] get user [/INST]         if (!$this->container->has('security.token_storage')) {
            throw new \LogicException('The SecurityBundle is not registered in your application. Try running ""composer require symfony/security-bundle"".');
        }

        if (null === $token = $this->container->get('security.token_storage')->getToken()) {
            return null;
        }

        return $token->getUser();
 <\s>
"
"<s>[INST] is csrf token valid [/INST]         if (!$this->container->has('security.csrf.token_manager')) {
            throw new \LogicException('CSRF protection is not enabled in your application. Enable it with the ""csrf_protection"" key in ""config/packages/framework.yaml"".');
        }

        return $this->container->get('security.csrf.token_manager')->isTokenValid(new CsrfToken($id, $token));
 <\s>
"
"<s>[INST] add link [/INST]         if (!class_exists(AddLinkHeaderListener::class)) {
            throw new \LogicException('You cannot use the ""addLink"" method if the WebLink component is not available. Try running ""composer require symfony/web-link"".');
        }

        if (null === $linkProvider = $request->attributes->get('_links')) {
            $request->attributes->set('_links', new GenericLinkProvider([$link]));

            return;
        }

        $request->attributes->set('_links', $linkProvider->withLink($link));
 <\s>
"
"<s>[INST] send early hints [/INST]         if (!$this->container->has('web_link.http_header_serializer')) {
            throw new \LogicException('You cannot use the ""sendEarlyHints"" method if the WebLink component is not available. Try running ""composer require symfony/web-link"".');
        }

        $response ??= new Response();

        $populatedLinks = [];
        foreach ($links as $link) {
            if ($link instanceof EvolvableLinkInterface && !$link->getRels()) {
                $link = $link->withRel('preload');
            }

            $populatedLinks[] = $link;
        }

        $response->headers->set('Link', $this->container->get('web_link.http_header_serializer')->serialize($populatedLinks), false);
        $response->sendHeaders(103);

        return $response;
 <\s>
"
"<s>[INST] __construct [/INST]         $this->propagator = new \Predict_SGPSDP();
 <\s>
"
"<s>[INST] propagate [/INST]         NormalizerInterface $normalizer
    ): JsonResponse {
        $tle = $request->getTle();

        $tleModel = new TleModel($tle->getLine1(), $tle->getLine2(), $tle->getName());
        $sat = new \Predict_Sat(new \Predict_TLE($tle->getName(), $tle->getLine1(), $tle->getLine2()));

        $datetime = $request->getDateTime();
        $deltaT = ($datetime->getTimestamp() - $tleModel->epochDateTime()->getTimestamp()) / 60; // minutes

        $algorithm = ($tleModel->period() / 60) > self::DEEP_SATELLITE_PERIOD ? PropagatorAlgorithm::SDP4 : PropagatorAlgorithm::SGP4;

        $this->propagator->$algorithm($sat, $deltaT);

        \Predict_Math::Convert_Sat_State($sat->pos, $sat->vel);

        $sat_geodetic = new \Predict_Geodetic();
        \Predict_SGPObs::Calculate_LatLonAlt(\Predict_Time::unix2daynum($datetime->getTimestamp()), $sat->pos, $sat_geodetic);

        $sat_geodetic->lat = rad2deg($sat_geodetic->lat);
        $sat_geodetic->lon = rad2deg($sat_geodetic->lon);

        $parameters = [
            'date' => $datetime->format(\DateTimeInterface::ATOM),
        ];

        $url = $this->router->generate(
            'tle_propagate',
            array_merge($request->request->all(), $parameters, ['id' => $request->getId()]),
            UrlGeneratorInterface::ABSOLUTE_URL
        );

        $parameters['satelliteId'] = $request->getId();

        $data = [
            '@context' => self::HYDRA_CONTEXT,
            '@id' => $url,
            '@type' => 'SatellitePropagationResult',
            'tle' => $tle,
            'algorithm' => $algorithm,
            'vector' => [
                'reference_frame' => 'ECI',
                'position' => [
                    'x' => $sat->pos->x,
                    'y' => $sat->pos->y,
                    'z' => $sat->pos->z,
                    'r' => $sat->pos->w,
                    'unit' => 'km',
                ],
                'velocity' => [
                    'x' => $sat->vel->x,
                    'y' => $sat->vel->y,
                    'z' => $sat->vel->z,
                    'r' => $sat->vel->w,
                    'unit' => 'km/s',
                ],
            ],
            'geodetic' => [
                'latitude' => $sat_geodetic->lat,
                'longitude' => $sat_geodetic->lon,
                'altitude' => $sat_geodetic->alt,
            ],
            'parameters' => $parameters,
        ];

        return $this->response(
            $normalizer->normalize($data)
        );
 <\s>
"
"<s>[INST] set router [/INST]         $this->router = $router;
 <\s>
"
"<s>[INST] response [/INST]         return new JsonResponse(
            $data,
            Response::HTTP_OK,
        );
 <\s>
"
"<s>[INST] set container [/INST]         $previous = $this->container;
        $this->container = $container;

        return $previous;
 <\s>
"
"<s>[INST] get parameter [/INST]         if (!$this->container->has('parameter_bag')) {
            throw new ServiceNotFoundException('parameter_bag.', null, null, [], sprintf('The ""%s::getParameter()"" method is missing a parameter bag to work properly. Did you forget to register your controller as a service subscriber? This can be fixed either by using autoconfiguration or by manually wiring a ""parameter_bag"" in the service locator passed to the controller.', static::class));
        }

        return $this->container->get('parameter_bag')->get($name);
 <\s>
"
"<s>[INST] get subscribed services [/INST]         return [
            'router' => '?'.RouterInterface::class,
            'request_stack' => '?'.RequestStack::class,
            'http_kernel' => '?'.HttpKernelInterface::class,
            'serializer' => '?'.SerializerInterface::class,
            'security.authorization_checker' => '?'.AuthorizationCheckerInterface::class,
            'twig' => '?'.Environment::class,
            'form.factory' => '?'.FormFactoryInterface::class,
            'security.token_storage' => '?'.TokenStorageInterface::class,
            'security.csrf.token_manager' => '?'.CsrfTokenManagerInterface::class,
            'parameter_bag' => '?'.ContainerBagInterface::class,
            'web_link.http_header_serializer' => '?'.HttpHeaderSerializer::class,
        ];
 <\s>
"
"<s>[INST] generate url [/INST]         return $this->container->get('router')->generate($route, $parameters, $referenceType);
 <\s>
"
"<s>[INST] forward [/INST]         $request = $this->container->get('request_stack')->getCurrentRequest();
        $path['_controller'] = $controller;
        $subRequest = $request->duplicate($query, null, $path);

        return $this->container->get('http_kernel')->handle($subRequest, HttpKernelInterface::SUB_REQUEST);
 <\s>
"
"<s>[INST] redirect [/INST]         return new RedirectResponse($url, $status);
 <\s>
"
"<s>[INST] redirect to route [/INST]         return $this->redirect($this->generateUrl($route, $parameters), $status);
 <\s>
"
"<s>[INST] json [/INST]         if ($this->container->has('serializer')) {
            $json = $this->container->get('serializer')->serialize($data, 'json', array_merge([
                'json_encode_options' => JsonResponse::DEFAULT_ENCODING_OPTIONS,
            ], $context));

            return new JsonResponse($json, $status, $headers, true);
        }

        return new JsonResponse($data, $status, $headers);
 <\s>
"
"<s>[INST] file [/INST]         $response = new BinaryFileResponse($file);
        $response->setContentDisposition($disposition, $fileName ?? $response->getFile()->getFilename());

        return $response;
 <\s>
"
"<s>[INST] add flash [/INST]         try {
            $session = $this->container->get('request_stack')->getSession();
        } catch (SessionNotFoundException $e) {
            throw new \LogicException('You cannot use the addFlash method if sessions are disabled. Enable them in ""config/packages/framework.yaml"".', 0, $e);
        }

        if (!$session instanceof FlashBagAwareSessionInterface) {
            trigger_deprecation('symfony/framework-bundle', '6.2', 'Calling ""addFlash()"" method when the session does not implement %s is deprecated.', FlashBagAwareSessionInterface::class);
        }

        $session->getFlashBag()->add($type, $message);
 <\s>
"
"<s>[INST] is granted [/INST]         if (!$this->container->has('security.authorization_checker')) {
            throw new \LogicException('The SecurityBundle is not registered in your application. Try running ""composer require symfony/security-bundle"".');
        }

        return $this->container->get('security.authorization_checker')->isGranted($attribute, $subject);
 <\s>
"
"<s>[INST] deny access unless granted [/INST]         if (!$this->isGranted($attribute, $subject)) {
            $exception = $this->createAccessDeniedException($message);
            $exception->setAttributes([$attribute]);
            $exception->setSubject($subject);

            throw $exception;
        }
 <\s>
"
"<s>[INST] render view [/INST]         if (!$this->container->has('twig')) {
            throw new \LogicException('You cannot use the ""renderView"" method if the Twig Bundle is not available. Try running ""composer require symfony/twig-bundle"".');
        }

        foreach ($parameters as $k => $v) {
            if ($v instanceof FormInterface) {
                $parameters[$k] = $v->createView();
            }
        }

        return $this->container->get('twig')->render($view, $parameters);
 <\s>
"
"<s>[INST] render [/INST]         $content = $this->renderView($view, $parameters);
        $response ??= new Response();

        if (200 === $response->getStatusCode()) {
            foreach ($parameters as $v) {
                if ($v instanceof FormInterface && $v->isSubmitted() && !$v->isValid()) {
                    $response->setStatusCode(422);
                    break;
                }
            }
        }

        $response->setContent($content);

        return $response;
 <\s>
"
"<s>[INST] render form [/INST]         trigger_deprecation('symfony/framework-bundle', '6.2', 'The ""%s::renderForm()"" method is deprecated, use ""render()"" instead.', get_debug_type($this));

        return $this->render($view, $parameters, $response);
 <\s>
"
"<s>[INST] stream [/INST]         if (!$this->container->has('twig')) {
            throw new \LogicException('You cannot use the ""stream"" method if the Twig Bundle is not available. Try running ""composer require symfony/twig-bundle"".');
        }

        $twig = $this->container->get('twig');

        $callback = function () use ($twig, $view, $parameters) {
            $twig->display($view, $parameters);
        };

        if (null === $response) {
            return new StreamedResponse($callback);
        }

        $response->setCallback($callback);

        return $response;
 <\s>
"
"<s>[INST] create not found exception [/INST]         return new NotFoundHttpException($message, $previous);
 <\s>
"
"<s>[INST] create access denied exception [/INST]         if (!class_exists(AccessDeniedException::class)) {
            throw new \LogicException('You cannot use the ""createAccessDeniedException"" method if the Security component is not available. Try running ""composer require symfony/security-bundle"".');
        }

        return new AccessDeniedException($message, $previous);
 <\s>
"
"<s>[INST] create form [/INST]         return $this->container->get('form.factory')->create($type, $data, $options);
 <\s>
"
"<s>[INST] create form builder [/INST]         return $this->container->get('form.factory')->createBuilder(FormType::class, $data, $options);
 <\s>
"
"<s>[INST] get user [/INST]         if (!$this->container->has('security.token_storage')) {
            throw new \LogicException('The SecurityBundle is not registered in your application. Try running ""composer require symfony/security-bundle"".');
        }

        if (null === $token = $this->container->get('security.token_storage')->getToken()) {
            return null;
        }

        return $token->getUser();
 <\s>
"
"<s>[INST] is csrf token valid [/INST]         if (!$this->container->has('security.csrf.token_manager')) {
            throw new \LogicException('CSRF protection is not enabled in your application. Enable it with the ""csrf_protection"" key in ""config/packages/framework.yaml"".');
        }

        return $this->container->get('security.csrf.token_manager')->isTokenValid(new CsrfToken($id, $token));
 <\s>
"
"<s>[INST] add link [/INST]         if (!class_exists(AddLinkHeaderListener::class)) {
            throw new \LogicException('You cannot use the ""addLink"" method if the WebLink component is not available. Try running ""composer require symfony/web-link"".');
        }

        if (null === $linkProvider = $request->attributes->get('_links')) {
            $request->attributes->set('_links', new GenericLinkProvider([$link]));

            return;
        }

        $request->attributes->set('_links', $linkProvider->withLink($link));
 <\s>
"
"<s>[INST] send early hints [/INST]         if (!$this->container->has('web_link.http_header_serializer')) {
            throw new \LogicException('You cannot use the ""sendEarlyHints"" method if the WebLink component is not available. Try running ""composer require symfony/web-link"".');
        }

        $response ??= new Response();

        $populatedLinks = [];
        foreach ($links as $link) {
            if ($link instanceof EvolvableLinkInterface && !$link->getRels()) {
                $link = $link->withRel('preload');
            }

            $populatedLinks[] = $link;
        }

        $response->headers->set('Link', $this->container->get('web_link.http_header_serializer')->serialize($populatedLinks), false);
        $response->sendHeaders(103);

        return $response;
 <\s>
"
"<s>[INST] hits [/INST]     ): Response {
        $newerThan = new \DateTime('now');
        $newerThan->setTime(0, 0);
        $newerThan->modify('-3 days');

        $qb = $em->createQueryBuilder();

        $qb->select(
            [
                'DATE_FORMAT(r.createdAt, \'%Y-%m-%d\') as date',
                'ROUND(CAST(DATE_FORMAT(r.createdAt, \'%H\') AS UNSIGNED) / :interval) as hour',
                'COUNT(r.id) as hits',
            ]
        );

        $qb
            ->from(Request::class, 'r')
            ->where('r.createdAt > :newerThan')
            ->setParameter('newerThan', $newerThan)
            ->groupBy('date, hour')
            ->setParameter('interval', self::INTERVAL);

        /** @var Request[] $result */
        $result = $qb->getQuery()->getResult();

        $response = [];
        foreach ($result as $key => &$item) {
            if ('0' === $item['hour']) {
                $previousKey = $key - 1;
                if (isset($result[$previousKey])) {
                    $result[$previousKey]['hits'] = $item['hits'];
                }

                unset($result[$key]);
            }

            $date = new \DateTime($item['date']);
            $date->setTime((int) $item['hour'] * self::INTERVAL, 0);

            $response[$date->format(\DateTimeInterface::ATOM)] = $item['hits'];
        }

        return new JsonResponse(
            $response,
            Response::HTTP_OK,
        );
 <\s>
"
"<s>[INST] set router [/INST]         $this->router = $router;
 <\s>
"
"<s>[INST] response [/INST]         return new JsonResponse(
            $data,
            Response::HTTP_OK,
        );
 <\s>
"
"<s>[INST] set container [/INST]         $previous = $this->container;
        $this->container = $container;

        return $previous;
 <\s>
"
"<s>[INST] get parameter [/INST]         if (!$this->container->has('parameter_bag')) {
            throw new ServiceNotFoundException('parameter_bag.', null, null, [], sprintf('The ""%s::getParameter()"" method is missing a parameter bag to work properly. Did you forget to register your controller as a service subscriber? This can be fixed either by using autoconfiguration or by manually wiring a ""parameter_bag"" in the service locator passed to the controller.', static::class));
        }

        return $this->container->get('parameter_bag')->get($name);
 <\s>
"
"<s>[INST] get subscribed services [/INST]         return [
            'router' => '?'.RouterInterface::class,
            'request_stack' => '?'.RequestStack::class,
            'http_kernel' => '?'.HttpKernelInterface::class,
            'serializer' => '?'.SerializerInterface::class,
            'security.authorization_checker' => '?'.AuthorizationCheckerInterface::class,
            'twig' => '?'.Environment::class,
            'form.factory' => '?'.FormFactoryInterface::class,
            'security.token_storage' => '?'.TokenStorageInterface::class,
            'security.csrf.token_manager' => '?'.CsrfTokenManagerInterface::class,
            'parameter_bag' => '?'.ContainerBagInterface::class,
            'web_link.http_header_serializer' => '?'.HttpHeaderSerializer::class,
        ];
 <\s>
"
"<s>[INST] generate url [/INST]         return $this->container->get('router')->generate($route, $parameters, $referenceType);
 <\s>
"
"<s>[INST] forward [/INST]         $request = $this->container->get('request_stack')->getCurrentRequest();
        $path['_controller'] = $controller;
        $subRequest = $request->duplicate($query, null, $path);

        return $this->container->get('http_kernel')->handle($subRequest, HttpKernelInterface::SUB_REQUEST);
 <\s>
"
"<s>[INST] redirect [/INST]         return new RedirectResponse($url, $status);
 <\s>
"
"<s>[INST] redirect to route [/INST]         return $this->redirect($this->generateUrl($route, $parameters), $status);
 <\s>
"
"<s>[INST] json [/INST]         if ($this->container->has('serializer')) {
            $json = $this->container->get('serializer')->serialize($data, 'json', array_merge([
                'json_encode_options' => JsonResponse::DEFAULT_ENCODING_OPTIONS,
            ], $context));

            return new JsonResponse($json, $status, $headers, true);
        }

        return new JsonResponse($data, $status, $headers);
 <\s>
"
"<s>[INST] file [/INST]         $response = new BinaryFileResponse($file);
        $response->setContentDisposition($disposition, $fileName ?? $response->getFile()->getFilename());

        return $response;
 <\s>
"
"<s>[INST] add flash [/INST]         try {
            $session = $this->container->get('request_stack')->getSession();
        } catch (SessionNotFoundException $e) {
            throw new \LogicException('You cannot use the addFlash method if sessions are disabled. Enable them in ""config/packages/framework.yaml"".', 0, $e);
        }

        if (!$session instanceof FlashBagAwareSessionInterface) {
            trigger_deprecation('symfony/framework-bundle', '6.2', 'Calling ""addFlash()"" method when the session does not implement %s is deprecated.', FlashBagAwareSessionInterface::class);
        }

        $session->getFlashBag()->add($type, $message);
 <\s>
"
"<s>[INST] is granted [/INST]         if (!$this->container->has('security.authorization_checker')) {
            throw new \LogicException('The SecurityBundle is not registered in your application. Try running ""composer require symfony/security-bundle"".');
        }

        return $this->container->get('security.authorization_checker')->isGranted($attribute, $subject);
 <\s>
"
"<s>[INST] deny access unless granted [/INST]         if (!$this->isGranted($attribute, $subject)) {
            $exception = $this->createAccessDeniedException($message);
            $exception->setAttributes([$attribute]);
            $exception->setSubject($subject);

            throw $exception;
        }
 <\s>
"
"<s>[INST] render view [/INST]         if (!$this->container->has('twig')) {
            throw new \LogicException('You cannot use the ""renderView"" method if the Twig Bundle is not available. Try running ""composer require symfony/twig-bundle"".');
        }

        foreach ($parameters as $k => $v) {
            if ($v instanceof FormInterface) {
                $parameters[$k] = $v->createView();
            }
        }

        return $this->container->get('twig')->render($view, $parameters);
 <\s>
"
"<s>[INST] render [/INST]         $content = $this->renderView($view, $parameters);
        $response ??= new Response();

        if (200 === $response->getStatusCode()) {
            foreach ($parameters as $v) {
                if ($v instanceof FormInterface && $v->isSubmitted() && !$v->isValid()) {
                    $response->setStatusCode(422);
                    break;
                }
            }
        }

        $response->setContent($content);

        return $response;
 <\s>
"
"<s>[INST] render form [/INST]         trigger_deprecation('symfony/framework-bundle', '6.2', 'The ""%s::renderForm()"" method is deprecated, use ""render()"" instead.', get_debug_type($this));

        return $this->render($view, $parameters, $response);
 <\s>
"
"<s>[INST] stream [/INST]         if (!$this->container->has('twig')) {
            throw new \LogicException('You cannot use the ""stream"" method if the Twig Bundle is not available. Try running ""composer require symfony/twig-bundle"".');
        }

        $twig = $this->container->get('twig');

        $callback = function () use ($twig, $view, $parameters) {
            $twig->display($view, $parameters);
        };

        if (null === $response) {
            return new StreamedResponse($callback);
        }

        $response->setCallback($callback);

        return $response;
 <\s>
"
"<s>[INST] create not found exception [/INST]         return new NotFoundHttpException($message, $previous);
 <\s>
"
"<s>[INST] create access denied exception [/INST]         if (!class_exists(AccessDeniedException::class)) {
            throw new \LogicException('You cannot use the ""createAccessDeniedException"" method if the Security component is not available. Try running ""composer require symfony/security-bundle"".');
        }

        return new AccessDeniedException($message, $previous);
 <\s>
"
"<s>[INST] create form [/INST]         return $this->container->get('form.factory')->create($type, $data, $options);
 <\s>
"
"<s>[INST] create form builder [/INST]         return $this->container->get('form.factory')->createBuilder(FormType::class, $data, $options);
 <\s>
"
"<s>[INST] get user [/INST]         if (!$this->container->has('security.token_storage')) {
            throw new \LogicException('The SecurityBundle is not registered in your application. Try running ""composer require symfony/security-bundle"".');
        }

        if (null === $token = $this->container->get('security.token_storage')->getToken()) {
            return null;
        }

        return $token->getUser();
 <\s>
"
"<s>[INST] is csrf token valid [/INST]         if (!$this->container->has('security.csrf.token_manager')) {
            throw new \LogicException('CSRF protection is not enabled in your application. Enable it with the ""csrf_protection"" key in ""config/packages/framework.yaml"".');
        }

        return $this->container->get('security.csrf.token_manager')->isTokenValid(new CsrfToken($id, $token));
 <\s>
"
"<s>[INST] add link [/INST]         if (!class_exists(AddLinkHeaderListener::class)) {
            throw new \LogicException('You cannot use the ""addLink"" method if the WebLink component is not available. Try running ""composer require symfony/web-link"".');
        }

        if (null === $linkProvider = $request->attributes->get('_links')) {
            $request->attributes->set('_links', new GenericLinkProvider([$link]));

            return;
        }

        $request->attributes->set('_links', $linkProvider->withLink($link));
 <\s>
"
"<s>[INST] send early hints [/INST]         if (!$this->container->has('web_link.http_header_serializer')) {
            throw new \LogicException('You cannot use the ""sendEarlyHints"" method if the WebLink component is not available. Try running ""composer require symfony/web-link"".');
        }

        $response ??= new Response();

        $populatedLinks = [];
        foreach ($links as $link) {
            if ($link instanceof EvolvableLinkInterface && !$link->getRels()) {
                $link = $link->withRel('preload');
            }

            $populatedLinks[] = $link;
        }

        $response->headers->set('Link', $this->container->get('web_link.http_header_serializer')->serialize($populatedLinks), false);
        $response->sendHeaders(103);

        return $response;
 <\s>
"
"<s>[INST] __construct [/INST]  <\s>
"
"<s>[INST] record [/INST]         NormalizerInterface $normalizer,
    ): JsonResponse
    {
        return $this->response(
            [
                '@context' => self::HYDRA_CONTEXT,
                ...$normalizer->normalize($request->getTle(), null, [TleRequest::EXTRA_PARAM => $request->getExtra()]),
            ]
        );
 <\s>
"
"<s>[INST] collection [/INST]         NormalizerInterface  $normalizer
    ): JsonResponse
    {
        $builder = $this->repository->collection(
            $request->getSearch(),
            $request->getSort(TleCollectionSortableFieldsEnum::POPULARITY),
            $request->getSortDirection(),
            $request->getFilters(),
        );

        $pagination = new QueryBuilderPaginator($builder);
        $pagination->setFromRequest($request);

        $response = $normalizer->normalize($pagination, null, [TleRequest::EXTRA_PARAM => $request->getExtra()]);
        $response['parameters'] = $request->getParameters();

        return $this->response($response);
 <\s>
"
"<s>[INST] stats [/INST]         return $this->response(
            [
                ...$normalizer->normalize($this->statRepository->get(), null, [TleRequest::EXTRA_PARAM => true]),
            ]
        );
 <\s>
"
"<s>[INST] set router [/INST]         $this->router = $router;
 <\s>
"
"<s>[INST] response [/INST]         return new JsonResponse(
            $data,
            Response::HTTP_OK,
        );
 <\s>
"
"<s>[INST] set container [/INST]         $previous = $this->container;
        $this->container = $container;

        return $previous;
 <\s>
"
"<s>[INST] get parameter [/INST]         if (!$this->container->has('parameter_bag')) {
            throw new ServiceNotFoundException('parameter_bag.', null, null, [], sprintf('The ""%s::getParameter()"" method is missing a parameter bag to work properly. Did you forget to register your controller as a service subscriber? This can be fixed either by using autoconfiguration or by manually wiring a ""parameter_bag"" in the service locator passed to the controller.', static::class));
        }

        return $this->container->get('parameter_bag')->get($name);
 <\s>
"
"<s>[INST] get subscribed services [/INST]         return [
            'router' => '?'.RouterInterface::class,
            'request_stack' => '?'.RequestStack::class,
            'http_kernel' => '?'.HttpKernelInterface::class,
            'serializer' => '?'.SerializerInterface::class,
            'security.authorization_checker' => '?'.AuthorizationCheckerInterface::class,
            'twig' => '?'.Environment::class,
            'form.factory' => '?'.FormFactoryInterface::class,
            'security.token_storage' => '?'.TokenStorageInterface::class,
            'security.csrf.token_manager' => '?'.CsrfTokenManagerInterface::class,
            'parameter_bag' => '?'.ContainerBagInterface::class,
            'web_link.http_header_serializer' => '?'.HttpHeaderSerializer::class,
        ];
 <\s>
"
"<s>[INST] generate url [/INST]         return $this->container->get('router')->generate($route, $parameters, $referenceType);
 <\s>
"
"<s>[INST] forward [/INST]         $request = $this->container->get('request_stack')->getCurrentRequest();
        $path['_controller'] = $controller;
        $subRequest = $request->duplicate($query, null, $path);

        return $this->container->get('http_kernel')->handle($subRequest, HttpKernelInterface::SUB_REQUEST);
 <\s>
"
"<s>[INST] redirect [/INST]         return new RedirectResponse($url, $status);
 <\s>
"
"<s>[INST] redirect to route [/INST]         return $this->redirect($this->generateUrl($route, $parameters), $status);
 <\s>
"
"<s>[INST] json [/INST]         if ($this->container->has('serializer')) {
            $json = $this->container->get('serializer')->serialize($data, 'json', array_merge([
                'json_encode_options' => JsonResponse::DEFAULT_ENCODING_OPTIONS,
            ], $context));

            return new JsonResponse($json, $status, $headers, true);
        }

        return new JsonResponse($data, $status, $headers);
 <\s>
"
"<s>[INST] file [/INST]         $response = new BinaryFileResponse($file);
        $response->setContentDisposition($disposition, $fileName ?? $response->getFile()->getFilename());

        return $response;
 <\s>
"
"<s>[INST] add flash [/INST]         try {
            $session = $this->container->get('request_stack')->getSession();
        } catch (SessionNotFoundException $e) {
            throw new \LogicException('You cannot use the addFlash method if sessions are disabled. Enable them in ""config/packages/framework.yaml"".', 0, $e);
        }

        if (!$session instanceof FlashBagAwareSessionInterface) {
            trigger_deprecation('symfony/framework-bundle', '6.2', 'Calling ""addFlash()"" method when the session does not implement %s is deprecated.', FlashBagAwareSessionInterface::class);
        }

        $session->getFlashBag()->add($type, $message);
 <\s>
"
"<s>[INST] is granted [/INST]         if (!$this->container->has('security.authorization_checker')) {
            throw new \LogicException('The SecurityBundle is not registered in your application. Try running ""composer require symfony/security-bundle"".');
        }

        return $this->container->get('security.authorization_checker')->isGranted($attribute, $subject);
 <\s>
"
"<s>[INST] deny access unless granted [/INST]         if (!$this->isGranted($attribute, $subject)) {
            $exception = $this->createAccessDeniedException($message);
            $exception->setAttributes([$attribute]);
            $exception->setSubject($subject);

            throw $exception;
        }
 <\s>
"
"<s>[INST] render view [/INST]         if (!$this->container->has('twig')) {
            throw new \LogicException('You cannot use the ""renderView"" method if the Twig Bundle is not available. Try running ""composer require symfony/twig-bundle"".');
        }

        foreach ($parameters as $k => $v) {
            if ($v instanceof FormInterface) {
                $parameters[$k] = $v->createView();
            }
        }

        return $this->container->get('twig')->render($view, $parameters);
 <\s>
"
"<s>[INST] render [/INST]         $content = $this->renderView($view, $parameters);
        $response ??= new Response();

        if (200 === $response->getStatusCode()) {
            foreach ($parameters as $v) {
                if ($v instanceof FormInterface && $v->isSubmitted() && !$v->isValid()) {
                    $response->setStatusCode(422);
                    break;
                }
            }
        }

        $response->setContent($content);

        return $response;
 <\s>
"
"<s>[INST] render form [/INST]         trigger_deprecation('symfony/framework-bundle', '6.2', 'The ""%s::renderForm()"" method is deprecated, use ""render()"" instead.', get_debug_type($this));

        return $this->render($view, $parameters, $response);
 <\s>
"
"<s>[INST] stream [/INST]         if (!$this->container->has('twig')) {
            throw new \LogicException('You cannot use the ""stream"" method if the Twig Bundle is not available. Try running ""composer require symfony/twig-bundle"".');
        }

        $twig = $this->container->get('twig');

        $callback = function () use ($twig, $view, $parameters) {
            $twig->display($view, $parameters);
        };

        if (null === $response) {
            return new StreamedResponse($callback);
        }

        $response->setCallback($callback);

        return $response;
 <\s>
"
"<s>[INST] create not found exception [/INST]         return new NotFoundHttpException($message, $previous);
 <\s>
"
"<s>[INST] create access denied exception [/INST]         if (!class_exists(AccessDeniedException::class)) {
            throw new \LogicException('You cannot use the ""createAccessDeniedException"" method if the Security component is not available. Try running ""composer require symfony/security-bundle"".');
        }

        return new AccessDeniedException($message, $previous);
 <\s>
"
"<s>[INST] create form [/INST]         return $this->container->get('form.factory')->create($type, $data, $options);
 <\s>
"
"<s>[INST] create form builder [/INST]         return $this->container->get('form.factory')->createBuilder(FormType::class, $data, $options);
 <\s>
"
"<s>[INST] get user [/INST]         if (!$this->container->has('security.token_storage')) {
            throw new \LogicException('The SecurityBundle is not registered in your application. Try running ""composer require symfony/security-bundle"".');
        }

        if (null === $token = $this->container->get('security.token_storage')->getToken()) {
            return null;
        }

        return $token->getUser();
 <\s>
"
"<s>[INST] is csrf token valid [/INST]         if (!$this->container->has('security.csrf.token_manager')) {
            throw new \LogicException('CSRF protection is not enabled in your application. Enable it with the ""csrf_protection"" key in ""config/packages/framework.yaml"".');
        }

        return $this->container->get('security.csrf.token_manager')->isTokenValid(new CsrfToken($id, $token));
 <\s>
"
"<s>[INST] add link [/INST]         if (!class_exists(AddLinkHeaderListener::class)) {
            throw new \LogicException('You cannot use the ""addLink"" method if the WebLink component is not available. Try running ""composer require symfony/web-link"".');
        }

        if (null === $linkProvider = $request->attributes->get('_links')) {
            $request->attributes->set('_links', new GenericLinkProvider([$link]));

            return;
        }

        $request->attributes->set('_links', $linkProvider->withLink($link));
 <\s>
"
"<s>[INST] send early hints [/INST]         if (!$this->container->has('web_link.http_header_serializer')) {
            throw new \LogicException('You cannot use the ""sendEarlyHints"" method if the WebLink component is not available. Try running ""composer require symfony/web-link"".');
        }

        $response ??= new Response();

        $populatedLinks = [];
        foreach ($links as $link) {
            if ($link instanceof EvolvableLinkInterface && !$link->getRels()) {
                $link = $link->withRel('preload');
            }

            $populatedLinks[] = $link;
        }

        $response->headers->set('Link', $this->container->get('web_link.http_header_serializer')->serialize($populatedLinks), false);
        $response->sendHeaders(103);

        return $response;
 <\s>
"
"<s>[INST] create [/INST]         $tle = new Tle();
        $tle->setId(self::$satelliteId);
        $tle->setName(self::$name);
        $tle->setLine1(self::$line1);
        $tle->setLine2(self::$line2);

        return $tle;
 <\s>
"
"<s>[INST] create deep [/INST]         $tle = new Tle();
        $tle->setId(22049);
        $tle->setName('GEOTAIL');
        $tle->setLine1('1 22049U 92044A   21119.24930644 -.00001485  00000-0  00000+0 0  9990');
        $tle->setLine2('2 22049  38.4941  42.7845 5317694 181.2241 357.6003  0.19228928 12156');

        return $tle;
 <\s>
"
"<s>[INST] load [/INST]         // create single record
        $manager->persist(self::create());
        $manager->persist(self::createDeep());

        // create additional nine records with dummy satelliteIds
        for ($satelliteId = 1; $satelliteId < 10; ++$satelliteId) {
            $tle = self::create();
            $tle->setId($satelliteId);

            $manager->persist($tle);
        }

        $manager->flush();
 <\s>
"
"<s>[INST] set reference repository [/INST]         $this->referenceRepository = $referenceRepository;
 <\s>
"
"<s>[INST] set reference [/INST]         $this->getReferenceRepository()->setReference($name, $object);
 <\s>
"
"<s>[INST] add reference [/INST]         $this->getReferenceRepository()->addReference($name, $object);
 <\s>
"
"<s>[INST] get reference [/INST]         if ($class === null) {
            Deprecation::trigger(
                'doctrine/data-fixtures',
                'https://github.com/doctrine/data-fixtures/pull/409',
                'Argument $class of %s() will be mandatory in 2.0.',
                __METHOD__
            );
        }

        return $this->getReferenceRepository()->getReference($name, $class);
 <\s>
"
"<s>[INST] has reference [/INST]         if ($class === null) {
            Deprecation::trigger(
                'doctrine/data-fixtures',
                'https://github.com/doctrine/data-fixtures/pull/409',
                'Argument $class of %s() will be mandatory in 2.0.',
                __METHOD__
            );
        }

        return $this->getReferenceRepository()->hasReference($name, $class);
 <\s>
"
"<s>[INST] update [/INST]         $this->createdAt = DateTimeService::getCurrentUTC();
 <\s>
"
"<s>[INST] get tle [/INST]         return $this->tle;
 <\s>
"
"<s>[INST] set tle [/INST]         $this->tle = $tle;
 <\s>
"
"<s>[INST] get ip [/INST]         return $this->ip;
 <\s>
"
"<s>[INST] set ip [/INST]         $this->ip = $ip;
 <\s>
"
"<s>[INST] get referer [/INST]         return $this->referer;
 <\s>
"
"<s>[INST] set referer [/INST]         $this->referer = $referer;
 <\s>
"
"<s>[INST] get id [/INST]         return $this->id;
 <\s>
"
"<s>[INST] set id [/INST]         $this->id = $id;
 <\s>
"
"<s>[INST] update [/INST]         $this->updatedAt = DateTimeService::getCurrentUTC();
 <\s>
"
"<s>[INST] get info [/INST]         return $this->info;
 <\s>
"
"<s>[INST] get id [/INST]         return $this->id;
 <\s>
"
"<s>[INST] set id [/INST]         $this->id = $id;
 <\s>
"
"<s>[INST] get name [/INST]         return $this->name;
 <\s>
"
"<s>[INST] set name [/INST]         $this->name = $name;
 <\s>
"
"<s>[INST] get line1 [/INST]         return $this->line1;
 <\s>
"
"<s>[INST] set line1 [/INST]         $this->line1 = $line1;
 <\s>
"
"<s>[INST] get line2 [/INST]         return $this->line2;
 <\s>
"
"<s>[INST] set line2 [/INST]         $this->line2 = $line2;
 <\s>
"
"<s>[INST] __construct [/INST]         $this->tle = $tle;
 <\s>
"
"<s>[INST] get tle [/INST]         return $this->tle;
 <\s>
"
"<s>[INST] set tle [/INST]         $this->tle = $tle;
 <\s>
"
"<s>[INST] __construct [/INST]         $this->setName($name);
 <\s>
"
"<s>[INST] get name [/INST]         return $this->name;
 <\s>
"
"<s>[INST] set name [/INST]         $this->name = $name;
 <\s>
"
"<s>[INST] get tle [/INST]         return $this->tle;
 <\s>
"
"<s>[INST] set tle [/INST]         $this->tle = $tle;
 <\s>
"
"<s>[INST] __construct [/INST]         $this->limiter = $anonymousApiLimiter;
 <\s>
"
"<s>[INST] get subscribed events [/INST]         return [
            KernelEvents::REQUEST => 'onRequest',
        ];
 <\s>
"
"<s>[INST] on request [/INST]         $refererHost = null;

        if ($event->getRequest()->headers->has('referer')) {
            $refererHost = parse_url($event->getRequest()->headers->get('referer'), PHP_URL_HOST);
        }

        if (!FeatureFlag::API_RATE_LIMITER || Route::PRODUCTION_HOST === $refererHost || !Route::inArray($event->getRequest(), self::ROUTES)) {
            return;
        }

        $limit = $this->limiter->create($event->getRequest()->getClientIp())->consume();

        if (false === $limit->isAccepted()) {
            $headers = [
                'X-RateLimit-Remaining' => $limit->getRemainingTokens(),
                'X-RateLimit-Retry-After' => $limit->getRetryAfter()->format(\DateTimeInterface::ATOM),
                'X-RateLimit-Limit' => $limit->getLimit(),
            ];

            $event->setResponse(
                new JsonResponse(
                    [
                        'response' => [
                            'message' => \sprintf('Too many requests. Retry after %s.', $limit->getRetryAfter()->format(\DateTimeInterface::ATOM)),
                            'limit' => $limit->getLimit(),
                            'remaining' => $limit->getRemainingTokens(),
                        ],
                    ],
                    Response::HTTP_TOO_MANY_REQUESTS,
                    $headers
                ),
            );
        }
 <\s>
"
"<s>[INST] __construct [/INST]  <\s>
"
"<s>[INST] get subscribed events [/INST]         return [
            KernelEvents::TERMINATE => 'onKernelTerminate',
        ];
 <\s>
"
"<s>[INST] on kernel terminate [/INST]         if (!Route::inArray($event->getRequest(), self::ROUTES)) {
            return;
        }

        /** @var Tle|null $tle */
        $tle = $this->tleRepository->find($event->getRequest()->get('id'));

        if (null === $tle) {
            return;
        }

        $request = new Request();
        $request->setTle($tle);
        $request->setIp($event->getRequest()->getClientIp());
        $request->setReferer($event->getRequest()->headers->get('referer'));

        $this->em->persist($request);
        $this->em->flush();
 <\s>
"
"<s>[INST] get config dir [/INST]         return $this->getProjectDir().'/etc';
 <\s>
"
"<s>[INST] __construct [/INST]         if (!$this->environment = $environment) {
            throw new \InvalidArgumentException(sprintf('Invalid environment provided to ""%s"": the environment cannot be empty.', get_debug_type($this)));
        }

        $this->debug = $debug;
 <\s>
"
"<s>[INST] __clone [/INST]         $this->booted = false;
        $this->container = null;
        $this->requestStackSize = 0;
        $this->resetServices = false;
 <\s>
"
"<s>[INST] boot [/INST]         if (true === $this->booted) {
            if (!$this->requestStackSize && $this->resetServices) {
                if ($this->container->has('services_resetter')) {
                    $this->container->get('services_resetter')->reset();
                }
                $this->resetServices = false;
                if ($this->debug) {
                    $this->startTime = microtime(true);
                }
            }

            return;
        }

        if (null === $this->container) {
            $this->preBoot();
        }

        foreach ($this->getBundles() as $bundle) {
            $bundle->setContainer($this->container);
            $bundle->boot();
        }

        $this->booted = true;
 <\s>
"
"<s>[INST] reboot [/INST]         $this->shutdown();
        $this->warmupDir = $warmupDir;
        $this->boot();
 <\s>
"
"<s>[INST] terminate [/INST]         if (false === $this->booted) {
            return;
        }

        if ($this->getHttpKernel() instanceof TerminableInterface) {
            $this->getHttpKernel()->terminate($request, $response);
        }
 <\s>
"
"<s>[INST] shutdown [/INST]         if (false === $this->booted) {
            return;
        }

        $this->booted = false;

        foreach ($this->getBundles() as $bundle) {
            $bundle->shutdown();
            $bundle->setContainer(null);
        }

        $this->container = null;
        $this->requestStackSize = 0;
        $this->resetServices = false;
 <\s>
"
"<s>[INST] handle [/INST]         if (!$this->booted) {
            $container = $this->container ?? $this->preBoot();

            if ($container->has('http_cache')) {
                return $container->get('http_cache')->handle($request, $type, $catch);
            }
        }

        $this->boot();
        ++$this->requestStackSize;
        $this->resetServices = true;

        try {
            return $this->getHttpKernel()->handle($request, $type, $catch);
        } finally {
            --$this->requestStackSize;
        }
 <\s>
"
"<s>[INST] get http kernel [/INST]         return $this->container->get('http_kernel');
 <\s>
"
"<s>[INST] get bundles [/INST]         return $this->bundles;
 <\s>
"
"<s>[INST] get bundle [/INST]         if (!isset($this->bundles[$name])) {
            throw new \InvalidArgumentException(sprintf('Bundle ""%s"" does not exist or it is not enabled. Maybe you forgot to add it in the ""registerBundles()"" method of your ""%s.php"" file?', $name, get_debug_type($this)));
        }

        return $this->bundles[$name];
 <\s>
"
"<s>[INST] locate resource [/INST]         if ('@' !== $name[0]) {
            throw new \InvalidArgumentException(sprintf('A resource name must start with @ (""%s"" given).', $name));
        }

        if (str_contains($name, '..')) {
            throw new \RuntimeException(sprintf('File name ""%s"" contains invalid characters (..).', $name));
        }

        $bundleName = substr($name, 1);
        $path = '';
        if (str_contains($bundleName, '/')) {
            [$bundleName, $path] = explode('/', $bundleName, 2);
        }

        $bundle = $this->getBundle($bundleName);
        if (file_exists($file = $bundle->getPath().'/'.$path)) {
            return $file;
        }

        throw new \InvalidArgumentException(sprintf('Unable to find file ""%s"".', $name));
 <\s>
"
"<s>[INST] get environment [/INST]         return $this->environment;
 <\s>
"
"<s>[INST] is debug [/INST]         return $this->debug;
 <\s>
"
"<s>[INST] get project dir [/INST]         if (!isset($this->projectDir)) {
            $r = new \ReflectionObject($this);

            if (!is_file($dir = $r->getFileName())) {
                throw new \LogicException(sprintf('Cannot auto-detect project dir for kernel of class ""%s"".', $r->name));
            }

            $dir = $rootDir = \dirname($dir);
            while (!is_file($dir.'/composer.json')) {
                if ($dir === \dirname($dir)) {
                    return $this->projectDir = $rootDir;
                }
                $dir = \dirname($dir);
            }
            $this->projectDir = $dir;
        }

        return $this->projectDir;
 <\s>
"
"<s>[INST] get container [/INST]         if (!$this->container) {
            throw new \LogicException('Cannot retrieve the container from a non-booted kernel.');
        }

        return $this->container;
 <\s>
"
"<s>[INST] set annotated class cache [/INST]         file_put_contents(($this->warmupDir ?: $this->getBuildDir()).'/annotations.map', sprintf('<?php return %s;', var_export($annotatedClasses, true)));
 <\s>
"
"<s>[INST] get start time [/INST]         return $this->debug && null !== $this->startTime ? $this->startTime : -\INF;
 <\s>
"
"<s>[INST] get cache dir [/INST]         if (isset($_SERVER['APP_CACHE_DIR'])) {
            return $_SERVER['APP_CACHE_DIR'].'/'.$this->environment;
        }

        return parent::getCacheDir();
 <\s>
"
"<s>[INST] get build dir [/INST]         // Returns $this->getCacheDir() for backward compatibility
        return $this->getCacheDir();
 <\s>
"
"<s>[INST] get log dir [/INST]         return $_SERVER['APP_LOG_DIR'] ?? parent::getLogDir();
 <\s>
"
"<s>[INST] get charset [/INST]         return 'UTF-8';
 <\s>
"
"<s>[INST] get annotated classes to compile [/INST]         return [];
 <\s>
"
"<s>[INST] initialize bundles [/INST]         // init bundles
        $this->bundles = [];
        foreach ($this->registerBundles() as $bundle) {
            $name = $bundle->getName();
            if (isset($this->bundles[$name])) {
                throw new \LogicException(sprintf('Trying to register two bundles with the same name ""%s"".', $name));
            }
            $this->bundles[$name] = $bundle;
        }
 <\s>
"
"<s>[INST] build [/INST]  <\s>
"
"<s>[INST] get container class [/INST]         $class = static::class;
        $class = str_contains($class, ""@anonymous\0"") ? get_parent_class($class).str_replace('.', '_', ContainerBuilder::hash($class)) : $class;
        $class = str_replace('\\', '_', $class).ucfirst($this->environment).($this->debug ? 'Debug' : '').'Container';

        if (!preg_match('/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/', $class)) {
            throw new \InvalidArgumentException(sprintf('The environment ""%s"" contains invalid characters, it can only contain characters allowed in PHP class names.', $this->environment));
        }

        return $class;
 <\s>
"
"<s>[INST] get container base class [/INST]         return 'Container';
 <\s>
"
"<s>[INST] initialize container [/INST]         $class = $this->getContainerClass();
        $buildDir = $this->warmupDir ?: $this->getBuildDir();
        $cache = new ConfigCache($buildDir.'/'.$class.'.php', $this->debug);
        $cachePath = $cache->getPath();

        // Silence E_WARNING to ignore ""include"" failures - don't use ""@"" to prevent silencing fatal errors
        $errorLevel = error_reporting(\E_ALL ^ \E_WARNING);

        try {
            if (is_file($cachePath) && \is_object($this->container = include $cachePath)
                && (!$this->debug || (self::$freshCache[$cachePath] ?? $cache->isFresh()))
            ) {
                self::$freshCache[$cachePath] = true;
                $this->container->set('kernel', $this);
                error_reporting($errorLevel);

                return;
            }
        } catch (\Throwable $e) {
        }

        $oldContainer = \is_object($this->container) ? new \ReflectionClass($this->container) : $this->container = null;

        try {
            is_dir($buildDir) ?: mkdir($buildDir, 0777, true);

            if ($lock = fopen($cachePath.'.lock', 'w')) {
                if (!flock($lock, \LOCK_EX | \LOCK_NB, $wouldBlock) && !flock($lock, $wouldBlock ? \LOCK_SH : \LOCK_EX)) {
                    fclose($lock);
                    $lock = null;
                } elseif (!is_file($cachePath) || !\is_object($this->container = include $cachePath)) {
                    $this->container = null;
                } elseif (!$oldContainer || $this->container::class !== $oldContainer->name) {
                    flock($lock, \LOCK_UN);
                    fclose($lock);
                    $this->container->set('kernel', $this);

                    return;
                }
            }
        } catch (\Throwable $e) {
        } finally {
            error_reporting($errorLevel);
        }

        if ($collectDeprecations = $this->debug && !\defined('PHPUNIT_COMPOSER_INSTALL')) {
            $collectedLogs = [];
            $previousHandler = set_error_handler(function ($type, $message, $file, $line) use (&$collectedLogs, &$previousHandler) {
                if (\E_USER_DEPRECATED !== $type && \E_DEPRECATED !== $type) {
                    return $previousHandler ? $previousHandler($type, $message, $file, $line) : false;
                }

                if (isset($collectedLogs[$message])) {
                    ++$collectedLogs[$message]['count'];

                    return null;
                }

                $backtrace = debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS, 5);
                // Clean the trace by removing first frames added by the error handler itself.
                for ($i = 0; isset($backtrace[$i]); ++$i) {
                    if (isset($backtrace[$i]['file'], $backtrace[$i]['line']) && $backtrace[$i]['line'] === $line && $backtrace[$i]['file'] === $file) {
                        $backtrace = \array_slice($backtrace, 1 + $i);
                        break;
                    }
                }
                for ($i = 0; isset($backtrace[$i]); ++$i) {
                    if (!isset($backtrace[$i]['file'], $backtrace[$i]['line'], $backtrace[$i]['function'])) {
                        continue;
                    }
                    if (!isset($backtrace[$i]['class']) && 'trigger_deprecation' === $backtrace[$i]['function']) {
                        $file = $backtrace[$i]['file'];
                        $line = $backtrace[$i]['line'];
                        $backtrace = \array_slice($backtrace, 1 + $i);
                        break;
                    }
                }

                // Remove frames added by DebugClassLoader.
                for ($i = \count($backtrace) - 2; 0 < $i; --$i) {
                    if (DebugClassLoader::class === ($backtrace[$i]['class'] ?? null)) {
                        $backtrace = [$backtrace[$i + 1]];
                        break;
                    }
                }

                $collectedLogs[$message] = [
                    'type' => $type,
                    'message' => $message,
                    'file' => $file,
                    'line' => $line,
                    'trace' => [$backtrace[0]],
                    'count' => 1,
                ];

                return null;
            });
        }

        try {
            $container = null;
            $container = $this->buildContainer();
            $container->compile();
        } finally {
            if ($collectDeprecations) {
                restore_error_handler();

                @file_put_contents($buildDir.'/'.$class.'Deprecations.log', serialize(array_values($collectedLogs)));
                @file_put_contents($buildDir.'/'.$class.'Compiler.log', null !== $container ? implode(""\n"", $container->getCompiler()->getLog()) : '');
            }
        }

        $this->dumpContainer($cache, $container, $class, $this->getContainerBaseClass());

        if ($lock) {
            flock($lock, \LOCK_UN);
            fclose($lock);
        }

        $this->container = require $cachePath;
        $this->container->set('kernel', $this);

        if ($oldContainer && $this->container::class !== $oldContainer->name) {
            // Because concurrent requests might still be using them,
            // old container files are not removed immediately,
            // but on a next dump of the container.
            static $legacyContainers = [];
            $oldContainerDir = \dirname($oldContainer->getFileName());
            $legacyContainers[$oldContainerDir.'.legacy'] = true;
            foreach (glob(\dirname($oldContainerDir).\DIRECTORY_SEPARATOR.'*.legacy', \GLOB_NOSORT) as $legacyContainer) {
                if (!isset($legacyContainers[$legacyContainer]) && @unlink($legacyContainer)) {
                    (new Filesystem())->remove(substr($legacyContainer, 0, -7));
                }
            }

            touch($oldContainerDir.'.legacy');
        }

        $preload = $this instanceof WarmableInterface ? (array) $this->warmUp($this->container->getParameter('kernel.cache_dir')) : [];

        if ($this->container->has('cache_warmer')) {
            $preload = array_merge($preload, (array) $this->container->get('cache_warmer')->warmUp($this->container->getParameter('kernel.cache_dir')));
        }

        if ($preload && file_exists($preloadFile = $buildDir.'/'.$class.'.preload.php')) {
            Preloader::append($preloadFile, $preload);
        }
 <\s>
"
"<s>[INST] get kernel parameters [/INST]         $bundles = [];
        $bundlesMetadata = [];

        foreach ($this->bundles as $name => $bundle) {
            $bundles[$name] = $bundle::class;
            $bundlesMetadata[$name] = [
                'path' => $bundle->getPath(),
                'namespace' => $bundle->getNamespace(),
            ];
        }

        return [
            'kernel.project_dir' => realpath($this->getProjectDir()) ?: $this->getProjectDir(),
            'kernel.environment' => $this->environment,
            'kernel.runtime_environment' => '%env(default:kernel.environment:APP_RUNTIME_ENV)%',
            'kernel.debug' => $this->debug,
            'kernel.build_dir' => realpath($buildDir = $this->warmupDir ?: $this->getBuildDir()) ?: $buildDir,
            'kernel.cache_dir' => realpath($cacheDir = ($this->getCacheDir() === $this->getBuildDir() ? ($this->warmupDir ?: $this->getCacheDir()) : $this->getCacheDir())) ?: $cacheDir,
            'kernel.logs_dir' => realpath($this->getLogDir()) ?: $this->getLogDir(),
            'kernel.bundles' => $bundles,
            'kernel.bundles_metadata' => $bundlesMetadata,
            'kernel.charset' => $this->getCharset(),
            'kernel.container_class' => $this->getContainerClass(),
        ];
 <\s>
"
"<s>[INST] build container [/INST]         foreach (['cache' => $this->getCacheDir(), 'build' => $this->warmupDir ?: $this->getBuildDir(), 'logs' => $this->getLogDir()] as $name => $dir) {
            if (!is_dir($dir)) {
                if (false === @mkdir($dir, 0777, true) && !is_dir($dir)) {
                    throw new \RuntimeException(sprintf('Unable to create the ""%s"" directory (%s).', $name, $dir));
                }
            } elseif (!is_writable($dir)) {
                throw new \RuntimeException(sprintf('Unable to write in the ""%s"" directory (%s).', $name, $dir));
            }
        }

        $container = $this->getContainerBuilder();
        $container->addObjectResource($this);
        $this->prepareContainer($container);
        $this->registerContainerConfiguration($this->getContainerLoader($container));

        $container->addCompilerPass(new AddAnnotatedClassesToCachePass($this));

        return $container;
 <\s>
"
"<s>[INST] prepare container [/INST]         $extensions = [];
        foreach ($this->bundles as $bundle) {
            if ($extension = $bundle->getContainerExtension()) {
                $container->registerExtension($extension);
            }

            if ($this->debug) {
                $container->addObjectResource($bundle);
            }
        }

        foreach ($this->bundles as $bundle) {
            $bundle->build($container);
        }

        $this->build($container);

        foreach ($container->getExtensions() as $extension) {
            $extensions[] = $extension->getAlias();
        }

        // ensure these extensions are implicitly loaded
        $container->getCompilerPassConfig()->setMergePass(new MergeExtensionConfigurationPass($extensions));
 <\s>
"
"<s>[INST] get container builder [/INST]         $container = new ContainerBuilder();
        $container->getParameterBag()->add($this->getKernelParameters());

        if ($this instanceof ExtensionInterface) {
            $container->registerExtension($this);
        }
        if ($this instanceof CompilerPassInterface) {
            $container->addCompilerPass($this, PassConfig::TYPE_BEFORE_OPTIMIZATION, -10000);
        }

        return $container;
 <\s>
"
"<s>[INST] dump container [/INST]         // cache the container
        $dumper = new PhpDumper($container);

        $buildParameters = [];
        foreach ($container->getCompilerPassConfig()->getPasses() as $pass) {
            if ($pass instanceof RemoveBuildParametersPass) {
                $buildParameters = array_merge($buildParameters, $pass->getRemovedParameters());
            }
        }

        $inlineFactories = false;
        if (isset($buildParameters['.container.dumper.inline_factories'])) {
            $inlineFactories = $buildParameters['.container.dumper.inline_factories'];
        } elseif ($container->hasParameter('container.dumper.inline_factories')) {
            trigger_deprecation('symfony/http-kernel', '6.3', 'Parameter ""%s"" is deprecated, use "".%1$s"" instead.', 'container.dumper.inline_factories');
            $inlineFactories = $container->getParameter('container.dumper.inline_factories');
        }

        $inlineClassLoader = $this->debug;
        if (isset($buildParameters['.container.dumper.inline_class_loader'])) {
            $inlineClassLoader = $buildParameters['.container.dumper.inline_class_loader'];
        } elseif ($container->hasParameter('container.dumper.inline_class_loader')) {
            trigger_deprecation('symfony/http-kernel', '6.3', 'Parameter ""%s"" is deprecated, use "".%1$s"" instead.', 'container.dumper.inline_class_loader');
            $inlineClassLoader = $container->getParameter('container.dumper.inline_class_loader');
        }

        $content = $dumper->dump([
            'class' => $class,
            'base_class' => $baseClass,
            'file' => $cache->getPath(),
            'as_files' => true,
            'debug' => $this->debug,
            'inline_factories' => $inlineFactories,
            'inline_class_loader' => $inlineClassLoader,
            'build_time' => $container->hasParameter('kernel.container_build_time') ? $container->getParameter('kernel.container_build_time') : time(),
            'preload_classes' => array_map('get_class', $this->bundles),
        ]);

        $rootCode = array_pop($content);
        $dir = \dirname($cache->getPath()).'/';
        $fs = new Filesystem();

        foreach ($content as $file => $code) {
            $fs->dumpFile($dir.$file, $code);
            @chmod($dir.$file, 0666 & ~umask());
        }
        $legacyFile = \dirname($dir.key($content)).'.legacy';
        if (is_file($legacyFile)) {
            @unlink($legacyFile);
        }

        $cache->write($rootCode, $container->getResources());
 <\s>
"
"<s>[INST] get container loader [/INST]         $env = $this->getEnvironment();
        $locator = new FileLocator($this);
        $resolver = new LoaderResolver([
            new XmlFileLoader($container, $locator, $env),
            new YamlFileLoader($container, $locator, $env),
            new IniFileLoader($container, $locator, $env),
            new PhpFileLoader($container, $locator, $env, class_exists(ConfigBuilderGenerator::class) ? new ConfigBuilderGenerator($this->getBuildDir()) : null),
            new GlobFileLoader($container, $locator, $env),
            new DirectoryLoader($container, $locator, $env),
            new ClosureLoader($container, $env),
        ]);

        return new DelegatingLoader($resolver);
 <\s>
"
"<s>[INST] strip comments [/INST]         if (!\function_exists('token_get_all')) {
            return $source;
        }

        $rawChunk = '';
        $output = '';
        $tokens = token_get_all($source);
        $ignoreSpace = false;
        for ($i = 0; isset($tokens[$i]); ++$i) {
            $token = $tokens[$i];
            if (!isset($token[1]) || 'b""' === $token) {
                $rawChunk .= $token;
            } elseif (\T_START_HEREDOC === $token[0]) {
                $output .= $rawChunk.$token[1];
                do {
                    $token = $tokens[++$i];
                    $output .= isset($token[1]) && 'b""' !== $token ? $token[1] : $token;
                } while (\T_END_HEREDOC !== $token[0]);
                $rawChunk = '';
            } elseif (\T_WHITESPACE === $token[0]) {
                if ($ignoreSpace) {
                    $ignoreSpace = false;

                    continue;
                }

                // replace multiple new lines with a single newline
                $rawChunk .= preg_replace(['/\n{2,}/S'], ""\n"", $token[1]);
            } elseif (\in_array($token[0], [\T_COMMENT, \T_DOC_COMMENT])) {
                if (!\in_array($rawChunk[\strlen($rawChunk) - 1], [' ', ""\n"", ""\r"", ""\t""], true)) {
                    $rawChunk .= ' ';
                }
                $ignoreSpace = true;
            } else {
                $rawChunk .= $token[1];

                // The PHP-open tag already has a new-line
                if (\T_OPEN_TAG === $token[0]) {
                    $ignoreSpace = true;
                } else {
                    $ignoreSpace = false;
                }
            }
        }

        $output .= $rawChunk;

        unset($tokens, $rawChunk);
        gc_mem_caches();

        return $output;
 <\s>
"
"<s>[INST] __sleep [/INST]         return ['environment', 'debug'];
 <\s>
"
"<s>[INST] __wakeup [/INST]         if (\is_object($this->environment) || \is_object($this->debug)) {
            throw new \BadMethodCallException('Cannot unserialize '.__CLASS__);
        }

        $this->__construct($this->environment, $this->debug);
 <\s>
"
"<s>[INST] register bundles [/INST]         $contents = require $this->getBundlesPath();
        foreach ($contents as $class => $envs) {
            if ($envs[$this->environment] ?? $envs['all'] ?? false) {
                yield new $class();
            }
        }
 <\s>
"
"<s>[INST] register container configuration [/INST]         $loader->load(function (ContainerBuilder $container) use ($loader) {
            $container->loadFromExtension('framework', [
                'router' => [
                    'resource' => 'kernel::loadRoutes',
                    'type' => 'service',
                ],
            ]);

            $kernelClass = str_contains(static::class, ""@anonymous\0"") ? parent::class : static::class;

            if (!$container->hasDefinition('kernel')) {
                $container->register('kernel', $kernelClass)
                    ->addTag('controller.service_arguments')
                    ->setAutoconfigured(true)
                    ->setSynthetic(true)
                    ->setPublic(true)
                ;
            }

            $kernelDefinition = $container->getDefinition('kernel');
            $kernelDefinition->addTag('routing.route_loader');

            $container->addObjectResource($this);
            $container->fileExists($this->getBundlesPath());

            $configureContainer = new \ReflectionMethod($this, 'configureContainer');
            $configuratorClass = $configureContainer->getNumberOfParameters() > 0 && ($type = $configureContainer->getParameters()[0]->getType()) instanceof \ReflectionNamedType && !$type->isBuiltin() ? $type->getName() : null;

            if ($configuratorClass && !is_a(ContainerConfigurator::class, $configuratorClass, true)) {
                $configureContainer->getClosure($this)($container, $loader);

                return;
            }

            $file = (new \ReflectionObject($this))->getFileName();
            /* @var ContainerPhpFileLoader $kernelLoader */
            $kernelLoader = $loader->getResolver()->resolve($file);
            $kernelLoader->setCurrentDir(\dirname($file));
            $instanceof = &\Closure::bind(fn &() => $this->instanceof, $kernelLoader, $kernelLoader)();

            $valuePreProcessor = AbstractConfigurator::$valuePreProcessor;
            AbstractConfigurator::$valuePreProcessor = fn ($value) => $this === $value ? new Reference('kernel') : $value;

            try {
                $configureContainer->getClosure($this)(new ContainerConfigurator($container, $kernelLoader, $instanceof, $file, $file, $this->getEnvironment()), $loader, $container);
            } finally {
                $instanceof = [];
                $kernelLoader->registerAliasesForSinglyImplementedInterfaces();
                AbstractConfigurator::$valuePreProcessor = $valuePreProcessor;
            }

            $container->setAlias($kernelClass, 'kernel')->setPublic(true);
        });
 <\s>
"
"<s>[INST] configure container [/INST]         $configDir = $this->getConfigDir();

        $container->import($configDir.'/{packages}/*.{php,yaml}');
        $container->import($configDir.'/{packages}/'.$this->environment.'/*.{php,yaml}');

        if (is_file($configDir.'/services.yaml')) {
            $container->import($configDir.'/services.yaml');
            $container->import($configDir.'/{services}_'.$this->environment.'.yaml');
        } else {
            $container->import($configDir.'/{services}.php');
        }
 <\s>
"
"<s>[INST] configure routes [/INST]         $configDir = $this->getConfigDir();

        $routes->import($configDir.'/{routes}/'.$this->environment.'/*.{php,yaml}');
        $routes->import($configDir.'/{routes}/*.{php,yaml}');

        if (is_file($configDir.'/routes.yaml')) {
            $routes->import($configDir.'/routes.yaml');
        } else {
            $routes->import($configDir.'/{routes}.php');
        }

        if (false !== ($fileName = (new \ReflectionObject($this))->getFileName())) {
            $routes->import($fileName, 'annotation');
        }
 <\s>
"
"<s>[INST] get bundles path [/INST]         return $this->getConfigDir().'/bundles.php';
 <\s>
"
"<s>[INST] load routes [/INST]         $file = (new \ReflectionObject($this))->getFileName();
        /* @var RoutingPhpFileLoader $kernelLoader */
        $kernelLoader = $loader->getResolver()->resolve($file, 'php');
        $kernelLoader->setCurrentDir(\dirname($file));
        $collection = new RouteCollection();

        $configureRoutes = new \ReflectionMethod($this, 'configureRoutes');
        $configureRoutes->getClosure($this)(new RoutingConfigurator($collection, $kernelLoader, $file, $file, $this->getEnvironment()));

        foreach ($collection as $route) {
            $controller = $route->getDefault('_controller');

            if (\is_array($controller) && [0, 1] === array_keys($controller) && $this === $controller[0]) {
                $route->setDefault('_controller', ['kernel', $controller[1]]);
            } elseif ($controller instanceof \Closure && $this === ($r = new \ReflectionFunction($controller))->getClosureThis() && !str_contains($r->name, '{closure}')) {
                $route->setDefault('_controller', ['kernel', $r->name]);
            }
        }

        return $collection;
 <\s>
"
"<s>[INST] is transactional [/INST]         return false;
 <\s>
"
"<s>[INST] up [/INST]         $this->abortIf(
            'mysql' !== $this->connection->getDatabasePlatform()->getName(),
            'Migration can only be executed safely on \'mysql\'.'
        );

        $this->addSql(
            'CREATE TABLE tle (id INT AUTO_INCREMENT NOT NULL, updated_at DATETIME NOT NULL, name VARCHAR(255) NOT NULL, line1 VARCHAR(255) NOT NULL, line2 VARCHAR(255) NOT NULL, PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8mb4 COLLATE `utf8mb4_unicode_ci` ENGINE = InnoDB'
        );
 <\s>
"
"<s>[INST] down [/INST]         $this->abortIf(
            'mysql' !== $this->connection->getDatabasePlatform()->getName(),
            'Migration can only be executed safely on \'mysql\'.'
        );

        $this->addSql('DROP TABLE tle');
 <\s>
"
"<s>[INST] __construct [/INST]         $this->connection = $connection;
        $this->sm         = $this->connection->createSchemaManager();
        $this->platform   = $this->connection->getDatabasePlatform();
        $this->logger     = $logger;
 <\s>
"
"<s>[INST] get description [/INST]         return '';
 <\s>
"
"<s>[INST] warn if [/INST]         if (! $condition) {
            return;
        }

        $this->logger->warning($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] abort if [/INST]         if ($condition) {
            throw new AbortMigration($message);
        }
 <\s>
"
"<s>[INST] skip if [/INST]         if ($condition) {
            throw new SkipMigration($message);
        }
 <\s>
"
"<s>[INST] pre up [/INST]  <\s>
"
"<s>[INST] post up [/INST]  <\s>
"
"<s>[INST] pre down [/INST]  <\s>
"
"<s>[INST] post down [/INST]  <\s>
"
"<s>[INST] add sql [/INST]         array $params = [],
        array $types = []
    ): void {
        $this->plannedSql[] = new Query($sql, $params, $types);
 <\s>
"
"<s>[INST] get sql [/INST]         return $this->plannedSql;
 <\s>
"
"<s>[INST] write [/INST]         $this->logger->notice($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] throw irreversible migration exception [/INST]         if ($message === null) {
            $message = 'This migration is irreversible and cannot be reverted.';
        }

        throw new IrreversibleMigration($message);
 <\s>
"
"<s>[INST] down [/INST]         // this down() migration is auto-generated, please modify it to your needs
        $this->abortIf(
            'mysql' !== $this->connection->getDatabasePlatform()->getName(),
            'Migration can only be executed safely on \'mysql\'.'
        );

        $this->addSql('DROP TABLE statistic');
 <\s>
"
"<s>[INST] is transactional [/INST]         return false;
 <\s>
"
"<s>[INST] up [/INST]         // this up() migration is auto-generated, please modify it to your needs
        $this->abortIf(
            'mysql' !== $this->connection->getDatabasePlatform()->getName(),
            'Migration can only be executed safely on \'mysql\'.'
        );

        $this->addSql(
            'CREATE TABLE statistic (tle_id INT NOT NULL, hits BIGINT NOT NULL, PRIMARY KEY(tle_id)) DEFAULT CHARACTER SET utf8mb4 COLLATE `utf8mb4_unicode_ci` ENGINE = InnoDB'
        );
        $this->addSql('ALTER TABLE statistic ADD CONSTRAINT FK_649B469CE84B6F2B FOREIGN KEY (tle_id) REFERENCES tle (id)');
 <\s>
"
"<s>[INST] __construct [/INST]         $this->connection = $connection;
        $this->sm         = $this->connection->createSchemaManager();
        $this->platform   = $this->connection->getDatabasePlatform();
        $this->logger     = $logger;
 <\s>
"
"<s>[INST] get description [/INST]         return '';
 <\s>
"
"<s>[INST] warn if [/INST]         if (! $condition) {
            return;
        }

        $this->logger->warning($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] abort if [/INST]         if ($condition) {
            throw new AbortMigration($message);
        }
 <\s>
"
"<s>[INST] skip if [/INST]         if ($condition) {
            throw new SkipMigration($message);
        }
 <\s>
"
"<s>[INST] pre up [/INST]  <\s>
"
"<s>[INST] post up [/INST]  <\s>
"
"<s>[INST] pre down [/INST]  <\s>
"
"<s>[INST] post down [/INST]  <\s>
"
"<s>[INST] add sql [/INST]         array $params = [],
        array $types = []
    ): void {
        $this->plannedSql[] = new Query($sql, $params, $types);
 <\s>
"
"<s>[INST] get sql [/INST]         return $this->plannedSql;
 <\s>
"
"<s>[INST] write [/INST]         $this->logger->notice($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] throw irreversible migration exception [/INST]         if ($message === null) {
            $message = 'This migration is irreversible and cannot be reverted.';
        }

        throw new IrreversibleMigration($message);
 <\s>
"
"<s>[INST] up [/INST]         // this up() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('CREATE TABLE request (id INT AUTO_INCREMENT NOT NULL, tle_id INT NOT NULL, updated_at DATETIME NOT NULL, ip VARCHAR(255) NOT NULL, INDEX IDX_3B978F9FE84B6F2B (tle_id), PRIMARY KEY(id)) DEFAULT CHARACTER SET utf8mb4 COLLATE `utf8mb4_unicode_ci` ENGINE = InnoDB');
        $this->addSql('ALTER TABLE request ADD CONSTRAINT FK_3B978F9FE84B6F2B FOREIGN KEY (tle_id) REFERENCES tle (id)');
 <\s>
"
"<s>[INST] down [/INST]         // this down() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('DROP TABLE request');
 <\s>
"
"<s>[INST] __construct [/INST]         $this->connection = $connection;
        $this->sm         = $this->connection->createSchemaManager();
        $this->platform   = $this->connection->getDatabasePlatform();
        $this->logger     = $logger;
 <\s>
"
"<s>[INST] is transactional [/INST]         return true;
 <\s>
"
"<s>[INST] get description [/INST]         return '';
 <\s>
"
"<s>[INST] warn if [/INST]         if (! $condition) {
            return;
        }

        $this->logger->warning($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] abort if [/INST]         if ($condition) {
            throw new AbortMigration($message);
        }
 <\s>
"
"<s>[INST] skip if [/INST]         if ($condition) {
            throw new SkipMigration($message);
        }
 <\s>
"
"<s>[INST] pre up [/INST]  <\s>
"
"<s>[INST] post up [/INST]  <\s>
"
"<s>[INST] pre down [/INST]  <\s>
"
"<s>[INST] post down [/INST]  <\s>
"
"<s>[INST] add sql [/INST]         array $params = [],
        array $types = []
    ): void {
        $this->plannedSql[] = new Query($sql, $params, $types);
 <\s>
"
"<s>[INST] get sql [/INST]         return $this->plannedSql;
 <\s>
"
"<s>[INST] write [/INST]         $this->logger->notice($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] throw irreversible migration exception [/INST]         if ($message === null) {
            $message = 'This migration is irreversible and cannot be reverted.';
        }

        throw new IrreversibleMigration($message);
 <\s>
"
"<s>[INST] up [/INST]         // this up() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('ALTER TABLE request CHANGE updated_at created_at DATETIME NOT NULL');
 <\s>
"
"<s>[INST] down [/INST]         // this down() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('ALTER TABLE request CHANGE created_at updated_at DATETIME NOT NULL');
 <\s>
"
"<s>[INST] __construct [/INST]         $this->connection = $connection;
        $this->sm         = $this->connection->createSchemaManager();
        $this->platform   = $this->connection->getDatabasePlatform();
        $this->logger     = $logger;
 <\s>
"
"<s>[INST] is transactional [/INST]         return true;
 <\s>
"
"<s>[INST] get description [/INST]         return '';
 <\s>
"
"<s>[INST] warn if [/INST]         if (! $condition) {
            return;
        }

        $this->logger->warning($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] abort if [/INST]         if ($condition) {
            throw new AbortMigration($message);
        }
 <\s>
"
"<s>[INST] skip if [/INST]         if ($condition) {
            throw new SkipMigration($message);
        }
 <\s>
"
"<s>[INST] pre up [/INST]  <\s>
"
"<s>[INST] post up [/INST]  <\s>
"
"<s>[INST] pre down [/INST]  <\s>
"
"<s>[INST] post down [/INST]  <\s>
"
"<s>[INST] add sql [/INST]         array $params = [],
        array $types = []
    ): void {
        $this->plannedSql[] = new Query($sql, $params, $types);
 <\s>
"
"<s>[INST] get sql [/INST]         return $this->plannedSql;
 <\s>
"
"<s>[INST] write [/INST]         $this->logger->notice($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] throw irreversible migration exception [/INST]         if ($message === null) {
            $message = 'This migration is irreversible and cannot be reverted.';
        }

        throw new IrreversibleMigration($message);
 <\s>
"
"<s>[INST] is transactional [/INST]         return false;
 <\s>
"
"<s>[INST] up [/INST]         // this up() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('CREATE TABLE tle_information (tle_id INT NOT NULL, eccentricity DOUBLE PRECISION DEFAULT NULL, inclination DOUBLE PRECISION DEFAULT NULL, PRIMARY KEY(tle_id)) DEFAULT CHARACTER SET utf8mb4 COLLATE `utf8mb4_unicode_ci` ENGINE = InnoDB');
        $this->addSql('ALTER TABLE tle_information ADD CONSTRAINT FK_E216A773E84B6F2B FOREIGN KEY (tle_id) REFERENCES tle (id)');
 <\s>
"
"<s>[INST] down [/INST]         // this down() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('DROP TABLE tle_information');
 <\s>
"
"<s>[INST] __construct [/INST]         $this->connection = $connection;
        $this->sm         = $this->connection->createSchemaManager();
        $this->platform   = $this->connection->getDatabasePlatform();
        $this->logger     = $logger;
 <\s>
"
"<s>[INST] get description [/INST]         return '';
 <\s>
"
"<s>[INST] warn if [/INST]         if (! $condition) {
            return;
        }

        $this->logger->warning($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] abort if [/INST]         if ($condition) {
            throw new AbortMigration($message);
        }
 <\s>
"
"<s>[INST] skip if [/INST]         if ($condition) {
            throw new SkipMigration($message);
        }
 <\s>
"
"<s>[INST] pre up [/INST]  <\s>
"
"<s>[INST] post up [/INST]  <\s>
"
"<s>[INST] pre down [/INST]  <\s>
"
"<s>[INST] post down [/INST]  <\s>
"
"<s>[INST] add sql [/INST]         array $params = [],
        array $types = []
    ): void {
        $this->plannedSql[] = new Query($sql, $params, $types);
 <\s>
"
"<s>[INST] get sql [/INST]         return $this->plannedSql;
 <\s>
"
"<s>[INST] write [/INST]         $this->logger->notice($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] throw irreversible migration exception [/INST]         if ($message === null) {
            $message = 'This migration is irreversible and cannot be reverted.';
        }

        throw new IrreversibleMigration($message);
 <\s>
"
"<s>[INST] up [/INST]         // this up() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('ALTER TABLE tle_information ADD `period` DOUBLE PRECISION DEFAULT NULL');
 <\s>
"
"<s>[INST] down [/INST]         // this down() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('ALTER TABLE tle_information DROP `period`');
 <\s>
"
"<s>[INST] __construct [/INST]         $this->connection = $connection;
        $this->sm         = $this->connection->createSchemaManager();
        $this->platform   = $this->connection->getDatabasePlatform();
        $this->logger     = $logger;
 <\s>
"
"<s>[INST] is transactional [/INST]         return true;
 <\s>
"
"<s>[INST] get description [/INST]         return '';
 <\s>
"
"<s>[INST] warn if [/INST]         if (! $condition) {
            return;
        }

        $this->logger->warning($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] abort if [/INST]         if ($condition) {
            throw new AbortMigration($message);
        }
 <\s>
"
"<s>[INST] skip if [/INST]         if ($condition) {
            throw new SkipMigration($message);
        }
 <\s>
"
"<s>[INST] pre up [/INST]  <\s>
"
"<s>[INST] post up [/INST]  <\s>
"
"<s>[INST] pre down [/INST]  <\s>
"
"<s>[INST] post down [/INST]  <\s>
"
"<s>[INST] add sql [/INST]         array $params = [],
        array $types = []
    ): void {
        $this->plannedSql[] = new Query($sql, $params, $types);
 <\s>
"
"<s>[INST] get sql [/INST]         return $this->plannedSql;
 <\s>
"
"<s>[INST] write [/INST]         $this->logger->notice($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] throw irreversible migration exception [/INST]         if ($message === null) {
            $message = 'This migration is irreversible and cannot be reverted.';
        }

        throw new IrreversibleMigration($message);
 <\s>
"
"<s>[INST] up [/INST]         // this up() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('ALTER TABLE tle_information ADD geostationary TINYINT(1) DEFAULT \'0\' NOT NULL');
 <\s>
"
"<s>[INST] down [/INST]         // this down() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('ALTER TABLE tle_information DROP geostationary');
 <\s>
"
"<s>[INST] __construct [/INST]         $this->connection = $connection;
        $this->sm         = $this->connection->createSchemaManager();
        $this->platform   = $this->connection->getDatabasePlatform();
        $this->logger     = $logger;
 <\s>
"
"<s>[INST] is transactional [/INST]         return true;
 <\s>
"
"<s>[INST] get description [/INST]         return '';
 <\s>
"
"<s>[INST] warn if [/INST]         if (! $condition) {
            return;
        }

        $this->logger->warning($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] abort if [/INST]         if ($condition) {
            throw new AbortMigration($message);
        }
 <\s>
"
"<s>[INST] skip if [/INST]         if ($condition) {
            throw new SkipMigration($message);
        }
 <\s>
"
"<s>[INST] pre up [/INST]  <\s>
"
"<s>[INST] post up [/INST]  <\s>
"
"<s>[INST] pre down [/INST]  <\s>
"
"<s>[INST] post down [/INST]  <\s>
"
"<s>[INST] add sql [/INST]         array $params = [],
        array $types = []
    ): void {
        $this->plannedSql[] = new Query($sql, $params, $types);
 <\s>
"
"<s>[INST] get sql [/INST]         return $this->plannedSql;
 <\s>
"
"<s>[INST] write [/INST]         $this->logger->notice($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] throw irreversible migration exception [/INST]         if ($message === null) {
            $message = 'This migration is irreversible and cannot be reverted.';
        }

        throw new IrreversibleMigration($message);
 <\s>
"
"<s>[INST] is transactional [/INST]         return false;
 <\s>
"
"<s>[INST] up [/INST]         // this up() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('DROP TABLE statistic');
 <\s>
"
"<s>[INST] down [/INST]         // this down() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('CREATE TABLE statistic (tle_id INT NOT NULL, hits BIGINT NOT NULL, PRIMARY KEY(tle_id)) DEFAULT CHARACTER SET utf8 COLLATE `utf8_unicode_ci` ENGINE = InnoDB COMMENT = \'\' ');
        $this->addSql('ALTER TABLE statistic ADD CONSTRAINT FK_649B469CE84B6F2B FOREIGN KEY (tle_id) REFERENCES tle (id) ON UPDATE NO ACTION ON DELETE NO ACTION');
 <\s>
"
"<s>[INST] __construct [/INST]         $this->connection = $connection;
        $this->sm         = $this->connection->createSchemaManager();
        $this->platform   = $this->connection->getDatabasePlatform();
        $this->logger     = $logger;
 <\s>
"
"<s>[INST] get description [/INST]         return '';
 <\s>
"
"<s>[INST] warn if [/INST]         if (! $condition) {
            return;
        }

        $this->logger->warning($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] abort if [/INST]         if ($condition) {
            throw new AbortMigration($message);
        }
 <\s>
"
"<s>[INST] skip if [/INST]         if ($condition) {
            throw new SkipMigration($message);
        }
 <\s>
"
"<s>[INST] pre up [/INST]  <\s>
"
"<s>[INST] post up [/INST]  <\s>
"
"<s>[INST] pre down [/INST]  <\s>
"
"<s>[INST] post down [/INST]  <\s>
"
"<s>[INST] add sql [/INST]         array $params = [],
        array $types = []
    ): void {
        $this->plannedSql[] = new Query($sql, $params, $types);
 <\s>
"
"<s>[INST] get sql [/INST]         return $this->plannedSql;
 <\s>
"
"<s>[INST] write [/INST]         $this->logger->notice($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] throw irreversible migration exception [/INST]         if ($message === null) {
            $message = 'This migration is irreversible and cannot be reverted.';
        }

        throw new IrreversibleMigration($message);
 <\s>
"
"<s>[INST] up [/INST]         // this up() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('ALTER TABLE tle_information ADD raan DOUBLE PRECISION DEFAULT NULL, ADD semi_major_axis DOUBLE PRECISION DEFAULT NULL');
 <\s>
"
"<s>[INST] down [/INST]         // this down() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('ALTER TABLE tle_information DROP raan, DROP semi_major_axis');
 <\s>
"
"<s>[INST] __construct [/INST]         $this->connection = $connection;
        $this->sm         = $this->connection->createSchemaManager();
        $this->platform   = $this->connection->getDatabasePlatform();
        $this->logger     = $logger;
 <\s>
"
"<s>[INST] is transactional [/INST]         return true;
 <\s>
"
"<s>[INST] get description [/INST]         return '';
 <\s>
"
"<s>[INST] warn if [/INST]         if (! $condition) {
            return;
        }

        $this->logger->warning($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] abort if [/INST]         if ($condition) {
            throw new AbortMigration($message);
        }
 <\s>
"
"<s>[INST] skip if [/INST]         if ($condition) {
            throw new SkipMigration($message);
        }
 <\s>
"
"<s>[INST] pre up [/INST]  <\s>
"
"<s>[INST] post up [/INST]  <\s>
"
"<s>[INST] pre down [/INST]  <\s>
"
"<s>[INST] post down [/INST]  <\s>
"
"<s>[INST] add sql [/INST]         array $params = [],
        array $types = []
    ): void {
        $this->plannedSql[] = new Query($sql, $params, $types);
 <\s>
"
"<s>[INST] get sql [/INST]         return $this->plannedSql;
 <\s>
"
"<s>[INST] write [/INST]         $this->logger->notice($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] throw irreversible migration exception [/INST]         if ($message === null) {
            $message = 'This migration is irreversible and cannot be reverted.';
        }

        throw new IrreversibleMigration($message);
 <\s>
"
"<s>[INST] is transactional [/INST]         return false;
 <\s>
"
"<s>[INST] up [/INST]         // this up() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('ALTER TABLE request ADD referer VARCHAR(255) DEFAULT NULL');
 <\s>
"
"<s>[INST] down [/INST]         // this down() migration is auto-generated, please modify it to your needs
        $this->abortIf('mysql' !== $this->connection->getDatabasePlatform()->getName(), 'Migration can only be executed safely on \'mysql\'.');

        $this->addSql('ALTER TABLE request DROP referer');
 <\s>
"
"<s>[INST] __construct [/INST]         $this->connection = $connection;
        $this->sm         = $this->connection->createSchemaManager();
        $this->platform   = $this->connection->getDatabasePlatform();
        $this->logger     = $logger;
 <\s>
"
"<s>[INST] get description [/INST]         return '';
 <\s>
"
"<s>[INST] warn if [/INST]         if (! $condition) {
            return;
        }

        $this->logger->warning($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] abort if [/INST]         if ($condition) {
            throw new AbortMigration($message);
        }
 <\s>
"
"<s>[INST] skip if [/INST]         if ($condition) {
            throw new SkipMigration($message);
        }
 <\s>
"
"<s>[INST] pre up [/INST]  <\s>
"
"<s>[INST] post up [/INST]  <\s>
"
"<s>[INST] pre down [/INST]  <\s>
"
"<s>[INST] post down [/INST]  <\s>
"
"<s>[INST] add sql [/INST]         array $params = [],
        array $types = []
    ): void {
        $this->plannedSql[] = new Query($sql, $params, $types);
 <\s>
"
"<s>[INST] get sql [/INST]         return $this->plannedSql;
 <\s>
"
"<s>[INST] write [/INST]         $this->logger->notice($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] throw irreversible migration exception [/INST]         if ($message === null) {
            $message = 'This migration is irreversible and cannot be reverted.';
        }

        throw new IrreversibleMigration($message);
 <\s>
"
"<s>[INST] get description [/INST]         return '';
 <\s>
"
"<s>[INST] up [/INST]         // this up() migration is auto-generated, please modify it to your needs
        $this->addSql('CREATE TABLE tle_stats (name VARCHAR(255) NOT NULL, tle_id INT NOT NULL, INDEX IDX_574767AAE84B6F2B (tle_id), PRIMARY KEY(name, tle_id)) DEFAULT CHARACTER SET utf8mb4 COLLATE `utf8mb4_unicode_ci` ENGINE = InnoDB');
        $this->addSql('ALTER TABLE tle_stats ADD CONSTRAINT FK_574767AAE84B6F2B FOREIGN KEY (tle_id) REFERENCES tle (id)');
 <\s>
"
"<s>[INST] down [/INST]         // this down() migration is auto-generated, please modify it to your needs
        $this->addSql('ALTER TABLE tle_stats DROP FOREIGN KEY FK_574767AAE84B6F2B');
        $this->addSql('DROP TABLE tle_stats');
 <\s>
"
"<s>[INST] __construct [/INST]         $this->connection = $connection;
        $this->sm         = $this->connection->createSchemaManager();
        $this->platform   = $this->connection->getDatabasePlatform();
        $this->logger     = $logger;
 <\s>
"
"<s>[INST] is transactional [/INST]         return true;
 <\s>
"
"<s>[INST] warn if [/INST]         if (! $condition) {
            return;
        }

        $this->logger->warning($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] abort if [/INST]         if ($condition) {
            throw new AbortMigration($message);
        }
 <\s>
"
"<s>[INST] skip if [/INST]         if ($condition) {
            throw new SkipMigration($message);
        }
 <\s>
"
"<s>[INST] pre up [/INST]  <\s>
"
"<s>[INST] post up [/INST]  <\s>
"
"<s>[INST] pre down [/INST]  <\s>
"
"<s>[INST] post down [/INST]  <\s>
"
"<s>[INST] add sql [/INST]         array $params = [],
        array $types = []
    ): void {
        $this->plannedSql[] = new Query($sql, $params, $types);
 <\s>
"
"<s>[INST] get sql [/INST]         return $this->plannedSql;
 <\s>
"
"<s>[INST] write [/INST]         $this->logger->notice($message, ['migration' => $this]);
 <\s>
"
"<s>[INST] throw irreversible migration exception [/INST]         if ($message === null) {
            $message = 'This migration is irreversible and cannot be reverted.';
        }

        throw new IrreversibleMigration($message);
 <\s>
"
"<s>[INST] __construct [/INST]  <\s>
"
"<s>[INST] normalize [/INST]         return [
            '@type' => 'Observer',
            ...$this->normalizer->normalize($object),
        ];
 <\s>
"
"<s>[INST] supports normalization [/INST]         return $data instanceof Observer;
 <\s>
"
"<s>[INST] __construct [/INST]  <\s>
"
"<s>[INST] normalize [/INST]         $timezone = $context['timezone'] ?? 'UTC';
        $details = $context['details'] ?? false;

        $result = [
            '@type' => $details ? 'SatelliteFlyOverDetails' : 'SatelliteFlyOver',
            'aos' => [
                'date' => \Predict_Time::daynum2datetime($object->visible_aos ?? $object->aos, $timezone)->format(
                    \DateTimeInterface::ATOM
                ),
                'azimuth' => round($object->visible_aos_az ?? null, 2),
                'elevation' => round($object->visible_aos_el ?? null, 2),
            ],
            'max' => [
                'date' => \Predict_Time::daynum2datetime($object->visible_tca ?? $object->tca, $timezone)->format(
                    \DateTimeInterface::ATOM
                ),
                'azimuth' => round($object->visible_max_el_az ?? null, 2),
                'elevation' => round($object->visible_max_el ?? null, 2),
            ],
            'los' => [
                'date' => \Predict_Time::daynum2datetime($object->visible_los ?? $object->los, $timezone)->format(
                    \DateTimeInterface::ATOM
                ),
                'azimuth' => round($object->visible_los_az ?? $object->los_az, 2),
                'elevation' => round($object->visible_los_el ?? null, 2),
            ],
        ];

        if ($details) {
            foreach ($object->details as $item) {
                $result['details'][] = [
                    'azimuth' => $item->az,
                    'elevation' => $item->el,
                ];
            }
        }

        return $result;
 <\s>
"
"<s>[INST] supports normalization [/INST]         return $data instanceof \Predict_Pass;
 <\s>
"
"<s>[INST] __construct [/INST]  <\s>
"
"<s>[INST] normalize [/INST]         $id = $this->router->generate('tle_record', ['id' => $object->getId()], UrlGeneratorInterface::ABSOLUTE_URL);

        $model = new TleModel($object->getLine1(), $object->getLine2(), $object->getName());

        $isExtra = ($context[TleRequest::EXTRA_PARAM] ?? null) === true;

        $normalized = [
            '@id' => $id,
            '@type' => 'Tle',
            'satelliteId' => $model->getId(),
            'name' => $model->getName(),
            'date' => $model->epochDateTime()->format(\DateTimeInterface::ATOM),
            'line1' => $model->getLine1(),
            'line2' => $model->getLine2(),
        ];

        if ($isExtra && $object->getInfo()) {
            $normalized['extra'] = [
                TleCollectionSortableFieldsEnum::ECCENTRICITY => $object->getInfo()->eccentricity,
                TleCollectionSortableFieldsEnum::INCLINATION => $object->getInfo()->inclination,
                TleCollectionSortableFieldsEnum::PERIOD => $object->getInfo()->period,
                TleCollectionSortableFieldsEnum::RAAN => $object->getInfo()->raan,
                TleCollectionSortableFieldsEnum::SEMI_MAJOR_AXIS => $object->getInfo()->semiMajorAxis,
            ];

            $normalized['orbit'] = [
                'geostationary' => $object->getInfo()->geostationary,
            ];
        }

        return $normalized;
 <\s>
"
"<s>[INST] supports normalization [/INST]         return $data instanceof Tle;
 <\s>
"
"<s>[INST] __construct [/INST]         parent::__construct($registry, Request::class);
 <\s>
"
"<s>[INST] remove before [/INST]         $builder = $this->_em->createQueryBuilder();

        $builder
            ->delete(Request::class, 'r')
            ->where('r.createdAt < :date')
            ->setParameter('date', $dateTime);

        $builder->getQuery()->execute();
 <\s>
"
"<s>[INST] create query builder [/INST]         return $this->_em->createQueryBuilder()
            ->select($alias)
            ->from($this->_entityName, $alias, $indexBy);
 <\s>
"
"<s>[INST] create result set mapping builder [/INST]         $rsm = new ResultSetMappingBuilder($this->_em, ResultSetMappingBuilder::COLUMN_RENAMING_INCREMENT);
        $rsm->addRootEntityFromClassMetadata($this->_entityName, $alias);

        return $rsm;
 <\s>
"
"<s>[INST] create named query [/INST]         Deprecation::trigger(
            'doctrine/orm',
            'https://github.com/doctrine/orm/issues/8592',
            'Named Queries are deprecated, here ""%s"" on entity %s. Move the query logic into EntityRepository',
            $queryName,
            $this->_class->name
        );

        return $this->_em->createQuery($this->_class->getNamedQuery($queryName));
 <\s>
"
"<s>[INST] create native named query [/INST]         Deprecation::trigger(
            'doctrine/orm',
            'https://github.com/doctrine/orm/issues/8592',
            'Named Native Queries are deprecated, here ""%s"" on entity %s. Move the query logic into EntityRepository',
            $queryName,
            $this->_class->name
        );

        $queryMapping = $this->_class->getNamedNativeQuery($queryName);
        $rsm          = new Query\ResultSetMappingBuilder($this->_em);
        $rsm->addNamedNativeQueryMapping($this->_class, $queryMapping);

        return $this->_em->createNativeQuery($queryMapping['query'], $rsm);
 <\s>
"
"<s>[INST] clear [/INST]         Deprecation::trigger(
            'doctrine/orm',
            'https://github.com/doctrine/orm/issues/8460',
            'Calling %s() is deprecated and will not be supported in Doctrine ORM 3.0.',
            __METHOD__
        );

        if (! class_exists(PersistentObject::class)) {
            throw NotSupported::createForPersistence3(sprintf(
                'Partial clearing of entities for class %s',
                $this->_class->rootEntityName
            ));
        }

        $this->_em->clear($this->_class->rootEntityName);
 <\s>
"
"<s>[INST] find [/INST]         return $this->_em->find($this->_entityName, $id, $lockMode, $lockVersion);
 <\s>
"
"<s>[INST] find all [/INST]         return $this->findBy([]);
 <\s>
"
"<s>[INST] find by [/INST]         $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName);

        return $persister->loadAll($criteria, $orderBy, $limit, $offset);
 <\s>
"
"<s>[INST] find one by [/INST]         $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName);

        return $persister->load($criteria, null, null, [], null, 1, $orderBy);
 <\s>
"
"<s>[INST] count [/INST]         return $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName)->count($criteria);
 <\s>
"
"<s>[INST] __call [/INST]         if (str_starts_with($method, 'findBy')) {
            return $this->resolveMagicCall('findBy', substr($method, 6), $arguments);
        }

        if (str_starts_with($method, 'findOneBy')) {
            return $this->resolveMagicCall('findOneBy', substr($method, 9), $arguments);
        }

        if (str_starts_with($method, 'countBy')) {
            return $this->resolveMagicCall('count', substr($method, 7), $arguments);
        }

        throw new BadMethodCallException(sprintf(
            'Undefined method ""%s"". The method name must start with ' .
            'either findBy, findOneBy or countBy!',
            $method
        ));
 <\s>
"
"<s>[INST] get entity name [/INST]         return $this->_entityName;
 <\s>
"
"<s>[INST] get class name [/INST]         return $this->getEntityName();
 <\s>
"
"<s>[INST] get entity manager [/INST]         return $this->_em;
 <\s>
"
"<s>[INST] get class metadata [/INST]         return $this->_class;
 <\s>
"
"<s>[INST] matching [/INST]         $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName);

        return new LazyCriteriaCollection($persister, $criteria);
 <\s>
"
"<s>[INST] is lazy object initialized [/INST]         if (!$state = $this->lazyObjectState ?? null) {
            return true;
        }

        if (!\is_array($state->initializer)) {
            return LazyObjectState::STATUS_INITIALIZED_FULL === $state->status;
        }

        $class = $this::class;
        $properties = (array) $this;

        if ($partial) {
            return (bool) array_intersect_key($state->initializer, $properties);
        }

        $propertyScopes = Hydrator::$propertyScopes[$class] ??= Hydrator::getPropertyScopes($class);
        foreach ($state->initializer as $key => $initializer) {
            if (!\array_key_exists($key, $properties) && isset($propertyScopes[$key])) {
                return false;
            }
        }

        return true;
 <\s>
"
"<s>[INST] initialize lazy object [/INST]         if (!$state = $this->lazyObjectState ?? null) {
            return $this;
        }

        if (!\is_array($state->initializer)) {
            if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {
                $state->initialize($this, '', null);
            }

            return $this;
        }

        $values = isset($state->initializer[""\0""]) ? null : [];

        $class = $this::class;
        $properties = (array) $this;
        $propertyScopes = Hydrator::$propertyScopes[$class] ??= Hydrator::getPropertyScopes($class);
        foreach ($state->initializer as $key => $initializer) {
            if (\array_key_exists($key, $properties) || ![$scope, $name, $readonlyScope] = $propertyScopes[$key] ?? null) {
                continue;
            }
            $scope = $readonlyScope ?? ('*' !== $scope ? $scope : $class);

            if (null === $values) {
                if (!\is_array($values = ($state->initializer[""\0""])($this, Registry::$defaultProperties[$class]))) {
                    throw new \TypeError(sprintf('The lazy-initializer defined for instance of ""%s"" must return an array, got ""%s"".', $class, get_debug_type($values)));
                }

                if (\array_key_exists($key, $properties = (array) $this)) {
                    continue;
                }
            }

            if (\array_key_exists($key, $values)) {
                $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);
                $accessor['set']($this, $name, $properties[$key] = $values[$key]);
            } else {
                $state->initialize($this, $name, $scope);
                $properties = (array) $this;
            }
        }

        return $this;
 <\s>
"
"<s>[INST] reset lazy object [/INST]         if (!$state = $this->lazyObjectState ?? null) {
            return false;
        }

        if (LazyObjectState::STATUS_UNINITIALIZED_FULL !== $state->status) {
            $state->reset($this);
        }

        return true;
 <\s>
"
"<s>[INST] __get [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name);
            $state = $this->lazyObjectState ?? null;

            if ($state && (null === $scope || isset($propertyScopes[""\0$scope\0$name""]))
                && LazyObjectState::STATUS_UNINITIALIZED_PARTIAL !== $state->initialize($this, $name, $readonlyScope ?? $scope)
            ) {
                goto get_in_scope;
            }
        }

        if ($parent = (Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['get']) {
            if (2 === $parent) {
                return parent::__get($name);
            }
            $value = parent::__get($name);

            return $value;
        }

        if (null === $class) {
            $frame = debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
            trigger_error(sprintf('Undefined property: %s::$%s in %s on line %s', $this::class, $name, $frame['file'], $frame['line']), \E_USER_NOTICE);
        }

        get_in_scope:

        try {
            if (null === $scope) {
                if (null === $readonlyScope) {
                    return $this->$name;
                }
                $value = $this->$name;

                return $value;
            }
            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);

            return $accessor['get']($this, $name, null !== $readonlyScope);
        } catch (\Error $e) {
            if (\Error::class !== $e::class || !str_starts_with($e->getMessage(), 'Cannot access uninitialized non-nullable property')) {
                throw $e;
            }

            try {
                if (null === $scope) {
                    $this->$name = [];

                    return $this->$name;
                }

                $accessor['set']($this, $name, []);

                return $accessor['get']($this, $name, null !== $readonlyScope);
            } catch (\Error) {
                throw $e;
            }
        }
 <\s>
"
"<s>[INST] __set [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name, $readonlyScope);
            $state = $this->lazyObjectState ?? null;

            if ($state && ($readonlyScope === $scope || isset($propertyScopes[""\0$scope\0$name""]))) {
                if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {
                    $state->initialize($this, $name, $readonlyScope ?? $scope);
                }
                goto set_in_scope;
            }
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['set']) {
            parent::__set($name, $value);

            return;
        }

        set_in_scope:

        if (null === $scope) {
            $this->$name = $value;
        } else {
            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);
            $accessor['set']($this, $name, $value);
        }
 <\s>
"
"<s>[INST] __isset [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name);
            $state = $this->lazyObjectState ?? null;

            if ($state && (null === $scope || isset($propertyScopes[""\0$scope\0$name""]))
                && LazyObjectState::STATUS_UNINITIALIZED_PARTIAL !== $state->initialize($this, $name, $readonlyScope ?? $scope)
            ) {
                goto isset_in_scope;
            }
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['isset']) {
            return parent::__isset($name);
        }

        isset_in_scope:

        if (null === $scope) {
            return isset($this->$name);
        }
        $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);

        return $accessor['isset']($this, $name);
 <\s>
"
"<s>[INST] __unset [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name, $readonlyScope);
            $state = $this->lazyObjectState ?? null;

            if ($state && ($readonlyScope === $scope || isset($propertyScopes[""\0$scope\0$name""]))) {
                if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {
                    $state->initialize($this, $name, $readonlyScope ?? $scope);
                }
                goto unset_in_scope;
            }
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['unset']) {
            parent::__unset($name);

            return;
        }

        unset_in_scope:

        if (null === $scope) {
            unset($this->$name);
        } else {
            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);
            $accessor['unset']($this, $name);
        }
 <\s>
"
"<s>[INST] __clone [/INST]         if ($state = $this->lazyObjectState ?? null) {
            $this->lazyObjectState = clone $state;
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['clone']) {
            parent::__clone();
        }
 <\s>
"
"<s>[INST] __serialize [/INST]         $class = self::class;

        if ((Registry::$parentMethods[$class] ??= Registry::getParentMethods($class))['serialize']) {
            $properties = parent::__serialize();
        } else {
            $this->initializeLazyObject();
            $properties = (array) $this;
        }
        unset($properties[""\0$class\0lazyObjectState""]);

        if (Registry::$parentMethods[$class]['serialize'] || !Registry::$parentMethods[$class]['sleep']) {
            return $properties;
        }

        $scope = get_parent_class($class);
        $data = [];

        foreach (parent::__sleep() as $name) {
            $value = $properties[$k = $name] ?? $properties[$k = ""\0*\0$name""] ?? $properties[$k = ""\0$scope\0$name""] ?? $k = null;

            if (null === $k) {
                trigger_error(sprintf('serialize(): ""%s"" returned as member variable from __sleep() but does not exist', $name), \E_USER_NOTICE);
            } else {
                $data[$k] = $value;
            }
        }

        return $data;
 <\s>
"
"<s>[INST] __destruct [/INST]         $state = $this->lazyObjectState ?? null;

        if ($state && \in_array($state->status, [LazyObjectState::STATUS_UNINITIALIZED_FULL, LazyObjectState::STATUS_UNINITIALIZED_PARTIAL], true)) {
            return;
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['destruct']) {
            parent::__destruct();
        }
 <\s>
"
"<s>[INST] __construct [/INST]         parent::__construct($registry, TleInformation::class);
 <\s>
"
"<s>[INST] get max inclination [/INST]         $tle = $this->createQueryBuilder('i')
            ->select('i')
            ->orderBy('i.inclination', 'DESC')
            ->setMaxResults(1)
            ->getQuery()
            ->getSingleResult();

        return $tle ? $tle->getTle() : null;
 <\s>
"
"<s>[INST] get max period [/INST]         $tle = $this->createQueryBuilder('i')
            ->select('i')
            ->orderBy('i.period', 'DESC')
            ->setMaxResults(1)
            ->getQuery()
            ->getSingleResult();

        return $tle ? $tle->getTle() : null;
 <\s>
"
"<s>[INST] get min period [/INST]         $tle = $this->createQueryBuilder('i')
            ->select('i')
            ->orderBy('i.period', 'ASC')
            ->setMaxResults(1)
            ->getQuery()
            ->getSingleResult();

        return $tle ? $tle->getTle() : null;
 <\s>
"
"<s>[INST] get max eccentricity [/INST]         $tle = $this->createQueryBuilder('i')
            ->select('i')
            ->orderBy('i.eccentricity', 'DESC')
            ->setMaxResults(1)
            ->getQuery()
            ->getSingleResult();

        return $tle ? $tle->getTle() : null;
 <\s>
"
"<s>[INST] create query builder [/INST]         return $this->_em->createQueryBuilder()
            ->select($alias)
            ->from($this->_entityName, $alias, $indexBy);
 <\s>
"
"<s>[INST] create result set mapping builder [/INST]         $rsm = new ResultSetMappingBuilder($this->_em, ResultSetMappingBuilder::COLUMN_RENAMING_INCREMENT);
        $rsm->addRootEntityFromClassMetadata($this->_entityName, $alias);

        return $rsm;
 <\s>
"
"<s>[INST] create named query [/INST]         Deprecation::trigger(
            'doctrine/orm',
            'https://github.com/doctrine/orm/issues/8592',
            'Named Queries are deprecated, here ""%s"" on entity %s. Move the query logic into EntityRepository',
            $queryName,
            $this->_class->name
        );

        return $this->_em->createQuery($this->_class->getNamedQuery($queryName));
 <\s>
"
"<s>[INST] create native named query [/INST]         Deprecation::trigger(
            'doctrine/orm',
            'https://github.com/doctrine/orm/issues/8592',
            'Named Native Queries are deprecated, here ""%s"" on entity %s. Move the query logic into EntityRepository',
            $queryName,
            $this->_class->name
        );

        $queryMapping = $this->_class->getNamedNativeQuery($queryName);
        $rsm          = new Query\ResultSetMappingBuilder($this->_em);
        $rsm->addNamedNativeQueryMapping($this->_class, $queryMapping);

        return $this->_em->createNativeQuery($queryMapping['query'], $rsm);
 <\s>
"
"<s>[INST] clear [/INST]         Deprecation::trigger(
            'doctrine/orm',
            'https://github.com/doctrine/orm/issues/8460',
            'Calling %s() is deprecated and will not be supported in Doctrine ORM 3.0.',
            __METHOD__
        );

        if (! class_exists(PersistentObject::class)) {
            throw NotSupported::createForPersistence3(sprintf(
                'Partial clearing of entities for class %s',
                $this->_class->rootEntityName
            ));
        }

        $this->_em->clear($this->_class->rootEntityName);
 <\s>
"
"<s>[INST] find [/INST]         return $this->_em->find($this->_entityName, $id, $lockMode, $lockVersion);
 <\s>
"
"<s>[INST] find all [/INST]         return $this->findBy([]);
 <\s>
"
"<s>[INST] find by [/INST]         $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName);

        return $persister->loadAll($criteria, $orderBy, $limit, $offset);
 <\s>
"
"<s>[INST] find one by [/INST]         $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName);

        return $persister->load($criteria, null, null, [], null, 1, $orderBy);
 <\s>
"
"<s>[INST] count [/INST]         return $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName)->count($criteria);
 <\s>
"
"<s>[INST] __call [/INST]         if (str_starts_with($method, 'findBy')) {
            return $this->resolveMagicCall('findBy', substr($method, 6), $arguments);
        }

        if (str_starts_with($method, 'findOneBy')) {
            return $this->resolveMagicCall('findOneBy', substr($method, 9), $arguments);
        }

        if (str_starts_with($method, 'countBy')) {
            return $this->resolveMagicCall('count', substr($method, 7), $arguments);
        }

        throw new BadMethodCallException(sprintf(
            'Undefined method ""%s"". The method name must start with ' .
            'either findBy, findOneBy or countBy!',
            $method
        ));
 <\s>
"
"<s>[INST] get entity name [/INST]         return $this->_entityName;
 <\s>
"
"<s>[INST] get class name [/INST]         return $this->getEntityName();
 <\s>
"
"<s>[INST] get entity manager [/INST]         return $this->_em;
 <\s>
"
"<s>[INST] get class metadata [/INST]         return $this->_class;
 <\s>
"
"<s>[INST] matching [/INST]         $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName);

        return new LazyCriteriaCollection($persister, $criteria);
 <\s>
"
"<s>[INST] is lazy object initialized [/INST]         if (!$state = $this->lazyObjectState ?? null) {
            return true;
        }

        if (!\is_array($state->initializer)) {
            return LazyObjectState::STATUS_INITIALIZED_FULL === $state->status;
        }

        $class = $this::class;
        $properties = (array) $this;

        if ($partial) {
            return (bool) array_intersect_key($state->initializer, $properties);
        }

        $propertyScopes = Hydrator::$propertyScopes[$class] ??= Hydrator::getPropertyScopes($class);
        foreach ($state->initializer as $key => $initializer) {
            if (!\array_key_exists($key, $properties) && isset($propertyScopes[$key])) {
                return false;
            }
        }

        return true;
 <\s>
"
"<s>[INST] initialize lazy object [/INST]         if (!$state = $this->lazyObjectState ?? null) {
            return $this;
        }

        if (!\is_array($state->initializer)) {
            if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {
                $state->initialize($this, '', null);
            }

            return $this;
        }

        $values = isset($state->initializer[""\0""]) ? null : [];

        $class = $this::class;
        $properties = (array) $this;
        $propertyScopes = Hydrator::$propertyScopes[$class] ??= Hydrator::getPropertyScopes($class);
        foreach ($state->initializer as $key => $initializer) {
            if (\array_key_exists($key, $properties) || ![$scope, $name, $readonlyScope] = $propertyScopes[$key] ?? null) {
                continue;
            }
            $scope = $readonlyScope ?? ('*' !== $scope ? $scope : $class);

            if (null === $values) {
                if (!\is_array($values = ($state->initializer[""\0""])($this, Registry::$defaultProperties[$class]))) {
                    throw new \TypeError(sprintf('The lazy-initializer defined for instance of ""%s"" must return an array, got ""%s"".', $class, get_debug_type($values)));
                }

                if (\array_key_exists($key, $properties = (array) $this)) {
                    continue;
                }
            }

            if (\array_key_exists($key, $values)) {
                $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);
                $accessor['set']($this, $name, $properties[$key] = $values[$key]);
            } else {
                $state->initialize($this, $name, $scope);
                $properties = (array) $this;
            }
        }

        return $this;
 <\s>
"
"<s>[INST] reset lazy object [/INST]         if (!$state = $this->lazyObjectState ?? null) {
            return false;
        }

        if (LazyObjectState::STATUS_UNINITIALIZED_FULL !== $state->status) {
            $state->reset($this);
        }

        return true;
 <\s>
"
"<s>[INST] __get [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name);
            $state = $this->lazyObjectState ?? null;

            if ($state && (null === $scope || isset($propertyScopes[""\0$scope\0$name""]))
                && LazyObjectState::STATUS_UNINITIALIZED_PARTIAL !== $state->initialize($this, $name, $readonlyScope ?? $scope)
            ) {
                goto get_in_scope;
            }
        }

        if ($parent = (Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['get']) {
            if (2 === $parent) {
                return parent::__get($name);
            }
            $value = parent::__get($name);

            return $value;
        }

        if (null === $class) {
            $frame = debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
            trigger_error(sprintf('Undefined property: %s::$%s in %s on line %s', $this::class, $name, $frame['file'], $frame['line']), \E_USER_NOTICE);
        }

        get_in_scope:

        try {
            if (null === $scope) {
                if (null === $readonlyScope) {
                    return $this->$name;
                }
                $value = $this->$name;

                return $value;
            }
            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);

            return $accessor['get']($this, $name, null !== $readonlyScope);
        } catch (\Error $e) {
            if (\Error::class !== $e::class || !str_starts_with($e->getMessage(), 'Cannot access uninitialized non-nullable property')) {
                throw $e;
            }

            try {
                if (null === $scope) {
                    $this->$name = [];

                    return $this->$name;
                }

                $accessor['set']($this, $name, []);

                return $accessor['get']($this, $name, null !== $readonlyScope);
            } catch (\Error) {
                throw $e;
            }
        }
 <\s>
"
"<s>[INST] __set [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name, $readonlyScope);
            $state = $this->lazyObjectState ?? null;

            if ($state && ($readonlyScope === $scope || isset($propertyScopes[""\0$scope\0$name""]))) {
                if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {
                    $state->initialize($this, $name, $readonlyScope ?? $scope);
                }
                goto set_in_scope;
            }
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['set']) {
            parent::__set($name, $value);

            return;
        }

        set_in_scope:

        if (null === $scope) {
            $this->$name = $value;
        } else {
            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);
            $accessor['set']($this, $name, $value);
        }
 <\s>
"
"<s>[INST] __isset [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name);
            $state = $this->lazyObjectState ?? null;

            if ($state && (null === $scope || isset($propertyScopes[""\0$scope\0$name""]))
                && LazyObjectState::STATUS_UNINITIALIZED_PARTIAL !== $state->initialize($this, $name, $readonlyScope ?? $scope)
            ) {
                goto isset_in_scope;
            }
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['isset']) {
            return parent::__isset($name);
        }

        isset_in_scope:

        if (null === $scope) {
            return isset($this->$name);
        }
        $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);

        return $accessor['isset']($this, $name);
 <\s>
"
"<s>[INST] __unset [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name, $readonlyScope);
            $state = $this->lazyObjectState ?? null;

            if ($state && ($readonlyScope === $scope || isset($propertyScopes[""\0$scope\0$name""]))) {
                if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {
                    $state->initialize($this, $name, $readonlyScope ?? $scope);
                }
                goto unset_in_scope;
            }
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['unset']) {
            parent::__unset($name);

            return;
        }

        unset_in_scope:

        if (null === $scope) {
            unset($this->$name);
        } else {
            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);
            $accessor['unset']($this, $name);
        }
 <\s>
"
"<s>[INST] __clone [/INST]         if ($state = $this->lazyObjectState ?? null) {
            $this->lazyObjectState = clone $state;
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['clone']) {
            parent::__clone();
        }
 <\s>
"
"<s>[INST] __serialize [/INST]         $class = self::class;

        if ((Registry::$parentMethods[$class] ??= Registry::getParentMethods($class))['serialize']) {
            $properties = parent::__serialize();
        } else {
            $this->initializeLazyObject();
            $properties = (array) $this;
        }
        unset($properties[""\0$class\0lazyObjectState""]);

        if (Registry::$parentMethods[$class]['serialize'] || !Registry::$parentMethods[$class]['sleep']) {
            return $properties;
        }

        $scope = get_parent_class($class);
        $data = [];

        foreach (parent::__sleep() as $name) {
            $value = $properties[$k = $name] ?? $properties[$k = ""\0*\0$name""] ?? $properties[$k = ""\0$scope\0$name""] ?? $k = null;

            if (null === $k) {
                trigger_error(sprintf('serialize(): ""%s"" returned as member variable from __sleep() but does not exist', $name), \E_USER_NOTICE);
            } else {
                $data[$k] = $value;
            }
        }

        return $data;
 <\s>
"
"<s>[INST] __destruct [/INST]         $state = $this->lazyObjectState ?? null;

        if ($state && \in_array($state->status, [LazyObjectState::STATUS_UNINITIALIZED_FULL, LazyObjectState::STATUS_UNINITIALIZED_PARTIAL], true)) {
            return;
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['destruct']) {
            parent::__destruct();
        }
 <\s>
"
"<s>[INST] __construct [/INST]         parent::__construct($registry, Tle::class);
 <\s>
"
"<s>[INST] fetch all indexed [/INST]         return $this->createQueryBuilder('tle', 'tle.id')
            ->getQuery()
            ->getResult();
 <\s>
"
"<s>[INST] collection [/INST]         string $sort,
        string $sortDir,
        array $filters,
    ): QueryBuilder {
        $builder = $this->createQueryBuilder('tle');

        $builder->select('tle');
        $builder->leftJoin(TleInformation::class, 'info', Expr\Join::WITH, 'info.tle = tle.id');

        $builder = $this->search($builder, ['tle.id', 'tle.name'], $search);

        // filters
        foreach ($filters as $index => $filter) {
            if (Filter::FILTER_TYPE_ARRAY === $filter->type) {
                $paramName = \sprintf('param_%d', $index);

                $builder
                    ->andWhere(\sprintf('%s IN (:%s)', $this->getSortTableColumnMapping($filter->filter), $paramName))
                    ->setParameter($paramName, $filter->value);

                continue;
            }

            $placeholder = \sprintf('filter_%s_%d', $filter->filter, $index);
            $builder->andWhere(\sprintf('info.%s %s :%s', $filter->filter, $filter->sqlOperator, $placeholder));
            $builder->setParameter($placeholder, $filter->value);
        }

        // sort
        if (TleCollectionSortableFieldsEnum::POPULARITY === $sort) {
            $before = (new \DateTime())->sub(new \DateInterval('P7D'));
            $builder->leftJoin(Request::class, 's', Expr\Join::WITH, 's.tle = tle.id AND s.createdAt < :date');
            $builder->setParameter('date', $before);
            $builder->groupBy('tle.id');
            $builder->addOrderBy('COUNT(s.id)', $sortDir);
        } else {
            $builder->addOrderBy($this->getSortTableColumnMapping($sort), $sortDir);
        }

        return $builder;
 <\s>
"
"<s>[INST] get sort table column mapping [/INST]         return match ($sort) {
            TleCollectionSortableFieldsEnum::ID, TleCollectionSortableFieldsEnum::SATELLITE_ID => 'tle.id',
            TleCollectionSortableFieldsEnum::NAME => 'tle.name',
            TleCollectionSortableFieldsEnum::POPULARITY => null,
            TleCollectionSortableFieldsEnum::INCLINATION => 'info.inclination',
            TleCollectionSortableFieldsEnum::ECCENTRICITY => 'info.eccentricity',
            TleCollectionSortableFieldsEnum::PERIOD => 'info.period',
            TleCollectionSortableFieldsEnum::SEMI_MAJOR_AXIS => 'info.semiMajorAxis',
            TleCollectionSortableFieldsEnum::RAAN => 'info.raan',
        };
 <\s>
"
"<s>[INST] get [/INST]         $builder = $this->_em->createQueryBuilder();
        $identifier = $this->meta->getIdentifier();
        $alias = $this->meta->getAlias();

        $builder->select($alias);
        $builder->from($entity, $alias);

        $builder
            ->where(""$alias.$identifier = :id"")
            ->setParameter('id', $id);

        return $builder->getQuery()->getOneOrNullResult();
 <\s>
"
"<s>[INST] search [/INST]         if ($query === null || empty($query)) {
            return $builder;
        }

        $conditions = array_map(
            static fn($field) => \sprintf('%s LIKE :%s', $field, self::SEARCH_QUERY_PARAM),
            $fields
        );

        $orX = $builder->expr()->orX();
        $orX->addMultiple($conditions);

        $builder->where($orX);

        $builder->setParameter(self::SEARCH_QUERY_PARAM, '%'.$query.'%');

        return $builder;
 <\s>
"
"<s>[INST] create query builder [/INST]         return $this->_em->createQueryBuilder()
            ->select($alias)
            ->from($this->_entityName, $alias, $indexBy);
 <\s>
"
"<s>[INST] create result set mapping builder [/INST]         $rsm = new ResultSetMappingBuilder($this->_em, ResultSetMappingBuilder::COLUMN_RENAMING_INCREMENT);
        $rsm->addRootEntityFromClassMetadata($this->_entityName, $alias);

        return $rsm;
 <\s>
"
"<s>[INST] create named query [/INST]         Deprecation::trigger(
            'doctrine/orm',
            'https://github.com/doctrine/orm/issues/8592',
            'Named Queries are deprecated, here ""%s"" on entity %s. Move the query logic into EntityRepository',
            $queryName,
            $this->_class->name
        );

        return $this->_em->createQuery($this->_class->getNamedQuery($queryName));
 <\s>
"
"<s>[INST] create native named query [/INST]         Deprecation::trigger(
            'doctrine/orm',
            'https://github.com/doctrine/orm/issues/8592',
            'Named Native Queries are deprecated, here ""%s"" on entity %s. Move the query logic into EntityRepository',
            $queryName,
            $this->_class->name
        );

        $queryMapping = $this->_class->getNamedNativeQuery($queryName);
        $rsm          = new Query\ResultSetMappingBuilder($this->_em);
        $rsm->addNamedNativeQueryMapping($this->_class, $queryMapping);

        return $this->_em->createNativeQuery($queryMapping['query'], $rsm);
 <\s>
"
"<s>[INST] clear [/INST]         Deprecation::trigger(
            'doctrine/orm',
            'https://github.com/doctrine/orm/issues/8460',
            'Calling %s() is deprecated and will not be supported in Doctrine ORM 3.0.',
            __METHOD__
        );

        if (! class_exists(PersistentObject::class)) {
            throw NotSupported::createForPersistence3(sprintf(
                'Partial clearing of entities for class %s',
                $this->_class->rootEntityName
            ));
        }

        $this->_em->clear($this->_class->rootEntityName);
 <\s>
"
"<s>[INST] find [/INST]         return $this->_em->find($this->_entityName, $id, $lockMode, $lockVersion);
 <\s>
"
"<s>[INST] find all [/INST]         return $this->findBy([]);
 <\s>
"
"<s>[INST] find by [/INST]         $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName);

        return $persister->loadAll($criteria, $orderBy, $limit, $offset);
 <\s>
"
"<s>[INST] find one by [/INST]         $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName);

        return $persister->load($criteria, null, null, [], null, 1, $orderBy);
 <\s>
"
"<s>[INST] count [/INST]         return $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName)->count($criteria);
 <\s>
"
"<s>[INST] __call [/INST]         if (str_starts_with($method, 'findBy')) {
            return $this->resolveMagicCall('findBy', substr($method, 6), $arguments);
        }

        if (str_starts_with($method, 'findOneBy')) {
            return $this->resolveMagicCall('findOneBy', substr($method, 9), $arguments);
        }

        if (str_starts_with($method, 'countBy')) {
            return $this->resolveMagicCall('count', substr($method, 7), $arguments);
        }

        throw new BadMethodCallException(sprintf(
            'Undefined method ""%s"". The method name must start with ' .
            'either findBy, findOneBy or countBy!',
            $method
        ));
 <\s>
"
"<s>[INST] get entity name [/INST]         return $this->_entityName;
 <\s>
"
"<s>[INST] get class name [/INST]         return $this->getEntityName();
 <\s>
"
"<s>[INST] get entity manager [/INST]         return $this->_em;
 <\s>
"
"<s>[INST] get class metadata [/INST]         return $this->_class;
 <\s>
"
"<s>[INST] matching [/INST]         $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName);

        return new LazyCriteriaCollection($persister, $criteria);
 <\s>
"
"<s>[INST] is lazy object initialized [/INST]         if (!$state = $this->lazyObjectState ?? null) {
            return true;
        }

        if (!\is_array($state->initializer)) {
            return LazyObjectState::STATUS_INITIALIZED_FULL === $state->status;
        }

        $class = $this::class;
        $properties = (array) $this;

        if ($partial) {
            return (bool) array_intersect_key($state->initializer, $properties);
        }

        $propertyScopes = Hydrator::$propertyScopes[$class] ??= Hydrator::getPropertyScopes($class);
        foreach ($state->initializer as $key => $initializer) {
            if (!\array_key_exists($key, $properties) && isset($propertyScopes[$key])) {
                return false;
            }
        }

        return true;
 <\s>
"
"<s>[INST] initialize lazy object [/INST]         if (!$state = $this->lazyObjectState ?? null) {
            return $this;
        }

        if (!\is_array($state->initializer)) {
            if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {
                $state->initialize($this, '', null);
            }

            return $this;
        }

        $values = isset($state->initializer[""\0""]) ? null : [];

        $class = $this::class;
        $properties = (array) $this;
        $propertyScopes = Hydrator::$propertyScopes[$class] ??= Hydrator::getPropertyScopes($class);
        foreach ($state->initializer as $key => $initializer) {
            if (\array_key_exists($key, $properties) || ![$scope, $name, $readonlyScope] = $propertyScopes[$key] ?? null) {
                continue;
            }
            $scope = $readonlyScope ?? ('*' !== $scope ? $scope : $class);

            if (null === $values) {
                if (!\is_array($values = ($state->initializer[""\0""])($this, Registry::$defaultProperties[$class]))) {
                    throw new \TypeError(sprintf('The lazy-initializer defined for instance of ""%s"" must return an array, got ""%s"".', $class, get_debug_type($values)));
                }

                if (\array_key_exists($key, $properties = (array) $this)) {
                    continue;
                }
            }

            if (\array_key_exists($key, $values)) {
                $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);
                $accessor['set']($this, $name, $properties[$key] = $values[$key]);
            } else {
                $state->initialize($this, $name, $scope);
                $properties = (array) $this;
            }
        }

        return $this;
 <\s>
"
"<s>[INST] reset lazy object [/INST]         if (!$state = $this->lazyObjectState ?? null) {
            return false;
        }

        if (LazyObjectState::STATUS_UNINITIALIZED_FULL !== $state->status) {
            $state->reset($this);
        }

        return true;
 <\s>
"
"<s>[INST] __get [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name);
            $state = $this->lazyObjectState ?? null;

            if ($state && (null === $scope || isset($propertyScopes[""\0$scope\0$name""]))
                && LazyObjectState::STATUS_UNINITIALIZED_PARTIAL !== $state->initialize($this, $name, $readonlyScope ?? $scope)
            ) {
                goto get_in_scope;
            }
        }

        if ($parent = (Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['get']) {
            if (2 === $parent) {
                return parent::__get($name);
            }
            $value = parent::__get($name);

            return $value;
        }

        if (null === $class) {
            $frame = debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
            trigger_error(sprintf('Undefined property: %s::$%s in %s on line %s', $this::class, $name, $frame['file'], $frame['line']), \E_USER_NOTICE);
        }

        get_in_scope:

        try {
            if (null === $scope) {
                if (null === $readonlyScope) {
                    return $this->$name;
                }
                $value = $this->$name;

                return $value;
            }
            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);

            return $accessor['get']($this, $name, null !== $readonlyScope);
        } catch (\Error $e) {
            if (\Error::class !== $e::class || !str_starts_with($e->getMessage(), 'Cannot access uninitialized non-nullable property')) {
                throw $e;
            }

            try {
                if (null === $scope) {
                    $this->$name = [];

                    return $this->$name;
                }

                $accessor['set']($this, $name, []);

                return $accessor['get']($this, $name, null !== $readonlyScope);
            } catch (\Error) {
                throw $e;
            }
        }
 <\s>
"
"<s>[INST] __set [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name, $readonlyScope);
            $state = $this->lazyObjectState ?? null;

            if ($state && ($readonlyScope === $scope || isset($propertyScopes[""\0$scope\0$name""]))) {
                if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {
                    $state->initialize($this, $name, $readonlyScope ?? $scope);
                }
                goto set_in_scope;
            }
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['set']) {
            parent::__set($name, $value);

            return;
        }

        set_in_scope:

        if (null === $scope) {
            $this->$name = $value;
        } else {
            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);
            $accessor['set']($this, $name, $value);
        }
 <\s>
"
"<s>[INST] __isset [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name);
            $state = $this->lazyObjectState ?? null;

            if ($state && (null === $scope || isset($propertyScopes[""\0$scope\0$name""]))
                && LazyObjectState::STATUS_UNINITIALIZED_PARTIAL !== $state->initialize($this, $name, $readonlyScope ?? $scope)
            ) {
                goto isset_in_scope;
            }
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['isset']) {
            return parent::__isset($name);
        }

        isset_in_scope:

        if (null === $scope) {
            return isset($this->$name);
        }
        $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);

        return $accessor['isset']($this, $name);
 <\s>
"
"<s>[INST] __unset [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name, $readonlyScope);
            $state = $this->lazyObjectState ?? null;

            if ($state && ($readonlyScope === $scope || isset($propertyScopes[""\0$scope\0$name""]))) {
                if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {
                    $state->initialize($this, $name, $readonlyScope ?? $scope);
                }
                goto unset_in_scope;
            }
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['unset']) {
            parent::__unset($name);

            return;
        }

        unset_in_scope:

        if (null === $scope) {
            unset($this->$name);
        } else {
            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);
            $accessor['unset']($this, $name);
        }
 <\s>
"
"<s>[INST] __clone [/INST]         if ($state = $this->lazyObjectState ?? null) {
            $this->lazyObjectState = clone $state;
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['clone']) {
            parent::__clone();
        }
 <\s>
"
"<s>[INST] __serialize [/INST]         $class = self::class;

        if ((Registry::$parentMethods[$class] ??= Registry::getParentMethods($class))['serialize']) {
            $properties = parent::__serialize();
        } else {
            $this->initializeLazyObject();
            $properties = (array) $this;
        }
        unset($properties[""\0$class\0lazyObjectState""]);

        if (Registry::$parentMethods[$class]['serialize'] || !Registry::$parentMethods[$class]['sleep']) {
            return $properties;
        }

        $scope = get_parent_class($class);
        $data = [];

        foreach (parent::__sleep() as $name) {
            $value = $properties[$k = $name] ?? $properties[$k = ""\0*\0$name""] ?? $properties[$k = ""\0$scope\0$name""] ?? $k = null;

            if (null === $k) {
                trigger_error(sprintf('serialize(): ""%s"" returned as member variable from __sleep() but does not exist', $name), \E_USER_NOTICE);
            } else {
                $data[$k] = $value;
            }
        }

        return $data;
 <\s>
"
"<s>[INST] __destruct [/INST]         $state = $this->lazyObjectState ?? null;

        if ($state && \in_array($state->status, [LazyObjectState::STATUS_UNINITIALIZED_FULL, LazyObjectState::STATUS_UNINITIALIZED_PARTIAL], true)) {
            return;
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['destruct']) {
            parent::__destruct();
        }
 <\s>
"
"<s>[INST] __construct [/INST]         parent::__construct($registry, TleStat::class);
 <\s>
"
"<s>[INST] update [/INST]         $stat = $this->createQueryBuilder('s')
            ->select('s')
            ->where('s.name = :name')
            ->setParameter('name', $name)
            ->getQuery()
            ->getOneOrNullResult();

        if ($stat === null) {
            $stat = new TleStat($name);
        }

        $stat->setName($name);
        $stat->setTle($tle);

        $this->getEntityManager()->persist($stat);
        $this->getEntityManager()->flush();
 <\s>
"
"<s>[INST] get [/INST]         $stats = $this->findAll();

        foreach ($stats as $stat) {
            yield $stat->getName() => $stat->getTle();
        }
 <\s>
"
"<s>[INST] create query builder [/INST]         return $this->_em->createQueryBuilder()
            ->select($alias)
            ->from($this->_entityName, $alias, $indexBy);
 <\s>
"
"<s>[INST] create result set mapping builder [/INST]         $rsm = new ResultSetMappingBuilder($this->_em, ResultSetMappingBuilder::COLUMN_RENAMING_INCREMENT);
        $rsm->addRootEntityFromClassMetadata($this->_entityName, $alias);

        return $rsm;
 <\s>
"
"<s>[INST] create named query [/INST]         Deprecation::trigger(
            'doctrine/orm',
            'https://github.com/doctrine/orm/issues/8592',
            'Named Queries are deprecated, here ""%s"" on entity %s. Move the query logic into EntityRepository',
            $queryName,
            $this->_class->name
        );

        return $this->_em->createQuery($this->_class->getNamedQuery($queryName));
 <\s>
"
"<s>[INST] create native named query [/INST]         Deprecation::trigger(
            'doctrine/orm',
            'https://github.com/doctrine/orm/issues/8592',
            'Named Native Queries are deprecated, here ""%s"" on entity %s. Move the query logic into EntityRepository',
            $queryName,
            $this->_class->name
        );

        $queryMapping = $this->_class->getNamedNativeQuery($queryName);
        $rsm          = new Query\ResultSetMappingBuilder($this->_em);
        $rsm->addNamedNativeQueryMapping($this->_class, $queryMapping);

        return $this->_em->createNativeQuery($queryMapping['query'], $rsm);
 <\s>
"
"<s>[INST] clear [/INST]         Deprecation::trigger(
            'doctrine/orm',
            'https://github.com/doctrine/orm/issues/8460',
            'Calling %s() is deprecated and will not be supported in Doctrine ORM 3.0.',
            __METHOD__
        );

        if (! class_exists(PersistentObject::class)) {
            throw NotSupported::createForPersistence3(sprintf(
                'Partial clearing of entities for class %s',
                $this->_class->rootEntityName
            ));
        }

        $this->_em->clear($this->_class->rootEntityName);
 <\s>
"
"<s>[INST] find [/INST]         return $this->_em->find($this->_entityName, $id, $lockMode, $lockVersion);
 <\s>
"
"<s>[INST] find all [/INST]         return $this->findBy([]);
 <\s>
"
"<s>[INST] find by [/INST]         $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName);

        return $persister->loadAll($criteria, $orderBy, $limit, $offset);
 <\s>
"
"<s>[INST] find one by [/INST]         $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName);

        return $persister->load($criteria, null, null, [], null, 1, $orderBy);
 <\s>
"
"<s>[INST] count [/INST]         return $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName)->count($criteria);
 <\s>
"
"<s>[INST] __call [/INST]         if (str_starts_with($method, 'findBy')) {
            return $this->resolveMagicCall('findBy', substr($method, 6), $arguments);
        }

        if (str_starts_with($method, 'findOneBy')) {
            return $this->resolveMagicCall('findOneBy', substr($method, 9), $arguments);
        }

        if (str_starts_with($method, 'countBy')) {
            return $this->resolveMagicCall('count', substr($method, 7), $arguments);
        }

        throw new BadMethodCallException(sprintf(
            'Undefined method ""%s"". The method name must start with ' .
            'either findBy, findOneBy or countBy!',
            $method
        ));
 <\s>
"
"<s>[INST] get entity name [/INST]         return $this->_entityName;
 <\s>
"
"<s>[INST] get class name [/INST]         return $this->getEntityName();
 <\s>
"
"<s>[INST] get entity manager [/INST]         return $this->_em;
 <\s>
"
"<s>[INST] get class metadata [/INST]         return $this->_class;
 <\s>
"
"<s>[INST] matching [/INST]         $persister = $this->_em->getUnitOfWork()->getEntityPersister($this->_entityName);

        return new LazyCriteriaCollection($persister, $criteria);
 <\s>
"
"<s>[INST] is lazy object initialized [/INST]         if (!$state = $this->lazyObjectState ?? null) {
            return true;
        }

        if (!\is_array($state->initializer)) {
            return LazyObjectState::STATUS_INITIALIZED_FULL === $state->status;
        }

        $class = $this::class;
        $properties = (array) $this;

        if ($partial) {
            return (bool) array_intersect_key($state->initializer, $properties);
        }

        $propertyScopes = Hydrator::$propertyScopes[$class] ??= Hydrator::getPropertyScopes($class);
        foreach ($state->initializer as $key => $initializer) {
            if (!\array_key_exists($key, $properties) && isset($propertyScopes[$key])) {
                return false;
            }
        }

        return true;
 <\s>
"
"<s>[INST] initialize lazy object [/INST]         if (!$state = $this->lazyObjectState ?? null) {
            return $this;
        }

        if (!\is_array($state->initializer)) {
            if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {
                $state->initialize($this, '', null);
            }

            return $this;
        }

        $values = isset($state->initializer[""\0""]) ? null : [];

        $class = $this::class;
        $properties = (array) $this;
        $propertyScopes = Hydrator::$propertyScopes[$class] ??= Hydrator::getPropertyScopes($class);
        foreach ($state->initializer as $key => $initializer) {
            if (\array_key_exists($key, $properties) || ![$scope, $name, $readonlyScope] = $propertyScopes[$key] ?? null) {
                continue;
            }
            $scope = $readonlyScope ?? ('*' !== $scope ? $scope : $class);

            if (null === $values) {
                if (!\is_array($values = ($state->initializer[""\0""])($this, Registry::$defaultProperties[$class]))) {
                    throw new \TypeError(sprintf('The lazy-initializer defined for instance of ""%s"" must return an array, got ""%s"".', $class, get_debug_type($values)));
                }

                if (\array_key_exists($key, $properties = (array) $this)) {
                    continue;
                }
            }

            if (\array_key_exists($key, $values)) {
                $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);
                $accessor['set']($this, $name, $properties[$key] = $values[$key]);
            } else {
                $state->initialize($this, $name, $scope);
                $properties = (array) $this;
            }
        }

        return $this;
 <\s>
"
"<s>[INST] reset lazy object [/INST]         if (!$state = $this->lazyObjectState ?? null) {
            return false;
        }

        if (LazyObjectState::STATUS_UNINITIALIZED_FULL !== $state->status) {
            $state->reset($this);
        }

        return true;
 <\s>
"
"<s>[INST] __get [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name);
            $state = $this->lazyObjectState ?? null;

            if ($state && (null === $scope || isset($propertyScopes[""\0$scope\0$name""]))
                && LazyObjectState::STATUS_UNINITIALIZED_PARTIAL !== $state->initialize($this, $name, $readonlyScope ?? $scope)
            ) {
                goto get_in_scope;
            }
        }

        if ($parent = (Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['get']) {
            if (2 === $parent) {
                return parent::__get($name);
            }
            $value = parent::__get($name);

            return $value;
        }

        if (null === $class) {
            $frame = debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS, 1)[0];
            trigger_error(sprintf('Undefined property: %s::$%s in %s on line %s', $this::class, $name, $frame['file'], $frame['line']), \E_USER_NOTICE);
        }

        get_in_scope:

        try {
            if (null === $scope) {
                if (null === $readonlyScope) {
                    return $this->$name;
                }
                $value = $this->$name;

                return $value;
            }
            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);

            return $accessor['get']($this, $name, null !== $readonlyScope);
        } catch (\Error $e) {
            if (\Error::class !== $e::class || !str_starts_with($e->getMessage(), 'Cannot access uninitialized non-nullable property')) {
                throw $e;
            }

            try {
                if (null === $scope) {
                    $this->$name = [];

                    return $this->$name;
                }

                $accessor['set']($this, $name, []);

                return $accessor['get']($this, $name, null !== $readonlyScope);
            } catch (\Error) {
                throw $e;
            }
        }
 <\s>
"
"<s>[INST] __set [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name, $readonlyScope);
            $state = $this->lazyObjectState ?? null;

            if ($state && ($readonlyScope === $scope || isset($propertyScopes[""\0$scope\0$name""]))) {
                if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {
                    $state->initialize($this, $name, $readonlyScope ?? $scope);
                }
                goto set_in_scope;
            }
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['set']) {
            parent::__set($name, $value);

            return;
        }

        set_in_scope:

        if (null === $scope) {
            $this->$name = $value;
        } else {
            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);
            $accessor['set']($this, $name, $value);
        }
 <\s>
"
"<s>[INST] __isset [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name);
            $state = $this->lazyObjectState ?? null;

            if ($state && (null === $scope || isset($propertyScopes[""\0$scope\0$name""]))
                && LazyObjectState::STATUS_UNINITIALIZED_PARTIAL !== $state->initialize($this, $name, $readonlyScope ?? $scope)
            ) {
                goto isset_in_scope;
            }
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['isset']) {
            return parent::__isset($name);
        }

        isset_in_scope:

        if (null === $scope) {
            return isset($this->$name);
        }
        $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);

        return $accessor['isset']($this, $name);
 <\s>
"
"<s>[INST] __unset [/INST]         $propertyScopes = Hydrator::$propertyScopes[$this::class] ??= Hydrator::getPropertyScopes($this::class);
        $scope = null;

        if ([$class, , $readonlyScope] = $propertyScopes[$name] ?? null) {
            $scope = Registry::getScope($propertyScopes, $class, $name, $readonlyScope);
            $state = $this->lazyObjectState ?? null;

            if ($state && ($readonlyScope === $scope || isset($propertyScopes[""\0$scope\0$name""]))) {
                if (LazyObjectState::STATUS_UNINITIALIZED_FULL === $state->status) {
                    $state->initialize($this, $name, $readonlyScope ?? $scope);
                }
                goto unset_in_scope;
            }
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['unset']) {
            parent::__unset($name);

            return;
        }

        unset_in_scope:

        if (null === $scope) {
            unset($this->$name);
        } else {
            $accessor = Registry::$classAccessors[$scope] ??= Registry::getClassAccessors($scope);
            $accessor['unset']($this, $name);
        }
 <\s>
"
"<s>[INST] __clone [/INST]         if ($state = $this->lazyObjectState ?? null) {
            $this->lazyObjectState = clone $state;
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['clone']) {
            parent::__clone();
        }
 <\s>
"
"<s>[INST] __serialize [/INST]         $class = self::class;

        if ((Registry::$parentMethods[$class] ??= Registry::getParentMethods($class))['serialize']) {
            $properties = parent::__serialize();
        } else {
            $this->initializeLazyObject();
            $properties = (array) $this;
        }
        unset($properties[""\0$class\0lazyObjectState""]);

        if (Registry::$parentMethods[$class]['serialize'] || !Registry::$parentMethods[$class]['sleep']) {
            return $properties;
        }

        $scope = get_parent_class($class);
        $data = [];

        foreach (parent::__sleep() as $name) {
            $value = $properties[$k = $name] ?? $properties[$k = ""\0*\0$name""] ?? $properties[$k = ""\0$scope\0$name""] ?? $k = null;

            if (null === $k) {
                trigger_error(sprintf('serialize(): ""%s"" returned as member variable from __sleep() but does not exist', $name), \E_USER_NOTICE);
            } else {
                $data[$k] = $value;
            }
        }

        return $data;
 <\s>
"
"<s>[INST] __destruct [/INST]         $state = $this->lazyObjectState ?? null;

        if ($state && \in_array($state->status, [LazyObjectState::STATUS_UNINITIALIZED_FULL, LazyObjectState::STATUS_UNINITIALIZED_PARTIAL], true)) {
            return;
        }

        if ((Registry::$parentMethods[self::class] ??= Registry::getParentMethods(self::class))['destruct']) {
            parent::__destruct();
        }
 <\s>
"
"<s>[INST] filter visible [/INST]         return (bool) $this->get('only_visible', true);
 <\s>
"
"<s>[INST] get observer [/INST]         try {
            return new Observer(
                (float) $this->get('latitude', 0),
                (float) $this->get('longitude', 0),
                0,
                $this->getDateTime(),
            );
        } catch (\InvalidArgumentException $exception) {
            throw new BadRequestHttpException($exception->getMessage());
        }
 <\s>
"
"<s>[INST] set repository [/INST]         $this->repository = $repository;
 <\s>
"
"<s>[INST] get id [/INST]         return $this->attributes->get('id');
 <\s>
"
"<s>[INST] validate [/INST]         $violations = $this->validateExtraParam($validator);
        $violations->addAll(parent::validate($validator));

        return $violations;
 <\s>
"
"<s>[INST] get tle [/INST]         /** @var Tle $tle */
        $tle = $this->repository->findOneBy(['id' => $this->getId()]);

        if (null === $tle) {
            throw new NotFoundHttpException(\sprintf('Unable to find record with id %s', $this->getId()));
        }

        return $tle;
 <\s>
"
"<s>[INST] __construct [/INST]         $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);
 <\s>
"
"<s>[INST] initialize [/INST]         $this->request = new InputBag($request);
        $this->query = new InputBag($query);
        $this->attributes = new ParameterBag($attributes);
        $this->cookies = new InputBag($cookies);
        $this->files = new FileBag($files);
        $this->server = new ServerBag($server);
        $this->headers = new HeaderBag($this->server->getHeaders());

        $this->content = $content;
        $this->languages = null;
        $this->charsets = null;
        $this->encodings = null;
        $this->acceptableContentTypes = null;
        $this->pathInfo = null;
        $this->requestUri = null;
        $this->baseUrl = null;
        $this->basePath = null;
        $this->method = null;
        $this->format = null;
 <\s>
"
"<s>[INST] create from globals [/INST]         $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $_SERVER);

        if (str_starts_with($request->headers->get('CONTENT_TYPE', ''), 'application/x-www-form-urlencoded')
            && \in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), ['PUT', 'DELETE', 'PATCH'])
        ) {
            parse_str($request->getContent(), $data);
            $request->request = new InputBag($data);
        }

        return $request;
 <\s>
"
"<s>[INST] create [/INST]         $server = array_replace([
            'SERVER_NAME' => 'localhost',
            'SERVER_PORT' => 80,
            'HTTP_HOST' => 'localhost',
            'HTTP_USER_AGENT' => 'Symfony',
            'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',
            'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',
            'REMOTE_ADDR' => '127.0.0.1',
            'SCRIPT_NAME' => '',
            'SCRIPT_FILENAME' => '',
            'SERVER_PROTOCOL' => 'HTTP/1.1',
            'REQUEST_TIME' => time(),
            'REQUEST_TIME_FLOAT' => microtime(true),
        ], $server);

        $server['PATH_INFO'] = '';
        $server['REQUEST_METHOD'] = strtoupper($method);

        $components = parse_url($uri);
        if (false === $components) {
            trigger_deprecation('symfony/http-foundation', '6.3', 'Calling ""%s()"" with an invalid URI is deprecated.', __METHOD__);
            $components = [];
        }
        if (isset($components['host'])) {
            $server['SERVER_NAME'] = $components['host'];
            $server['HTTP_HOST'] = $components['host'];
        }

        if (isset($components['scheme'])) {
            if ('https' === $components['scheme']) {
                $server['HTTPS'] = 'on';
                $server['SERVER_PORT'] = 443;
            } else {
                unset($server['HTTPS']);
                $server['SERVER_PORT'] = 80;
            }
        }

        if (isset($components['port'])) {
            $server['SERVER_PORT'] = $components['port'];
            $server['HTTP_HOST'] .= ':'.$components['port'];
        }

        if (isset($components['user'])) {
            $server['PHP_AUTH_USER'] = $components['user'];
        }

        if (isset($components['pass'])) {
            $server['PHP_AUTH_PW'] = $components['pass'];
        }

        if (!isset($components['path'])) {
            $components['path'] = '/';
        }

        switch (strtoupper($method)) {
            case 'POST':
            case 'PUT':
            case 'DELETE':
                if (!isset($server['CONTENT_TYPE'])) {
                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';
                }
                // no break
            case 'PATCH':
                $request = $parameters;
                $query = [];
                break;
            default:
                $request = [];
                $query = $parameters;
                break;
        }

        $queryString = '';
        if (isset($components['query'])) {
            parse_str(html_entity_decode($components['query']), $qs);

            if ($query) {
                $query = array_replace($qs, $query);
                $queryString = http_build_query($query, '', '&');
            } else {
                $query = $qs;
                $queryString = $components['query'];
            }
        } elseif ($query) {
            $queryString = http_build_query($query, '', '&');
        }

        $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');
        $server['QUERY_STRING'] = $queryString;

        return self::createRequestFromFactory($query, $request, [], $cookies, $files, $server, $content);
 <\s>
"
"<s>[INST] set factory [/INST]         self::$requestFactory = $callable;
 <\s>
"
"<s>[INST] duplicate [/INST]         $dup = clone $this;
        if (null !== $query) {
            $dup->query = new InputBag($query);
        }
        if (null !== $request) {
            $dup->request = new InputBag($request);
        }
        if (null !== $attributes) {
            $dup->attributes = new ParameterBag($attributes);
        }
        if (null !== $cookies) {
            $dup->cookies = new InputBag($cookies);
        }
        if (null !== $files) {
            $dup->files = new FileBag($files);
        }
        if (null !== $server) {
            $dup->server = new ServerBag($server);
            $dup->headers = new HeaderBag($dup->server->getHeaders());
        }
        $dup->languages = null;
        $dup->charsets = null;
        $dup->encodings = null;
        $dup->acceptableContentTypes = null;
        $dup->pathInfo = null;
        $dup->requestUri = null;
        $dup->baseUrl = null;
        $dup->basePath = null;
        $dup->method = null;
        $dup->format = null;

        if (!$dup->get('_format') && $this->get('_format')) {
            $dup->attributes->set('_format', $this->get('_format'));
        }

        if (!$dup->getRequestFormat(null)) {
            $dup->setRequestFormat($this->getRequestFormat(null));
        }

        return $dup;
 <\s>
"
"<s>[INST] __clone [/INST]         $this->query = clone $this->query;
        $this->request = clone $this->request;
        $this->attributes = clone $this->attributes;
        $this->cookies = clone $this->cookies;
        $this->files = clone $this->files;
        $this->server = clone $this->server;
        $this->headers = clone $this->headers;
 <\s>
"
"<s>[INST] __to string [/INST]         $content = $this->getContent();

        $cookieHeader = '';
        $cookies = [];

        foreach ($this->cookies as $k => $v) {
            $cookies[] = \is_array($v) ? http_build_query([$k => $v], '', '; ', \PHP_QUERY_RFC3986) : ""$k=$v"";
        }

        if ($cookies) {
            $cookieHeader = 'Cookie: '.implode('; ', $cookies).""\r\n"";
        }

        return
            sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).""\r\n"".
            $this->headers.
            $cookieHeader.""\r\n"".
            $content;
 <\s>
"
"<s>[INST] override globals [/INST]         $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));

        $_GET = $this->query->all();
        $_POST = $this->request->all();
        $_SERVER = $this->server->all();
        $_COOKIE = $this->cookies->all();

        foreach ($this->headers->all() as $key => $value) {
            $key = strtoupper(str_replace('-', '_', $key));
            if (\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true)) {
                $_SERVER[$key] = implode(', ', $value);
            } else {
                $_SERVER['HTTP_'.$key] = implode(', ', $value);
            }
        }

        $request = ['g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE];

        $requestOrder = \ini_get('request_order') ?: \ini_get('variables_order');
        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';

        $_REQUEST = [[]];

        foreach (str_split($requestOrder) as $order) {
            $_REQUEST[] = $request[$order];
        }

        $_REQUEST = array_merge(...$_REQUEST);
 <\s>
"
"<s>[INST] set trusted proxies [/INST]         self::$trustedProxies = array_reduce($proxies, function ($proxies, $proxy) {
            if ('REMOTE_ADDR' !== $proxy) {
                $proxies[] = $proxy;
            } elseif (isset($_SERVER['REMOTE_ADDR'])) {
                $proxies[] = $_SERVER['REMOTE_ADDR'];
            }

            return $proxies;
        }, []);
        self::$trustedHeaderSet = $trustedHeaderSet;
 <\s>
"
"<s>[INST] get trusted proxies [/INST]         return self::$trustedProxies;
 <\s>
"
"<s>[INST] get trusted header set [/INST]         return self::$trustedHeaderSet;
 <\s>
"
"<s>[INST] set trusted hosts [/INST]         self::$trustedHostPatterns = array_map(fn ($hostPattern) => sprintf('{%s}i', $hostPattern), $hostPatterns);
        // we need to reset trusted hosts on trusted host patterns change
        self::$trustedHosts = [];
 <\s>
"
"<s>[INST] get trusted hosts [/INST]         return self::$trustedHostPatterns;
 <\s>
"
"<s>[INST] normalize query string [/INST]         if ('' === ($qs ?? '')) {
            return '';
        }

        $qs = HeaderUtils::parseQuery($qs);
        ksort($qs);

        return http_build_query($qs, '', '&', \PHP_QUERY_RFC3986);
 <\s>
"
"<s>[INST] enable http method parameter override [/INST]         self::$httpMethodParameterOverride = true;
 <\s>
"
"<s>[INST] get http method parameter override [/INST]         return self::$httpMethodParameterOverride;
 <\s>
"
"<s>[INST] get [/INST]         if ($this !== $result = $this->attributes->get($key, $this)) {
            return $result;
        }

        if ($this->query->has($key)) {
            return $this->query->all()[$key];
        }

        if ($this->request->has($key)) {
            return $this->request->all()[$key];
        }

        return $default;
 <\s>
"
"<s>[INST] get session [/INST]         $session = $this->session;
        if (!$session instanceof SessionInterface && null !== $session) {
            $this->setSession($session = $session());
        }

        if (null === $session) {
            throw new SessionNotFoundException('Session has not been set.');
        }

        return $session;
 <\s>
"
"<s>[INST] has previous session [/INST]         // the check for $this->session avoids malicious users trying to fake a session cookie with proper name
        return $this->hasSession() && $this->cookies->has($this->getSession()->getName());
 <\s>
"
"<s>[INST] has session [/INST]         return null !== $this->session && (!$skipIfUninitialized || $this->session instanceof SessionInterface);
 <\s>
"
"<s>[INST] set session [/INST]         $this->session = $session;
 <\s>
"
"<s>[INST] set session factory [/INST]         $this->session = $factory;
 <\s>
"
"<s>[INST] get client ips [/INST]         $ip = $this->server->get('REMOTE_ADDR');

        if (!$this->isFromTrustedProxy()) {
            return [$ip];
        }

        return $this->getTrustedValues(self::HEADER_X_FORWARDED_FOR, $ip) ?: [$ip];
 <\s>
"
"<s>[INST] get client ip [/INST]         $ipAddresses = $this->getClientIps();

        return $ipAddresses[0];
 <\s>
"
"<s>[INST] get script name [/INST]         return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));
 <\s>
"
"<s>[INST] get path info [/INST]         return $this->pathInfo ??= $this->preparePathInfo();
 <\s>
"
"<s>[INST] get base path [/INST]         return $this->basePath ??= $this->prepareBasePath();
 <\s>
"
"<s>[INST] get base url [/INST]         $trustedPrefix = '';

        // the proxy prefix must be prepended to any prefix being needed at the webserver level
        if ($this->isFromTrustedProxy() && $trustedPrefixValues = $this->getTrustedValues(self::HEADER_X_FORWARDED_PREFIX)) {
            $trustedPrefix = rtrim($trustedPrefixValues[0], '/');
        }

        return $trustedPrefix.$this->getBaseUrlReal();
 <\s>
"
"<s>[INST] get scheme [/INST]         return $this->isSecure() ? 'https' : 'http';
 <\s>
"
"<s>[INST] get port [/INST]         if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_PORT)) {
            $host = $host[0];
        } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {
            $host = $host[0];
        } elseif (!$host = $this->headers->get('HOST')) {
            return $this->server->get('SERVER_PORT');
        }

        if ('[' === $host[0]) {
            $pos = strpos($host, ':', strrpos($host, ']'));
        } else {
            $pos = strrpos($host, ':');
        }

        if (false !== $pos && $port = substr($host, $pos + 1)) {
            return (int) $port;
        }

        return 'https' === $this->getScheme() ? 443 : 80;
 <\s>
"
"<s>[INST] get user [/INST]         return $this->headers->get('PHP_AUTH_USER');
 <\s>
"
"<s>[INST] get password [/INST]         return $this->headers->get('PHP_AUTH_PW');
 <\s>
"
"<s>[INST] get user info [/INST]         $userinfo = $this->getUser();

        $pass = $this->getPassword();
        if ('' != $pass) {
            $userinfo .= "":$pass"";
        }

        return $userinfo;
 <\s>
"
"<s>[INST] get http host [/INST]         $scheme = $this->getScheme();
        $port = $this->getPort();

        if (('http' === $scheme && 80 == $port) || ('https' === $scheme && 443 == $port)) {
            return $this->getHost();
        }

        return $this->getHost().':'.$port;
 <\s>
"
"<s>[INST] get request uri [/INST]         return $this->requestUri ??= $this->prepareRequestUri();
 <\s>
"
"<s>[INST] get scheme and http host [/INST]         return $this->getScheme().'://'.$this->getHttpHost();
 <\s>
"
"<s>[INST] get uri [/INST]         if (null !== $qs = $this->getQueryString()) {
            $qs = '?'.$qs;
        }

        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;
 <\s>
"
"<s>[INST] get uri for path [/INST]         return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;
 <\s>
"
"<s>[INST] get relative uri for path [/INST]         // be sure that we are dealing with an absolute path
        if (!isset($path[0]) || '/' !== $path[0]) {
            return $path;
        }

        if ($path === $basePath = $this->getPathInfo()) {
            return '';
        }

        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);
        $targetDirs = explode('/', substr($path, 1));
        array_pop($sourceDirs);
        $targetFile = array_pop($targetDirs);

        foreach ($sourceDirs as $i => $dir) {
            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {
                unset($sourceDirs[$i], $targetDirs[$i]);
            } else {
                break;
            }
        }

        $targetDirs[] = $targetFile;
        $path = str_repeat('../', \count($sourceDirs)).implode('/', $targetDirs);

        // A reference to the same base directory or an empty subdirectory must be prefixed with ""./"".
        // This also applies to a segment with a colon character (e.g., ""file:colon"") that cannot be used
        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name
        // (see https://tools.ietf.org/html/rfc3986#section-4.2).
        return !isset($path[0]) || '/' === $path[0]
            || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos)
            ? ""./$path"" : $path;
 <\s>
"
"<s>[INST] get query string [/INST]         $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));

        return '' === $qs ? null : $qs;
 <\s>
"
"<s>[INST] is secure [/INST]         if ($this->isFromTrustedProxy() && $proto = $this->getTrustedValues(self::HEADER_X_FORWARDED_PROTO)) {
            return \in_array(strtolower($proto[0]), ['https', 'on', 'ssl', '1'], true);
        }

        $https = $this->server->get('HTTPS');

        return !empty($https) && 'off' !== strtolower($https);
 <\s>
"
"<s>[INST] get host [/INST]         if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {
            $host = $host[0];
        } elseif (!$host = $this->headers->get('HOST')) {
            if (!$host = $this->server->get('SERVER_NAME')) {
                $host = $this->server->get('SERVER_ADDR', '');
            }
        }

        // trim and remove port number from host
        // host is lowercase as per RFC 952/2181
        $host = strtolower(preg_replace('/:\d+$/', '', trim($host)));

        // as the host can come from the user (HTTP_HOST and depending on the configuration, SERVER_NAME too can come from the user)
        // check that it does not contain forbidden characters (see RFC 952 and RFC 2181)
        // use preg_replace() instead of preg_match() to prevent DoS attacks with long host names
        if ($host && '' !== preg_replace('/(?:^\[)?[a-zA-Z0-9-:\]_]+\.?/', '', $host)) {
            if (!$this->isHostValid) {
                return '';
            }
            $this->isHostValid = false;

            throw new SuspiciousOperationException(sprintf('Invalid Host ""%s"".', $host));
        }

        if (\count(self::$trustedHostPatterns) > 0) {
            // to avoid host header injection attacks, you should provide a list of trusted host patterns

            if (\in_array($host, self::$trustedHosts)) {
                return $host;
            }

            foreach (self::$trustedHostPatterns as $pattern) {
                if (preg_match($pattern, $host)) {
                    self::$trustedHosts[] = $host;

                    return $host;
                }
            }

            if (!$this->isHostValid) {
                return '';
            }
            $this->isHostValid = false;

            throw new SuspiciousOperationException(sprintf('Untrusted Host ""%s"".', $host));
        }

        return $host;
 <\s>
"
"<s>[INST] set method [/INST]         $this->method = null;
        $this->server->set('REQUEST_METHOD', $method);
 <\s>
"
"<s>[INST] get method [/INST]         if (null !== $this->method) {
            return $this->method;
        }

        $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));

        if ('POST' !== $this->method) {
            return $this->method;
        }

        $method = $this->headers->get('X-HTTP-METHOD-OVERRIDE');

        if (!$method && self::$httpMethodParameterOverride) {
            $method = $this->request->get('_method', $this->query->get('_method', 'POST'));
        }

        if (!\is_string($method)) {
            return $this->method;
        }

        $method = strtoupper($method);

        if (\in_array($method, ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'PATCH', 'PURGE', 'TRACE'], true)) {
            return $this->method = $method;
        }

        if (!preg_match('/^[A-Z]++$/D', $method)) {
            throw new SuspiciousOperationException(sprintf('Invalid method override ""%s"".', $method));
        }

        return $this->method = $method;
 <\s>
"
"<s>[INST] get real method [/INST]         return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));
 <\s>
"
"<s>[INST] get mime type [/INST]         if (null === static::$formats) {
            static::initializeFormats();
        }

        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;
 <\s>
"
"<s>[INST] get mime types [/INST]         if (null === static::$formats) {
            static::initializeFormats();
        }

        return static::$formats[$format] ?? [];
 <\s>
"
"<s>[INST] get format [/INST]         $canonicalMimeType = null;
        if ($mimeType && false !== $pos = strpos($mimeType, ';')) {
            $canonicalMimeType = trim(substr($mimeType, 0, $pos));
        }

        if (null === static::$formats) {
            static::initializeFormats();
        }

        foreach (static::$formats as $format => $mimeTypes) {
            if (\in_array($mimeType, (array) $mimeTypes)) {
                return $format;
            }
            if (null !== $canonicalMimeType && \in_array($canonicalMimeType, (array) $mimeTypes)) {
                return $format;
            }
        }

        return null;
 <\s>
"
"<s>[INST] set format [/INST]         if (null === static::$formats) {
            static::initializeFormats();
        }

        static::$formats[$format] = \is_array($mimeTypes) ? $mimeTypes : [$mimeTypes];
 <\s>
"
"<s>[INST] get request format [/INST]         $this->format ??= $this->attributes->get('_format');

        return $this->format ?? $default;
 <\s>
"
"<s>[INST] set request format [/INST]         $this->format = $format;
 <\s>
"
"<s>[INST] get content type [/INST]         trigger_deprecation('symfony/http-foundation', '6.2', 'The ""%s()"" method is deprecated, use ""getContentTypeFormat()"" instead.', __METHOD__);

        return $this->getContentTypeFormat();
 <\s>
"
"<s>[INST] get content type format [/INST]         return $this->getFormat($this->headers->get('CONTENT_TYPE', ''));
 <\s>
"
"<s>[INST] set default locale [/INST]         $this->defaultLocale = $locale;

        if (null === $this->locale) {
            $this->setPhpDefaultLocale($locale);
        }
 <\s>
"
"<s>[INST] get default locale [/INST]         return $this->defaultLocale;
 <\s>
"
"<s>[INST] set locale [/INST]         $this->setPhpDefaultLocale($this->locale = $locale);
 <\s>
"
"<s>[INST] get locale [/INST]         return $this->locale ?? $this->defaultLocale;
 <\s>
"
"<s>[INST] is method [/INST]         return $this->getMethod() === strtoupper($method);
 <\s>
"
"<s>[INST] is method safe [/INST]         return \in_array($this->getMethod(), ['GET', 'HEAD', 'OPTIONS', 'TRACE']);
 <\s>
"
"<s>[INST] is method idempotent [/INST]         return \in_array($this->getMethod(), ['HEAD', 'GET', 'PUT', 'DELETE', 'TRACE', 'OPTIONS', 'PURGE']);
 <\s>
"
"<s>[INST] is method cacheable [/INST]         return \in_array($this->getMethod(), ['GET', 'HEAD']);
 <\s>
"
"<s>[INST] get protocol version [/INST]         if ($this->isFromTrustedProxy()) {
            preg_match('~^(HTTP/)?([1-9]\.[0-9]) ~', $this->headers->get('Via') ?? '', $matches);

            if ($matches) {
                return 'HTTP/'.$matches[2];
            }
        }

        return $this->server->get('SERVER_PROTOCOL');
 <\s>
"
"<s>[INST] get content [/INST]         $currentContentIsResource = \is_resource($this->content);

        if (true === $asResource) {
            if ($currentContentIsResource) {
                rewind($this->content);

                return $this->content;
            }

            // Content passed in parameter (test)
            if (\is_string($this->content)) {
                $resource = fopen('php://temp', 'r+');
                fwrite($resource, $this->content);
                rewind($resource);

                return $resource;
            }

            $this->content = false;

            return fopen('php://input', 'r');
        }

        if ($currentContentIsResource) {
            rewind($this->content);

            return stream_get_contents($this->content);
        }

        if (null === $this->content || false === $this->content) {
            $this->content = file_get_contents('php://input');
        }

        return $this->content;
 <\s>
"
"<s>[INST] get payload [/INST]         return $this->request->count() ? clone $this->request : new InputBag($this->toArray());
 <\s>
"
"<s>[INST] to array [/INST]         if ('' === $content = $this->getContent()) {
            throw new JsonException('Request body is empty.');
        }

        try {
            $content = json_decode($content, true, 512, \JSON_BIGINT_AS_STRING | \JSON_THROW_ON_ERROR);
        } catch (\JsonException $e) {
            throw new JsonException('Could not decode request body.', $e->getCode(), $e);
        }

        if (!\is_array($content)) {
            throw new JsonException(sprintf('JSON content was expected to decode to an array, ""%s"" returned.', get_debug_type($content)));
        }

        return $content;
 <\s>
"
"<s>[INST] get e tags [/INST]         return preg_split('/\s*,\s*/', $this->headers->get('If-None-Match', ''), -1, \PREG_SPLIT_NO_EMPTY);
 <\s>
"
"<s>[INST] is no cache [/INST]         return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');
 <\s>
"
"<s>[INST] get preferred format [/INST]         if (null !== $this->preferredFormat || null !== $this->preferredFormat = $this->getRequestFormat(null)) {
            return $this->preferredFormat;
        }

        foreach ($this->getAcceptableContentTypes() as $mimeType) {
            if ($this->preferredFormat = $this->getFormat($mimeType)) {
                return $this->preferredFormat;
            }
        }

        return $default;
 <\s>
"
"<s>[INST] get preferred language [/INST]         $preferredLanguages = $this->getLanguages();

        if (empty($locales)) {
            return $preferredLanguages[0] ?? null;
        }

        if (!$preferredLanguages) {
            return $locales[0];
        }

        $extendedPreferredLanguages = [];
        foreach ($preferredLanguages as $language) {
            $extendedPreferredLanguages[] = $language;
            if (false !== $position = strpos($language, '_')) {
                $superLanguage = substr($language, 0, $position);
                if (!\in_array($superLanguage, $preferredLanguages)) {
                    $extendedPreferredLanguages[] = $superLanguage;
                }
            }
        }

        $preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));

        return $preferredLanguages[0] ?? $locales[0];
 <\s>
"
"<s>[INST] get languages [/INST]         if (null !== $this->languages) {
            return $this->languages;
        }

        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();
        $this->languages = [];
        foreach ($languages as $acceptHeaderItem) {
            $lang = $acceptHeaderItem->getValue();
            if (str_contains($lang, '-')) {
                $codes = explode('-', $lang);
                if ('i' === $codes[0]) {
                    // Language not listed in ISO 639 that are not variants
                    // of any listed language, which can be registered with the
                    // i-prefix, such as i-cherokee
                    if (\count($codes) > 1) {
                        $lang = $codes[1];
                    }
                } else {
                    for ($i = 0, $max = \count($codes); $i < $max; ++$i) {
                        if (0 === $i) {
                            $lang = strtolower($codes[0]);
                        } else {
                            $lang .= '_'.strtoupper($codes[$i]);
                        }
                    }
                }
            }

            $this->languages[] = $lang;
        }

        return $this->languages;
 <\s>
"
"<s>[INST] get charsets [/INST]         if (null !== $this->charsets) {
            return $this->charsets;
        }

        return $this->charsets = array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all()));
 <\s>
"
"<s>[INST] get encodings [/INST]         if (null !== $this->encodings) {
            return $this->encodings;
        }

        return $this->encodings = array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all()));
 <\s>
"
"<s>[INST] get acceptable content types [/INST]         if (null !== $this->acceptableContentTypes) {
            return $this->acceptableContentTypes;
        }

        return $this->acceptableContentTypes = array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all()));
 <\s>
"
"<s>[INST] is xml http request [/INST]         return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');
 <\s>
"
"<s>[INST] prefer safe content [/INST]         if (isset($this->isSafeContentPreferred)) {
            return $this->isSafeContentPreferred;
        }

        if (!$this->isSecure()) {
            // see https://tools.ietf.org/html/rfc8674#section-3
            return $this->isSafeContentPreferred = false;
        }

        return $this->isSafeContentPreferred = AcceptHeader::fromString($this->headers->get('Prefer'))->has('safe');
 <\s>
"
"<s>[INST] prepare request uri [/INST]         $requestUri = '';

        if ('1' == $this->server->get('IIS_WasUrlRewritten') && '' != $this->server->get('UNENCODED_URL')) {
            // IIS7 with URL Rewrite: make sure we get the unencoded URL (double slash problem)
            $requestUri = $this->server->get('UNENCODED_URL');
            $this->server->remove('UNENCODED_URL');
            $this->server->remove('IIS_WasUrlRewritten');
        } elseif ($this->server->has('REQUEST_URI')) {
            $requestUri = $this->server->get('REQUEST_URI');

            if ('' !== $requestUri && '/' === $requestUri[0]) {
                // To only use path and query remove the fragment.
                if (false !== $pos = strpos($requestUri, '#')) {
                    $requestUri = substr($requestUri, 0, $pos);
                }
            } else {
                // HTTP proxy reqs setup request URI with scheme and host [and port] + the URL path,
                // only use URL path.
                $uriComponents = parse_url($requestUri);

                if (isset($uriComponents['path'])) {
                    $requestUri = $uriComponents['path'];
                }

                if (isset($uriComponents['query'])) {
                    $requestUri .= '?'.$uriComponents['query'];
                }
            }
        } elseif ($this->server->has('ORIG_PATH_INFO')) {
            // IIS 5.0, PHP as CGI
            $requestUri = $this->server->get('ORIG_PATH_INFO');
            if ('' != $this->server->get('QUERY_STRING')) {
                $requestUri .= '?'.$this->server->get('QUERY_STRING');
            }
            $this->server->remove('ORIG_PATH_INFO');
        }

        // normalize the request URI to ease creating sub-requests from this request
        $this->server->set('REQUEST_URI', $requestUri);

        return $requestUri;
 <\s>
"
"<s>[INST] prepare base url [/INST]         $filename = basename($this->server->get('SCRIPT_FILENAME', ''));

        if (basename($this->server->get('SCRIPT_NAME', '')) === $filename) {
            $baseUrl = $this->server->get('SCRIPT_NAME');
        } elseif (basename($this->server->get('PHP_SELF', '')) === $filename) {
            $baseUrl = $this->server->get('PHP_SELF');
        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME', '')) === $filename) {
            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); // 1and1 shared hosting compatibility
        } else {
            // Backtrack up the script_filename to find the portion matching
            // php_self
            $path = $this->server->get('PHP_SELF', '');
            $file = $this->server->get('SCRIPT_FILENAME', '');
            $segs = explode('/', trim($file, '/'));
            $segs = array_reverse($segs);
            $index = 0;
            $last = \count($segs);
            $baseUrl = '';
            do {
                $seg = $segs[$index];
                $baseUrl = '/'.$seg.$baseUrl;
                ++$index;
            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);
        }

        // Does the baseUrl have anything in common with the request_uri?
        $requestUri = $this->getRequestUri();
        if ('' !== $requestUri && '/' !== $requestUri[0]) {
            $requestUri = '/'.$requestUri;
        }

        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {
            // full $baseUrl matches
            return $prefix;
        }

        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, rtrim(\dirname($baseUrl), '/'.\DIRECTORY_SEPARATOR).'/')) {
            // directory portion of $baseUrl matches
            return rtrim($prefix, '/'.\DIRECTORY_SEPARATOR);
        }

        $truncatedRequestUri = $requestUri;
        if (false !== $pos = strpos($requestUri, '?')) {
            $truncatedRequestUri = substr($requestUri, 0, $pos);
        }

        $basename = basename($baseUrl ?? '');
        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {
            // no match whatsoever; set it blank
            return '';
        }

        // If using mod_rewrite or ISAPI_Rewrite strip the script filename
        // out of baseUrl. $pos !== 0 makes sure it is not matching a value
        // from PATH_INFO or QUERY_STRING
        if (\strlen($requestUri) >= \strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && 0 !== $pos) {
            $baseUrl = substr($requestUri, 0, $pos + \strlen($baseUrl));
        }

        return rtrim($baseUrl, '/'.\DIRECTORY_SEPARATOR);
 <\s>
"
"<s>[INST] prepare base path [/INST]         $baseUrl = $this->getBaseUrl();
        if (empty($baseUrl)) {
            return '';
        }

        $filename = basename($this->server->get('SCRIPT_FILENAME'));
        if (basename($baseUrl) === $filename) {
            $basePath = \dirname($baseUrl);
        } else {
            $basePath = $baseUrl;
        }

        if ('\\' === \DIRECTORY_SEPARATOR) {
            $basePath = str_replace('\\', '/', $basePath);
        }

        return rtrim($basePath, '/');
 <\s>
"
"<s>[INST] prepare path info [/INST]         if (null === ($requestUri = $this->getRequestUri())) {
            return '/';
        }

        // Remove the query string from REQUEST_URI
        if (false !== $pos = strpos($requestUri, '?')) {
            $requestUri = substr($requestUri, 0, $pos);
        }
        if ('' !== $requestUri && '/' !== $requestUri[0]) {
            $requestUri = '/'.$requestUri;
        }

        if (null === ($baseUrl = $this->getBaseUrlReal())) {
            return $requestUri;
        }

        $pathInfo = substr($requestUri, \strlen($baseUrl));
        if (false === $pathInfo || '' === $pathInfo) {
            // If substr() returns false then PATH_INFO is set to an empty string
            return '/';
        }

        return $pathInfo;
 <\s>
"
"<s>[INST] initialize formats [/INST]         static::$formats = [
            'html' => ['text/html', 'application/xhtml+xml'],
            'txt' => ['text/plain'],
            'js' => ['application/javascript', 'application/x-javascript', 'text/javascript'],
            'css' => ['text/css'],
            'json' => ['application/json', 'application/x-json'],
            'jsonld' => ['application/ld+json'],
            'xml' => ['text/xml', 'application/xml', 'application/x-xml'],
            'rdf' => ['application/rdf+xml'],
            'atom' => ['application/atom+xml'],
            'rss' => ['application/rss+xml'],
            'form' => ['application/x-www-form-urlencoded', 'multipart/form-data'],
        ];
 <\s>
"
"<s>[INST] is from trusted proxy [/INST]         return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR', ''), self::$trustedProxies);
 <\s>
"
"<s>[INST] get extra [/INST]         return (bool) $this->get(TleRequest::EXTRA_PARAM, false);
 <\s>
"
"<s>[INST] validate extra param [/INST]         return $validator->validate(
            $this->query->all(),
            new Assert\Collection(
                [
                    'allowExtraFields' => true,
                    'allowMissingFields' => true,
                    'fields' => [
                        TleRequest::EXTRA_PARAM => new Assert\Optional(new Assert\Choice(Filter::BOOLEAN_VALUES)),
                    ],
                ]
            )
        );
 <\s>
"
"<s>[INST] get date time [/INST]         $date = $this->get($name, DateTimeService::getCurrentUTC()->format(\DateTimeInterface::ATOM));

        return \DateTime::createFromFormat(\DateTimeInterface::ATOM, str_replace(' ', '+', $date));
 <\s>
"
"<s>[INST] set repository [/INST]         $this->repository = $repository;
 <\s>
"
"<s>[INST] get id [/INST]         return $this->attributes->get('id');
 <\s>
"
"<s>[INST] validate [/INST]         $violations = $this->validateExtraParam($validator);
        $violations->addAll(parent::validate($validator));

        return $violations;
 <\s>
"
"<s>[INST] get tle [/INST]         /** @var Tle $tle */
        $tle = $this->repository->findOneBy(['id' => $this->getId()]);

        if (null === $tle) {
            throw new NotFoundHttpException(\sprintf('Unable to find record with id %s', $this->getId()));
        }

        return $tle;
 <\s>
"
"<s>[INST] __construct [/INST]         $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);
 <\s>
"
"<s>[INST] initialize [/INST]         $this->request = new InputBag($request);
        $this->query = new InputBag($query);
        $this->attributes = new ParameterBag($attributes);
        $this->cookies = new InputBag($cookies);
        $this->files = new FileBag($files);
        $this->server = new ServerBag($server);
        $this->headers = new HeaderBag($this->server->getHeaders());

        $this->content = $content;
        $this->languages = null;
        $this->charsets = null;
        $this->encodings = null;
        $this->acceptableContentTypes = null;
        $this->pathInfo = null;
        $this->requestUri = null;
        $this->baseUrl = null;
        $this->basePath = null;
        $this->method = null;
        $this->format = null;
 <\s>
"
"<s>[INST] create from globals [/INST]         $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $_SERVER);

        if (str_starts_with($request->headers->get('CONTENT_TYPE', ''), 'application/x-www-form-urlencoded')
            && \in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), ['PUT', 'DELETE', 'PATCH'])
        ) {
            parse_str($request->getContent(), $data);
            $request->request = new InputBag($data);
        }

        return $request;
 <\s>
"
"<s>[INST] create [/INST]         $server = array_replace([
            'SERVER_NAME' => 'localhost',
            'SERVER_PORT' => 80,
            'HTTP_HOST' => 'localhost',
            'HTTP_USER_AGENT' => 'Symfony',
            'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',
            'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',
            'REMOTE_ADDR' => '127.0.0.1',
            'SCRIPT_NAME' => '',
            'SCRIPT_FILENAME' => '',
            'SERVER_PROTOCOL' => 'HTTP/1.1',
            'REQUEST_TIME' => time(),
            'REQUEST_TIME_FLOAT' => microtime(true),
        ], $server);

        $server['PATH_INFO'] = '';
        $server['REQUEST_METHOD'] = strtoupper($method);

        $components = parse_url($uri);
        if (false === $components) {
            trigger_deprecation('symfony/http-foundation', '6.3', 'Calling ""%s()"" with an invalid URI is deprecated.', __METHOD__);
            $components = [];
        }
        if (isset($components['host'])) {
            $server['SERVER_NAME'] = $components['host'];
            $server['HTTP_HOST'] = $components['host'];
        }

        if (isset($components['scheme'])) {
            if ('https' === $components['scheme']) {
                $server['HTTPS'] = 'on';
                $server['SERVER_PORT'] = 443;
            } else {
                unset($server['HTTPS']);
                $server['SERVER_PORT'] = 80;
            }
        }

        if (isset($components['port'])) {
            $server['SERVER_PORT'] = $components['port'];
            $server['HTTP_HOST'] .= ':'.$components['port'];
        }

        if (isset($components['user'])) {
            $server['PHP_AUTH_USER'] = $components['user'];
        }

        if (isset($components['pass'])) {
            $server['PHP_AUTH_PW'] = $components['pass'];
        }

        if (!isset($components['path'])) {
            $components['path'] = '/';
        }

        switch (strtoupper($method)) {
            case 'POST':
            case 'PUT':
            case 'DELETE':
                if (!isset($server['CONTENT_TYPE'])) {
                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';
                }
                // no break
            case 'PATCH':
                $request = $parameters;
                $query = [];
                break;
            default:
                $request = [];
                $query = $parameters;
                break;
        }

        $queryString = '';
        if (isset($components['query'])) {
            parse_str(html_entity_decode($components['query']), $qs);

            if ($query) {
                $query = array_replace($qs, $query);
                $queryString = http_build_query($query, '', '&');
            } else {
                $query = $qs;
                $queryString = $components['query'];
            }
        } elseif ($query) {
            $queryString = http_build_query($query, '', '&');
        }

        $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');
        $server['QUERY_STRING'] = $queryString;

        return self::createRequestFromFactory($query, $request, [], $cookies, $files, $server, $content);
 <\s>
"
"<s>[INST] set factory [/INST]         self::$requestFactory = $callable;
 <\s>
"
"<s>[INST] duplicate [/INST]         $dup = clone $this;
        if (null !== $query) {
            $dup->query = new InputBag($query);
        }
        if (null !== $request) {
            $dup->request = new InputBag($request);
        }
        if (null !== $attributes) {
            $dup->attributes = new ParameterBag($attributes);
        }
        if (null !== $cookies) {
            $dup->cookies = new InputBag($cookies);
        }
        if (null !== $files) {
            $dup->files = new FileBag($files);
        }
        if (null !== $server) {
            $dup->server = new ServerBag($server);
            $dup->headers = new HeaderBag($dup->server->getHeaders());
        }
        $dup->languages = null;
        $dup->charsets = null;
        $dup->encodings = null;
        $dup->acceptableContentTypes = null;
        $dup->pathInfo = null;
        $dup->requestUri = null;
        $dup->baseUrl = null;
        $dup->basePath = null;
        $dup->method = null;
        $dup->format = null;

        if (!$dup->get('_format') && $this->get('_format')) {
            $dup->attributes->set('_format', $this->get('_format'));
        }

        if (!$dup->getRequestFormat(null)) {
            $dup->setRequestFormat($this->getRequestFormat(null));
        }

        return $dup;
 <\s>
"
"<s>[INST] __clone [/INST]         $this->query = clone $this->query;
        $this->request = clone $this->request;
        $this->attributes = clone $this->attributes;
        $this->cookies = clone $this->cookies;
        $this->files = clone $this->files;
        $this->server = clone $this->server;
        $this->headers = clone $this->headers;
 <\s>
"
"<s>[INST] __to string [/INST]         $content = $this->getContent();

        $cookieHeader = '';
        $cookies = [];

        foreach ($this->cookies as $k => $v) {
            $cookies[] = \is_array($v) ? http_build_query([$k => $v], '', '; ', \PHP_QUERY_RFC3986) : ""$k=$v"";
        }

        if ($cookies) {
            $cookieHeader = 'Cookie: '.implode('; ', $cookies).""\r\n"";
        }

        return
            sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).""\r\n"".
            $this->headers.
            $cookieHeader.""\r\n"".
            $content;
 <\s>
"
"<s>[INST] override globals [/INST]         $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));

        $_GET = $this->query->all();
        $_POST = $this->request->all();
        $_SERVER = $this->server->all();
        $_COOKIE = $this->cookies->all();

        foreach ($this->headers->all() as $key => $value) {
            $key = strtoupper(str_replace('-', '_', $key));
            if (\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true)) {
                $_SERVER[$key] = implode(', ', $value);
            } else {
                $_SERVER['HTTP_'.$key] = implode(', ', $value);
            }
        }

        $request = ['g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE];

        $requestOrder = \ini_get('request_order') ?: \ini_get('variables_order');
        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';

        $_REQUEST = [[]];

        foreach (str_split($requestOrder) as $order) {
            $_REQUEST[] = $request[$order];
        }

        $_REQUEST = array_merge(...$_REQUEST);
 <\s>
"
"<s>[INST] set trusted proxies [/INST]         self::$trustedProxies = array_reduce($proxies, function ($proxies, $proxy) {
            if ('REMOTE_ADDR' !== $proxy) {
                $proxies[] = $proxy;
            } elseif (isset($_SERVER['REMOTE_ADDR'])) {
                $proxies[] = $_SERVER['REMOTE_ADDR'];
            }

            return $proxies;
        }, []);
        self::$trustedHeaderSet = $trustedHeaderSet;
 <\s>
"
"<s>[INST] get trusted proxies [/INST]         return self::$trustedProxies;
 <\s>
"
"<s>[INST] get trusted header set [/INST]         return self::$trustedHeaderSet;
 <\s>
"
"<s>[INST] set trusted hosts [/INST]         self::$trustedHostPatterns = array_map(fn ($hostPattern) => sprintf('{%s}i', $hostPattern), $hostPatterns);
        // we need to reset trusted hosts on trusted host patterns change
        self::$trustedHosts = [];
 <\s>
"
"<s>[INST] get trusted hosts [/INST]         return self::$trustedHostPatterns;
 <\s>
"
"<s>[INST] normalize query string [/INST]         if ('' === ($qs ?? '')) {
            return '';
        }

        $qs = HeaderUtils::parseQuery($qs);
        ksort($qs);

        return http_build_query($qs, '', '&', \PHP_QUERY_RFC3986);
 <\s>
"
"<s>[INST] enable http method parameter override [/INST]         self::$httpMethodParameterOverride = true;
 <\s>
"
"<s>[INST] get http method parameter override [/INST]         return self::$httpMethodParameterOverride;
 <\s>
"
"<s>[INST] get [/INST]         if ($this !== $result = $this->attributes->get($key, $this)) {
            return $result;
        }

        if ($this->query->has($key)) {
            return $this->query->all()[$key];
        }

        if ($this->request->has($key)) {
            return $this->request->all()[$key];
        }

        return $default;
 <\s>
"
"<s>[INST] get session [/INST]         $session = $this->session;
        if (!$session instanceof SessionInterface && null !== $session) {
            $this->setSession($session = $session());
        }

        if (null === $session) {
            throw new SessionNotFoundException('Session has not been set.');
        }

        return $session;
 <\s>
"
"<s>[INST] has previous session [/INST]         // the check for $this->session avoids malicious users trying to fake a session cookie with proper name
        return $this->hasSession() && $this->cookies->has($this->getSession()->getName());
 <\s>
"
"<s>[INST] has session [/INST]         return null !== $this->session && (!$skipIfUninitialized || $this->session instanceof SessionInterface);
 <\s>
"
"<s>[INST] set session [/INST]         $this->session = $session;
 <\s>
"
"<s>[INST] set session factory [/INST]         $this->session = $factory;
 <\s>
"
"<s>[INST] get client ips [/INST]         $ip = $this->server->get('REMOTE_ADDR');

        if (!$this->isFromTrustedProxy()) {
            return [$ip];
        }

        return $this->getTrustedValues(self::HEADER_X_FORWARDED_FOR, $ip) ?: [$ip];
 <\s>
"
"<s>[INST] get client ip [/INST]         $ipAddresses = $this->getClientIps();

        return $ipAddresses[0];
 <\s>
"
"<s>[INST] get script name [/INST]         return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));
 <\s>
"
"<s>[INST] get path info [/INST]         return $this->pathInfo ??= $this->preparePathInfo();
 <\s>
"
"<s>[INST] get base path [/INST]         return $this->basePath ??= $this->prepareBasePath();
 <\s>
"
"<s>[INST] get base url [/INST]         $trustedPrefix = '';

        // the proxy prefix must be prepended to any prefix being needed at the webserver level
        if ($this->isFromTrustedProxy() && $trustedPrefixValues = $this->getTrustedValues(self::HEADER_X_FORWARDED_PREFIX)) {
            $trustedPrefix = rtrim($trustedPrefixValues[0], '/');
        }

        return $trustedPrefix.$this->getBaseUrlReal();
 <\s>
"
"<s>[INST] get scheme [/INST]         return $this->isSecure() ? 'https' : 'http';
 <\s>
"
"<s>[INST] get port [/INST]         if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_PORT)) {
            $host = $host[0];
        } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {
            $host = $host[0];
        } elseif (!$host = $this->headers->get('HOST')) {
            return $this->server->get('SERVER_PORT');
        }

        if ('[' === $host[0]) {
            $pos = strpos($host, ':', strrpos($host, ']'));
        } else {
            $pos = strrpos($host, ':');
        }

        if (false !== $pos && $port = substr($host, $pos + 1)) {
            return (int) $port;
        }

        return 'https' === $this->getScheme() ? 443 : 80;
 <\s>
"
"<s>[INST] get user [/INST]         return $this->headers->get('PHP_AUTH_USER');
 <\s>
"
"<s>[INST] get password [/INST]         return $this->headers->get('PHP_AUTH_PW');
 <\s>
"
"<s>[INST] get user info [/INST]         $userinfo = $this->getUser();

        $pass = $this->getPassword();
        if ('' != $pass) {
            $userinfo .= "":$pass"";
        }

        return $userinfo;
 <\s>
"
"<s>[INST] get http host [/INST]         $scheme = $this->getScheme();
        $port = $this->getPort();

        if (('http' === $scheme && 80 == $port) || ('https' === $scheme && 443 == $port)) {
            return $this->getHost();
        }

        return $this->getHost().':'.$port;
 <\s>
"
"<s>[INST] get request uri [/INST]         return $this->requestUri ??= $this->prepareRequestUri();
 <\s>
"
"<s>[INST] get scheme and http host [/INST]         return $this->getScheme().'://'.$this->getHttpHost();
 <\s>
"
"<s>[INST] get uri [/INST]         if (null !== $qs = $this->getQueryString()) {
            $qs = '?'.$qs;
        }

        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;
 <\s>
"
"<s>[INST] get uri for path [/INST]         return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;
 <\s>
"
"<s>[INST] get relative uri for path [/INST]         // be sure that we are dealing with an absolute path
        if (!isset($path[0]) || '/' !== $path[0]) {
            return $path;
        }

        if ($path === $basePath = $this->getPathInfo()) {
            return '';
        }

        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);
        $targetDirs = explode('/', substr($path, 1));
        array_pop($sourceDirs);
        $targetFile = array_pop($targetDirs);

        foreach ($sourceDirs as $i => $dir) {
            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {
                unset($sourceDirs[$i], $targetDirs[$i]);
            } else {
                break;
            }
        }

        $targetDirs[] = $targetFile;
        $path = str_repeat('../', \count($sourceDirs)).implode('/', $targetDirs);

        // A reference to the same base directory or an empty subdirectory must be prefixed with ""./"".
        // This also applies to a segment with a colon character (e.g., ""file:colon"") that cannot be used
        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name
        // (see https://tools.ietf.org/html/rfc3986#section-4.2).
        return !isset($path[0]) || '/' === $path[0]
            || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos)
            ? ""./$path"" : $path;
 <\s>
"
"<s>[INST] get query string [/INST]         $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));

        return '' === $qs ? null : $qs;
 <\s>
"
"<s>[INST] is secure [/INST]         if ($this->isFromTrustedProxy() && $proto = $this->getTrustedValues(self::HEADER_X_FORWARDED_PROTO)) {
            return \in_array(strtolower($proto[0]), ['https', 'on', 'ssl', '1'], true);
        }

        $https = $this->server->get('HTTPS');

        return !empty($https) && 'off' !== strtolower($https);
 <\s>
"
"<s>[INST] get host [/INST]         if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {
            $host = $host[0];
        } elseif (!$host = $this->headers->get('HOST')) {
            if (!$host = $this->server->get('SERVER_NAME')) {
                $host = $this->server->get('SERVER_ADDR', '');
            }
        }

        // trim and remove port number from host
        // host is lowercase as per RFC 952/2181
        $host = strtolower(preg_replace('/:\d+$/', '', trim($host)));

        // as the host can come from the user (HTTP_HOST and depending on the configuration, SERVER_NAME too can come from the user)
        // check that it does not contain forbidden characters (see RFC 952 and RFC 2181)
        // use preg_replace() instead of preg_match() to prevent DoS attacks with long host names
        if ($host && '' !== preg_replace('/(?:^\[)?[a-zA-Z0-9-:\]_]+\.?/', '', $host)) {
            if (!$this->isHostValid) {
                return '';
            }
            $this->isHostValid = false;

            throw new SuspiciousOperationException(sprintf('Invalid Host ""%s"".', $host));
        }

        if (\count(self::$trustedHostPatterns) > 0) {
            // to avoid host header injection attacks, you should provide a list of trusted host patterns

            if (\in_array($host, self::$trustedHosts)) {
                return $host;
            }

            foreach (self::$trustedHostPatterns as $pattern) {
                if (preg_match($pattern, $host)) {
                    self::$trustedHosts[] = $host;

                    return $host;
                }
            }

            if (!$this->isHostValid) {
                return '';
            }
            $this->isHostValid = false;

            throw new SuspiciousOperationException(sprintf('Untrusted Host ""%s"".', $host));
        }

        return $host;
 <\s>
"
"<s>[INST] set method [/INST]         $this->method = null;
        $this->server->set('REQUEST_METHOD', $method);
 <\s>
"
"<s>[INST] get method [/INST]         if (null !== $this->method) {
            return $this->method;
        }

        $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));

        if ('POST' !== $this->method) {
            return $this->method;
        }

        $method = $this->headers->get('X-HTTP-METHOD-OVERRIDE');

        if (!$method && self::$httpMethodParameterOverride) {
            $method = $this->request->get('_method', $this->query->get('_method', 'POST'));
        }

        if (!\is_string($method)) {
            return $this->method;
        }

        $method = strtoupper($method);

        if (\in_array($method, ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'PATCH', 'PURGE', 'TRACE'], true)) {
            return $this->method = $method;
        }

        if (!preg_match('/^[A-Z]++$/D', $method)) {
            throw new SuspiciousOperationException(sprintf('Invalid method override ""%s"".', $method));
        }

        return $this->method = $method;
 <\s>
"
"<s>[INST] get real method [/INST]         return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));
 <\s>
"
"<s>[INST] get mime type [/INST]         if (null === static::$formats) {
            static::initializeFormats();
        }

        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;
 <\s>
"
"<s>[INST] get mime types [/INST]         if (null === static::$formats) {
            static::initializeFormats();
        }

        return static::$formats[$format] ?? [];
 <\s>
"
"<s>[INST] get format [/INST]         $canonicalMimeType = null;
        if ($mimeType && false !== $pos = strpos($mimeType, ';')) {
            $canonicalMimeType = trim(substr($mimeType, 0, $pos));
        }

        if (null === static::$formats) {
            static::initializeFormats();
        }

        foreach (static::$formats as $format => $mimeTypes) {
            if (\in_array($mimeType, (array) $mimeTypes)) {
                return $format;
            }
            if (null !== $canonicalMimeType && \in_array($canonicalMimeType, (array) $mimeTypes)) {
                return $format;
            }
        }

        return null;
 <\s>
"
"<s>[INST] set format [/INST]         if (null === static::$formats) {
            static::initializeFormats();
        }

        static::$formats[$format] = \is_array($mimeTypes) ? $mimeTypes : [$mimeTypes];
 <\s>
"
"<s>[INST] get request format [/INST]         $this->format ??= $this->attributes->get('_format');

        return $this->format ?? $default;
 <\s>
"
"<s>[INST] set request format [/INST]         $this->format = $format;
 <\s>
"
"<s>[INST] get content type [/INST]         trigger_deprecation('symfony/http-foundation', '6.2', 'The ""%s()"" method is deprecated, use ""getContentTypeFormat()"" instead.', __METHOD__);

        return $this->getContentTypeFormat();
 <\s>
"
"<s>[INST] get content type format [/INST]         return $this->getFormat($this->headers->get('CONTENT_TYPE', ''));
 <\s>
"
"<s>[INST] set default locale [/INST]         $this->defaultLocale = $locale;

        if (null === $this->locale) {
            $this->setPhpDefaultLocale($locale);
        }
 <\s>
"
"<s>[INST] get default locale [/INST]         return $this->defaultLocale;
 <\s>
"
"<s>[INST] set locale [/INST]         $this->setPhpDefaultLocale($this->locale = $locale);
 <\s>
"
"<s>[INST] get locale [/INST]         return $this->locale ?? $this->defaultLocale;
 <\s>
"
"<s>[INST] is method [/INST]         return $this->getMethod() === strtoupper($method);
 <\s>
"
"<s>[INST] is method safe [/INST]         return \in_array($this->getMethod(), ['GET', 'HEAD', 'OPTIONS', 'TRACE']);
 <\s>
"
"<s>[INST] is method idempotent [/INST]         return \in_array($this->getMethod(), ['HEAD', 'GET', 'PUT', 'DELETE', 'TRACE', 'OPTIONS', 'PURGE']);
 <\s>
"
"<s>[INST] is method cacheable [/INST]         return \in_array($this->getMethod(), ['GET', 'HEAD']);
 <\s>
"
"<s>[INST] get protocol version [/INST]         if ($this->isFromTrustedProxy()) {
            preg_match('~^(HTTP/)?([1-9]\.[0-9]) ~', $this->headers->get('Via') ?? '', $matches);

            if ($matches) {
                return 'HTTP/'.$matches[2];
            }
        }

        return $this->server->get('SERVER_PROTOCOL');
 <\s>
"
"<s>[INST] get content [/INST]         $currentContentIsResource = \is_resource($this->content);

        if (true === $asResource) {
            if ($currentContentIsResource) {
                rewind($this->content);

                return $this->content;
            }

            // Content passed in parameter (test)
            if (\is_string($this->content)) {
                $resource = fopen('php://temp', 'r+');
                fwrite($resource, $this->content);
                rewind($resource);

                return $resource;
            }

            $this->content = false;

            return fopen('php://input', 'r');
        }

        if ($currentContentIsResource) {
            rewind($this->content);

            return stream_get_contents($this->content);
        }

        if (null === $this->content || false === $this->content) {
            $this->content = file_get_contents('php://input');
        }

        return $this->content;
 <\s>
"
"<s>[INST] get payload [/INST]         return $this->request->count() ? clone $this->request : new InputBag($this->toArray());
 <\s>
"
"<s>[INST] to array [/INST]         if ('' === $content = $this->getContent()) {
            throw new JsonException('Request body is empty.');
        }

        try {
            $content = json_decode($content, true, 512, \JSON_BIGINT_AS_STRING | \JSON_THROW_ON_ERROR);
        } catch (\JsonException $e) {
            throw new JsonException('Could not decode request body.', $e->getCode(), $e);
        }

        if (!\is_array($content)) {
            throw new JsonException(sprintf('JSON content was expected to decode to an array, ""%s"" returned.', get_debug_type($content)));
        }

        return $content;
 <\s>
"
"<s>[INST] get e tags [/INST]         return preg_split('/\s*,\s*/', $this->headers->get('If-None-Match', ''), -1, \PREG_SPLIT_NO_EMPTY);
 <\s>
"
"<s>[INST] is no cache [/INST]         return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');
 <\s>
"
"<s>[INST] get preferred format [/INST]         if (null !== $this->preferredFormat || null !== $this->preferredFormat = $this->getRequestFormat(null)) {
            return $this->preferredFormat;
        }

        foreach ($this->getAcceptableContentTypes() as $mimeType) {
            if ($this->preferredFormat = $this->getFormat($mimeType)) {
                return $this->preferredFormat;
            }
        }

        return $default;
 <\s>
"
"<s>[INST] get preferred language [/INST]         $preferredLanguages = $this->getLanguages();

        if (empty($locales)) {
            return $preferredLanguages[0] ?? null;
        }

        if (!$preferredLanguages) {
            return $locales[0];
        }

        $extendedPreferredLanguages = [];
        foreach ($preferredLanguages as $language) {
            $extendedPreferredLanguages[] = $language;
            if (false !== $position = strpos($language, '_')) {
                $superLanguage = substr($language, 0, $position);
                if (!\in_array($superLanguage, $preferredLanguages)) {
                    $extendedPreferredLanguages[] = $superLanguage;
                }
            }
        }

        $preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));

        return $preferredLanguages[0] ?? $locales[0];
 <\s>
"
"<s>[INST] get languages [/INST]         if (null !== $this->languages) {
            return $this->languages;
        }

        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();
        $this->languages = [];
        foreach ($languages as $acceptHeaderItem) {
            $lang = $acceptHeaderItem->getValue();
            if (str_contains($lang, '-')) {
                $codes = explode('-', $lang);
                if ('i' === $codes[0]) {
                    // Language not listed in ISO 639 that are not variants
                    // of any listed language, which can be registered with the
                    // i-prefix, such as i-cherokee
                    if (\count($codes) > 1) {
                        $lang = $codes[1];
                    }
                } else {
                    for ($i = 0, $max = \count($codes); $i < $max; ++$i) {
                        if (0 === $i) {
                            $lang = strtolower($codes[0]);
                        } else {
                            $lang .= '_'.strtoupper($codes[$i]);
                        }
                    }
                }
            }

            $this->languages[] = $lang;
        }

        return $this->languages;
 <\s>
"
"<s>[INST] get charsets [/INST]         if (null !== $this->charsets) {
            return $this->charsets;
        }

        return $this->charsets = array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all()));
 <\s>
"
"<s>[INST] get encodings [/INST]         if (null !== $this->encodings) {
            return $this->encodings;
        }

        return $this->encodings = array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all()));
 <\s>
"
"<s>[INST] get acceptable content types [/INST]         if (null !== $this->acceptableContentTypes) {
            return $this->acceptableContentTypes;
        }

        return $this->acceptableContentTypes = array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all()));
 <\s>
"
"<s>[INST] is xml http request [/INST]         return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');
 <\s>
"
"<s>[INST] prefer safe content [/INST]         if (isset($this->isSafeContentPreferred)) {
            return $this->isSafeContentPreferred;
        }

        if (!$this->isSecure()) {
            // see https://tools.ietf.org/html/rfc8674#section-3
            return $this->isSafeContentPreferred = false;
        }

        return $this->isSafeContentPreferred = AcceptHeader::fromString($this->headers->get('Prefer'))->has('safe');
 <\s>
"
"<s>[INST] prepare request uri [/INST]         $requestUri = '';

        if ('1' == $this->server->get('IIS_WasUrlRewritten') && '' != $this->server->get('UNENCODED_URL')) {
            // IIS7 with URL Rewrite: make sure we get the unencoded URL (double slash problem)
            $requestUri = $this->server->get('UNENCODED_URL');
            $this->server->remove('UNENCODED_URL');
            $this->server->remove('IIS_WasUrlRewritten');
        } elseif ($this->server->has('REQUEST_URI')) {
            $requestUri = $this->server->get('REQUEST_URI');

            if ('' !== $requestUri && '/' === $requestUri[0]) {
                // To only use path and query remove the fragment.
                if (false !== $pos = strpos($requestUri, '#')) {
                    $requestUri = substr($requestUri, 0, $pos);
                }
            } else {
                // HTTP proxy reqs setup request URI with scheme and host [and port] + the URL path,
                // only use URL path.
                $uriComponents = parse_url($requestUri);

                if (isset($uriComponents['path'])) {
                    $requestUri = $uriComponents['path'];
                }

                if (isset($uriComponents['query'])) {
                    $requestUri .= '?'.$uriComponents['query'];
                }
            }
        } elseif ($this->server->has('ORIG_PATH_INFO')) {
            // IIS 5.0, PHP as CGI
            $requestUri = $this->server->get('ORIG_PATH_INFO');
            if ('' != $this->server->get('QUERY_STRING')) {
                $requestUri .= '?'.$this->server->get('QUERY_STRING');
            }
            $this->server->remove('ORIG_PATH_INFO');
        }

        // normalize the request URI to ease creating sub-requests from this request
        $this->server->set('REQUEST_URI', $requestUri);

        return $requestUri;
 <\s>
"
"<s>[INST] prepare base url [/INST]         $filename = basename($this->server->get('SCRIPT_FILENAME', ''));

        if (basename($this->server->get('SCRIPT_NAME', '')) === $filename) {
            $baseUrl = $this->server->get('SCRIPT_NAME');
        } elseif (basename($this->server->get('PHP_SELF', '')) === $filename) {
            $baseUrl = $this->server->get('PHP_SELF');
        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME', '')) === $filename) {
            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); // 1and1 shared hosting compatibility
        } else {
            // Backtrack up the script_filename to find the portion matching
            // php_self
            $path = $this->server->get('PHP_SELF', '');
            $file = $this->server->get('SCRIPT_FILENAME', '');
            $segs = explode('/', trim($file, '/'));
            $segs = array_reverse($segs);
            $index = 0;
            $last = \count($segs);
            $baseUrl = '';
            do {
                $seg = $segs[$index];
                $baseUrl = '/'.$seg.$baseUrl;
                ++$index;
            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);
        }

        // Does the baseUrl have anything in common with the request_uri?
        $requestUri = $this->getRequestUri();
        if ('' !== $requestUri && '/' !== $requestUri[0]) {
            $requestUri = '/'.$requestUri;
        }

        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {
            // full $baseUrl matches
            return $prefix;
        }

        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, rtrim(\dirname($baseUrl), '/'.\DIRECTORY_SEPARATOR).'/')) {
            // directory portion of $baseUrl matches
            return rtrim($prefix, '/'.\DIRECTORY_SEPARATOR);
        }

        $truncatedRequestUri = $requestUri;
        if (false !== $pos = strpos($requestUri, '?')) {
            $truncatedRequestUri = substr($requestUri, 0, $pos);
        }

        $basename = basename($baseUrl ?? '');
        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {
            // no match whatsoever; set it blank
            return '';
        }

        // If using mod_rewrite or ISAPI_Rewrite strip the script filename
        // out of baseUrl. $pos !== 0 makes sure it is not matching a value
        // from PATH_INFO or QUERY_STRING
        if (\strlen($requestUri) >= \strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && 0 !== $pos) {
            $baseUrl = substr($requestUri, 0, $pos + \strlen($baseUrl));
        }

        return rtrim($baseUrl, '/'.\DIRECTORY_SEPARATOR);
 <\s>
"
"<s>[INST] prepare base path [/INST]         $baseUrl = $this->getBaseUrl();
        if (empty($baseUrl)) {
            return '';
        }

        $filename = basename($this->server->get('SCRIPT_FILENAME'));
        if (basename($baseUrl) === $filename) {
            $basePath = \dirname($baseUrl);
        } else {
            $basePath = $baseUrl;
        }

        if ('\\' === \DIRECTORY_SEPARATOR) {
            $basePath = str_replace('\\', '/', $basePath);
        }

        return rtrim($basePath, '/');
 <\s>
"
"<s>[INST] prepare path info [/INST]         if (null === ($requestUri = $this->getRequestUri())) {
            return '/';
        }

        // Remove the query string from REQUEST_URI
        if (false !== $pos = strpos($requestUri, '?')) {
            $requestUri = substr($requestUri, 0, $pos);
        }
        if ('' !== $requestUri && '/' !== $requestUri[0]) {
            $requestUri = '/'.$requestUri;
        }

        if (null === ($baseUrl = $this->getBaseUrlReal())) {
            return $requestUri;
        }

        $pathInfo = substr($requestUri, \strlen($baseUrl));
        if (false === $pathInfo || '' === $pathInfo) {
            // If substr() returns false then PATH_INFO is set to an empty string
            return '/';
        }

        return $pathInfo;
 <\s>
"
"<s>[INST] initialize formats [/INST]         static::$formats = [
            'html' => ['text/html', 'application/xhtml+xml'],
            'txt' => ['text/plain'],
            'js' => ['application/javascript', 'application/x-javascript', 'text/javascript'],
            'css' => ['text/css'],
            'json' => ['application/json', 'application/x-json'],
            'jsonld' => ['application/ld+json'],
            'xml' => ['text/xml', 'application/xml', 'application/x-xml'],
            'rdf' => ['application/rdf+xml'],
            'atom' => ['application/atom+xml'],
            'rss' => ['application/rss+xml'],
            'form' => ['application/x-www-form-urlencoded', 'multipart/form-data'],
        ];
 <\s>
"
"<s>[INST] is from trusted proxy [/INST]         return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR', ''), self::$trustedProxies);
 <\s>
"
"<s>[INST] get extra [/INST]         return (bool) $this->get(TleRequest::EXTRA_PARAM, false);
 <\s>
"
"<s>[INST] validate extra param [/INST]         return $validator->validate(
            $this->query->all(),
            new Assert\Collection(
                [
                    'allowExtraFields' => true,
                    'allowMissingFields' => true,
                    'fields' => [
                        TleRequest::EXTRA_PARAM => new Assert\Optional(new Assert\Choice(Filter::BOOLEAN_VALUES)),
                    ],
                ]
            )
        );
 <\s>
"
"<s>[INST] get date time [/INST]         $date = $this->get($name, DateTimeService::getCurrentUTC()->format(\DateTimeInterface::ATOM));

        return \DateTime::createFromFormat(\DateTimeInterface::ATOM, str_replace(' ', '+', $date));
 <\s>
"
"<s>[INST] validate [/INST]         $violations = $this->validateExtraParam($validator);
        $violations->addAll(parent::validate($validator));

        return $violations;
 <\s>
"
"<s>[INST] get satellite ids filter [/INST]         return $this->get(TleCollectionSortableFieldsEnum::SATELLITE_ID, []);
 <\s>
"
"<s>[INST] get filters [/INST]         if (null !== $this->filters) {
            return $this->filters;
        }

        $result = [];

        foreach ($filters as $filter => $type) {
            $values = $this->get($filter, []);

            if (Filter::FILTER_TYPE_ARRAY === $type && !empty($values)) {
                $result[] = new Filter($filter, $type, Filter::OPERATOR_EQUAL, $values);

                continue;
            }

            foreach ($values as $operator => $value) {
                $result[] = new Filter($filter, $type, $operator, $value);
            }
        }

        $this->filters = $result;

        return $this->filters;
 <\s>
"
"<s>[INST] get parameters [/INST]         $parameters = [
            self::$searchParam => $this->getSearch() ?? '*',
            self::$sortParam => $this->getSort(TleCollectionSortableFieldsEnum::POPULARITY),
            self::$sortDirParam => $this->getSortDirection(),
            self::$pageParam => $this->getPage(),
            self::$pageSizeParam => $this->getPageSize(),
        ];

        foreach ($this->getFilters() as $filter) {
            if (TleCollectionSortableFieldsEnum::SATELLITE_ID === $filter->filter) {
                continue;
            }
            $parameters[\sprintf('%s[%s]', $filter->filter, $filter->operator)] = $filter->value;
        }

        foreach ($this->getSatelliteIdsFilter() as $index => $satelliteId) {
            $name = \sprintf('%s[%d]', TleCollectionSortableFieldsEnum::SATELLITE_ID, $index);
            $parameters[$name] = $satelliteId;
        }

        return $parameters;
 <\s>
"
"<s>[INST] get page [/INST]         return (int)$this->get(static::$pageParam, 1);
 <\s>
"
"<s>[INST] get page size [/INST]         return (int)min($this->get(static::$pageSizeParam, static::$defaultPageSize), static::$maxPageSize);
 <\s>
"
"<s>[INST] get sort direction [/INST]         return $this->get(static::$sortDirParam, SortDirectionEnum::DESCENDING);
 <\s>
"
"<s>[INST] get sort [/INST]         return $this->get(static::$sortParam, $default);
 <\s>
"
"<s>[INST] get search [/INST]         return $this->get(static::$searchParam);
 <\s>
"
"<s>[INST] __construct [/INST]         $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);
 <\s>
"
"<s>[INST] initialize [/INST]         $this->request = new InputBag($request);
        $this->query = new InputBag($query);
        $this->attributes = new ParameterBag($attributes);
        $this->cookies = new InputBag($cookies);
        $this->files = new FileBag($files);
        $this->server = new ServerBag($server);
        $this->headers = new HeaderBag($this->server->getHeaders());

        $this->content = $content;
        $this->languages = null;
        $this->charsets = null;
        $this->encodings = null;
        $this->acceptableContentTypes = null;
        $this->pathInfo = null;
        $this->requestUri = null;
        $this->baseUrl = null;
        $this->basePath = null;
        $this->method = null;
        $this->format = null;
 <\s>
"
"<s>[INST] create from globals [/INST]         $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $_SERVER);

        if (str_starts_with($request->headers->get('CONTENT_TYPE', ''), 'application/x-www-form-urlencoded')
            && \in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), ['PUT', 'DELETE', 'PATCH'])
        ) {
            parse_str($request->getContent(), $data);
            $request->request = new InputBag($data);
        }

        return $request;
 <\s>
"
"<s>[INST] create [/INST]         $server = array_replace([
            'SERVER_NAME' => 'localhost',
            'SERVER_PORT' => 80,
            'HTTP_HOST' => 'localhost',
            'HTTP_USER_AGENT' => 'Symfony',
            'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',
            'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',
            'REMOTE_ADDR' => '127.0.0.1',
            'SCRIPT_NAME' => '',
            'SCRIPT_FILENAME' => '',
            'SERVER_PROTOCOL' => 'HTTP/1.1',
            'REQUEST_TIME' => time(),
            'REQUEST_TIME_FLOAT' => microtime(true),
        ], $server);

        $server['PATH_INFO'] = '';
        $server['REQUEST_METHOD'] = strtoupper($method);

        $components = parse_url($uri);
        if (false === $components) {
            trigger_deprecation('symfony/http-foundation', '6.3', 'Calling ""%s()"" with an invalid URI is deprecated.', __METHOD__);
            $components = [];
        }
        if (isset($components['host'])) {
            $server['SERVER_NAME'] = $components['host'];
            $server['HTTP_HOST'] = $components['host'];
        }

        if (isset($components['scheme'])) {
            if ('https' === $components['scheme']) {
                $server['HTTPS'] = 'on';
                $server['SERVER_PORT'] = 443;
            } else {
                unset($server['HTTPS']);
                $server['SERVER_PORT'] = 80;
            }
        }

        if (isset($components['port'])) {
            $server['SERVER_PORT'] = $components['port'];
            $server['HTTP_HOST'] .= ':'.$components['port'];
        }

        if (isset($components['user'])) {
            $server['PHP_AUTH_USER'] = $components['user'];
        }

        if (isset($components['pass'])) {
            $server['PHP_AUTH_PW'] = $components['pass'];
        }

        if (!isset($components['path'])) {
            $components['path'] = '/';
        }

        switch (strtoupper($method)) {
            case 'POST':
            case 'PUT':
            case 'DELETE':
                if (!isset($server['CONTENT_TYPE'])) {
                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';
                }
                // no break
            case 'PATCH':
                $request = $parameters;
                $query = [];
                break;
            default:
                $request = [];
                $query = $parameters;
                break;
        }

        $queryString = '';
        if (isset($components['query'])) {
            parse_str(html_entity_decode($components['query']), $qs);

            if ($query) {
                $query = array_replace($qs, $query);
                $queryString = http_build_query($query, '', '&');
            } else {
                $query = $qs;
                $queryString = $components['query'];
            }
        } elseif ($query) {
            $queryString = http_build_query($query, '', '&');
        }

        $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');
        $server['QUERY_STRING'] = $queryString;

        return self::createRequestFromFactory($query, $request, [], $cookies, $files, $server, $content);
 <\s>
"
"<s>[INST] set factory [/INST]         self::$requestFactory = $callable;
 <\s>
"
"<s>[INST] duplicate [/INST]         $dup = clone $this;
        if (null !== $query) {
            $dup->query = new InputBag($query);
        }
        if (null !== $request) {
            $dup->request = new InputBag($request);
        }
        if (null !== $attributes) {
            $dup->attributes = new ParameterBag($attributes);
        }
        if (null !== $cookies) {
            $dup->cookies = new InputBag($cookies);
        }
        if (null !== $files) {
            $dup->files = new FileBag($files);
        }
        if (null !== $server) {
            $dup->server = new ServerBag($server);
            $dup->headers = new HeaderBag($dup->server->getHeaders());
        }
        $dup->languages = null;
        $dup->charsets = null;
        $dup->encodings = null;
        $dup->acceptableContentTypes = null;
        $dup->pathInfo = null;
        $dup->requestUri = null;
        $dup->baseUrl = null;
        $dup->basePath = null;
        $dup->method = null;
        $dup->format = null;

        if (!$dup->get('_format') && $this->get('_format')) {
            $dup->attributes->set('_format', $this->get('_format'));
        }

        if (!$dup->getRequestFormat(null)) {
            $dup->setRequestFormat($this->getRequestFormat(null));
        }

        return $dup;
 <\s>
"
"<s>[INST] __clone [/INST]         $this->query = clone $this->query;
        $this->request = clone $this->request;
        $this->attributes = clone $this->attributes;
        $this->cookies = clone $this->cookies;
        $this->files = clone $this->files;
        $this->server = clone $this->server;
        $this->headers = clone $this->headers;
 <\s>
"
"<s>[INST] __to string [/INST]         $content = $this->getContent();

        $cookieHeader = '';
        $cookies = [];

        foreach ($this->cookies as $k => $v) {
            $cookies[] = \is_array($v) ? http_build_query([$k => $v], '', '; ', \PHP_QUERY_RFC3986) : ""$k=$v"";
        }

        if ($cookies) {
            $cookieHeader = 'Cookie: '.implode('; ', $cookies).""\r\n"";
        }

        return
            sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).""\r\n"".
            $this->headers.
            $cookieHeader.""\r\n"".
            $content;
 <\s>
"
"<s>[INST] override globals [/INST]         $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));

        $_GET = $this->query->all();
        $_POST = $this->request->all();
        $_SERVER = $this->server->all();
        $_COOKIE = $this->cookies->all();

        foreach ($this->headers->all() as $key => $value) {
            $key = strtoupper(str_replace('-', '_', $key));
            if (\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true)) {
                $_SERVER[$key] = implode(', ', $value);
            } else {
                $_SERVER['HTTP_'.$key] = implode(', ', $value);
            }
        }

        $request = ['g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE];

        $requestOrder = \ini_get('request_order') ?: \ini_get('variables_order');
        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';

        $_REQUEST = [[]];

        foreach (str_split($requestOrder) as $order) {
            $_REQUEST[] = $request[$order];
        }

        $_REQUEST = array_merge(...$_REQUEST);
 <\s>
"
"<s>[INST] set trusted proxies [/INST]         self::$trustedProxies = array_reduce($proxies, function ($proxies, $proxy) {
            if ('REMOTE_ADDR' !== $proxy) {
                $proxies[] = $proxy;
            } elseif (isset($_SERVER['REMOTE_ADDR'])) {
                $proxies[] = $_SERVER['REMOTE_ADDR'];
            }

            return $proxies;
        }, []);
        self::$trustedHeaderSet = $trustedHeaderSet;
 <\s>
"
"<s>[INST] get trusted proxies [/INST]         return self::$trustedProxies;
 <\s>
"
"<s>[INST] get trusted header set [/INST]         return self::$trustedHeaderSet;
 <\s>
"
"<s>[INST] set trusted hosts [/INST]         self::$trustedHostPatterns = array_map(fn ($hostPattern) => sprintf('{%s}i', $hostPattern), $hostPatterns);
        // we need to reset trusted hosts on trusted host patterns change
        self::$trustedHosts = [];
 <\s>
"
"<s>[INST] get trusted hosts [/INST]         return self::$trustedHostPatterns;
 <\s>
"
"<s>[INST] normalize query string [/INST]         if ('' === ($qs ?? '')) {
            return '';
        }

        $qs = HeaderUtils::parseQuery($qs);
        ksort($qs);

        return http_build_query($qs, '', '&', \PHP_QUERY_RFC3986);
 <\s>
"
"<s>[INST] enable http method parameter override [/INST]         self::$httpMethodParameterOverride = true;
 <\s>
"
"<s>[INST] get http method parameter override [/INST]         return self::$httpMethodParameterOverride;
 <\s>
"
"<s>[INST] get [/INST]         if ($this !== $result = $this->attributes->get($key, $this)) {
            return $result;
        }

        if ($this->query->has($key)) {
            return $this->query->all()[$key];
        }

        if ($this->request->has($key)) {
            return $this->request->all()[$key];
        }

        return $default;
 <\s>
"
"<s>[INST] get session [/INST]         $session = $this->session;
        if (!$session instanceof SessionInterface && null !== $session) {
            $this->setSession($session = $session());
        }

        if (null === $session) {
            throw new SessionNotFoundException('Session has not been set.');
        }

        return $session;
 <\s>
"
"<s>[INST] has previous session [/INST]         // the check for $this->session avoids malicious users trying to fake a session cookie with proper name
        return $this->hasSession() && $this->cookies->has($this->getSession()->getName());
 <\s>
"
"<s>[INST] has session [/INST]         return null !== $this->session && (!$skipIfUninitialized || $this->session instanceof SessionInterface);
 <\s>
"
"<s>[INST] set session [/INST]         $this->session = $session;
 <\s>
"
"<s>[INST] set session factory [/INST]         $this->session = $factory;
 <\s>
"
"<s>[INST] get client ips [/INST]         $ip = $this->server->get('REMOTE_ADDR');

        if (!$this->isFromTrustedProxy()) {
            return [$ip];
        }

        return $this->getTrustedValues(self::HEADER_X_FORWARDED_FOR, $ip) ?: [$ip];
 <\s>
"
"<s>[INST] get client ip [/INST]         $ipAddresses = $this->getClientIps();

        return $ipAddresses[0];
 <\s>
"
"<s>[INST] get script name [/INST]         return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));
 <\s>
"
"<s>[INST] get path info [/INST]         return $this->pathInfo ??= $this->preparePathInfo();
 <\s>
"
"<s>[INST] get base path [/INST]         return $this->basePath ??= $this->prepareBasePath();
 <\s>
"
"<s>[INST] get base url [/INST]         $trustedPrefix = '';

        // the proxy prefix must be prepended to any prefix being needed at the webserver level
        if ($this->isFromTrustedProxy() && $trustedPrefixValues = $this->getTrustedValues(self::HEADER_X_FORWARDED_PREFIX)) {
            $trustedPrefix = rtrim($trustedPrefixValues[0], '/');
        }

        return $trustedPrefix.$this->getBaseUrlReal();
 <\s>
"
"<s>[INST] get scheme [/INST]         return $this->isSecure() ? 'https' : 'http';
 <\s>
"
"<s>[INST] get port [/INST]         if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_PORT)) {
            $host = $host[0];
        } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {
            $host = $host[0];
        } elseif (!$host = $this->headers->get('HOST')) {
            return $this->server->get('SERVER_PORT');
        }

        if ('[' === $host[0]) {
            $pos = strpos($host, ':', strrpos($host, ']'));
        } else {
            $pos = strrpos($host, ':');
        }

        if (false !== $pos && $port = substr($host, $pos + 1)) {
            return (int) $port;
        }

        return 'https' === $this->getScheme() ? 443 : 80;
 <\s>
"
"<s>[INST] get user [/INST]         return $this->headers->get('PHP_AUTH_USER');
 <\s>
"
"<s>[INST] get password [/INST]         return $this->headers->get('PHP_AUTH_PW');
 <\s>
"
"<s>[INST] get user info [/INST]         $userinfo = $this->getUser();

        $pass = $this->getPassword();
        if ('' != $pass) {
            $userinfo .= "":$pass"";
        }

        return $userinfo;
 <\s>
"
"<s>[INST] get http host [/INST]         $scheme = $this->getScheme();
        $port = $this->getPort();

        if (('http' === $scheme && 80 == $port) || ('https' === $scheme && 443 == $port)) {
            return $this->getHost();
        }

        return $this->getHost().':'.$port;
 <\s>
"
"<s>[INST] get request uri [/INST]         return $this->requestUri ??= $this->prepareRequestUri();
 <\s>
"
"<s>[INST] get scheme and http host [/INST]         return $this->getScheme().'://'.$this->getHttpHost();
 <\s>
"
"<s>[INST] get uri [/INST]         if (null !== $qs = $this->getQueryString()) {
            $qs = '?'.$qs;
        }

        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;
 <\s>
"
"<s>[INST] get uri for path [/INST]         return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;
 <\s>
"
"<s>[INST] get relative uri for path [/INST]         // be sure that we are dealing with an absolute path
        if (!isset($path[0]) || '/' !== $path[0]) {
            return $path;
        }

        if ($path === $basePath = $this->getPathInfo()) {
            return '';
        }

        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);
        $targetDirs = explode('/', substr($path, 1));
        array_pop($sourceDirs);
        $targetFile = array_pop($targetDirs);

        foreach ($sourceDirs as $i => $dir) {
            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {
                unset($sourceDirs[$i], $targetDirs[$i]);
            } else {
                break;
            }
        }

        $targetDirs[] = $targetFile;
        $path = str_repeat('../', \count($sourceDirs)).implode('/', $targetDirs);

        // A reference to the same base directory or an empty subdirectory must be prefixed with ""./"".
        // This also applies to a segment with a colon character (e.g., ""file:colon"") that cannot be used
        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name
        // (see https://tools.ietf.org/html/rfc3986#section-4.2).
        return !isset($path[0]) || '/' === $path[0]
            || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos)
            ? ""./$path"" : $path;
 <\s>
"
"<s>[INST] get query string [/INST]         $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));

        return '' === $qs ? null : $qs;
 <\s>
"
"<s>[INST] is secure [/INST]         if ($this->isFromTrustedProxy() && $proto = $this->getTrustedValues(self::HEADER_X_FORWARDED_PROTO)) {
            return \in_array(strtolower($proto[0]), ['https', 'on', 'ssl', '1'], true);
        }

        $https = $this->server->get('HTTPS');

        return !empty($https) && 'off' !== strtolower($https);
 <\s>
"
"<s>[INST] get host [/INST]         if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {
            $host = $host[0];
        } elseif (!$host = $this->headers->get('HOST')) {
            if (!$host = $this->server->get('SERVER_NAME')) {
                $host = $this->server->get('SERVER_ADDR', '');
            }
        }

        // trim and remove port number from host
        // host is lowercase as per RFC 952/2181
        $host = strtolower(preg_replace('/:\d+$/', '', trim($host)));

        // as the host can come from the user (HTTP_HOST and depending on the configuration, SERVER_NAME too can come from the user)
        // check that it does not contain forbidden characters (see RFC 952 and RFC 2181)
        // use preg_replace() instead of preg_match() to prevent DoS attacks with long host names
        if ($host && '' !== preg_replace('/(?:^\[)?[a-zA-Z0-9-:\]_]+\.?/', '', $host)) {
            if (!$this->isHostValid) {
                return '';
            }
            $this->isHostValid = false;

            throw new SuspiciousOperationException(sprintf('Invalid Host ""%s"".', $host));
        }

        if (\count(self::$trustedHostPatterns) > 0) {
            // to avoid host header injection attacks, you should provide a list of trusted host patterns

            if (\in_array($host, self::$trustedHosts)) {
                return $host;
            }

            foreach (self::$trustedHostPatterns as $pattern) {
                if (preg_match($pattern, $host)) {
                    self::$trustedHosts[] = $host;

                    return $host;
                }
            }

            if (!$this->isHostValid) {
                return '';
            }
            $this->isHostValid = false;

            throw new SuspiciousOperationException(sprintf('Untrusted Host ""%s"".', $host));
        }

        return $host;
 <\s>
"
"<s>[INST] set method [/INST]         $this->method = null;
        $this->server->set('REQUEST_METHOD', $method);
 <\s>
"
"<s>[INST] get method [/INST]         if (null !== $this->method) {
            return $this->method;
        }

        $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));

        if ('POST' !== $this->method) {
            return $this->method;
        }

        $method = $this->headers->get('X-HTTP-METHOD-OVERRIDE');

        if (!$method && self::$httpMethodParameterOverride) {
            $method = $this->request->get('_method', $this->query->get('_method', 'POST'));
        }

        if (!\is_string($method)) {
            return $this->method;
        }

        $method = strtoupper($method);

        if (\in_array($method, ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'PATCH', 'PURGE', 'TRACE'], true)) {
            return $this->method = $method;
        }

        if (!preg_match('/^[A-Z]++$/D', $method)) {
            throw new SuspiciousOperationException(sprintf('Invalid method override ""%s"".', $method));
        }

        return $this->method = $method;
 <\s>
"
"<s>[INST] get real method [/INST]         return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));
 <\s>
"
"<s>[INST] get mime type [/INST]         if (null === static::$formats) {
            static::initializeFormats();
        }

        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;
 <\s>
"
"<s>[INST] get mime types [/INST]         if (null === static::$formats) {
            static::initializeFormats();
        }

        return static::$formats[$format] ?? [];
 <\s>
"
"<s>[INST] get format [/INST]         $canonicalMimeType = null;
        if ($mimeType && false !== $pos = strpos($mimeType, ';')) {
            $canonicalMimeType = trim(substr($mimeType, 0, $pos));
        }

        if (null === static::$formats) {
            static::initializeFormats();
        }

        foreach (static::$formats as $format => $mimeTypes) {
            if (\in_array($mimeType, (array) $mimeTypes)) {
                return $format;
            }
            if (null !== $canonicalMimeType && \in_array($canonicalMimeType, (array) $mimeTypes)) {
                return $format;
            }
        }

        return null;
 <\s>
"
"<s>[INST] set format [/INST]         if (null === static::$formats) {
            static::initializeFormats();
        }

        static::$formats[$format] = \is_array($mimeTypes) ? $mimeTypes : [$mimeTypes];
 <\s>
"
"<s>[INST] get request format [/INST]         $this->format ??= $this->attributes->get('_format');

        return $this->format ?? $default;
 <\s>
"
"<s>[INST] set request format [/INST]         $this->format = $format;
 <\s>
"
"<s>[INST] get content type [/INST]         trigger_deprecation('symfony/http-foundation', '6.2', 'The ""%s()"" method is deprecated, use ""getContentTypeFormat()"" instead.', __METHOD__);

        return $this->getContentTypeFormat();
 <\s>
"
"<s>[INST] get content type format [/INST]         return $this->getFormat($this->headers->get('CONTENT_TYPE', ''));
 <\s>
"
"<s>[INST] set default locale [/INST]         $this->defaultLocale = $locale;

        if (null === $this->locale) {
            $this->setPhpDefaultLocale($locale);
        }
 <\s>
"
"<s>[INST] get default locale [/INST]         return $this->defaultLocale;
 <\s>
"
"<s>[INST] set locale [/INST]         $this->setPhpDefaultLocale($this->locale = $locale);
 <\s>
"
"<s>[INST] get locale [/INST]         return $this->locale ?? $this->defaultLocale;
 <\s>
"
"<s>[INST] is method [/INST]         return $this->getMethod() === strtoupper($method);
 <\s>
"
"<s>[INST] is method safe [/INST]         return \in_array($this->getMethod(), ['GET', 'HEAD', 'OPTIONS', 'TRACE']);
 <\s>
"
"<s>[INST] is method idempotent [/INST]         return \in_array($this->getMethod(), ['HEAD', 'GET', 'PUT', 'DELETE', 'TRACE', 'OPTIONS', 'PURGE']);
 <\s>
"
"<s>[INST] is method cacheable [/INST]         return \in_array($this->getMethod(), ['GET', 'HEAD']);
 <\s>
"
"<s>[INST] get protocol version [/INST]         if ($this->isFromTrustedProxy()) {
            preg_match('~^(HTTP/)?([1-9]\.[0-9]) ~', $this->headers->get('Via') ?? '', $matches);

            if ($matches) {
                return 'HTTP/'.$matches[2];
            }
        }

        return $this->server->get('SERVER_PROTOCOL');
 <\s>
"
"<s>[INST] get content [/INST]         $currentContentIsResource = \is_resource($this->content);

        if (true === $asResource) {
            if ($currentContentIsResource) {
                rewind($this->content);

                return $this->content;
            }

            // Content passed in parameter (test)
            if (\is_string($this->content)) {
                $resource = fopen('php://temp', 'r+');
                fwrite($resource, $this->content);
                rewind($resource);

                return $resource;
            }

            $this->content = false;

            return fopen('php://input', 'r');
        }

        if ($currentContentIsResource) {
            rewind($this->content);

            return stream_get_contents($this->content);
        }

        if (null === $this->content || false === $this->content) {
            $this->content = file_get_contents('php://input');
        }

        return $this->content;
 <\s>
"
"<s>[INST] get payload [/INST]         return $this->request->count() ? clone $this->request : new InputBag($this->toArray());
 <\s>
"
"<s>[INST] to array [/INST]         if ('' === $content = $this->getContent()) {
            throw new JsonException('Request body is empty.');
        }

        try {
            $content = json_decode($content, true, 512, \JSON_BIGINT_AS_STRING | \JSON_THROW_ON_ERROR);
        } catch (\JsonException $e) {
            throw new JsonException('Could not decode request body.', $e->getCode(), $e);
        }

        if (!\is_array($content)) {
            throw new JsonException(sprintf('JSON content was expected to decode to an array, ""%s"" returned.', get_debug_type($content)));
        }

        return $content;
 <\s>
"
"<s>[INST] get e tags [/INST]         return preg_split('/\s*,\s*/', $this->headers->get('If-None-Match', ''), -1, \PREG_SPLIT_NO_EMPTY);
 <\s>
"
"<s>[INST] is no cache [/INST]         return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');
 <\s>
"
"<s>[INST] get preferred format [/INST]         if (null !== $this->preferredFormat || null !== $this->preferredFormat = $this->getRequestFormat(null)) {
            return $this->preferredFormat;
        }

        foreach ($this->getAcceptableContentTypes() as $mimeType) {
            if ($this->preferredFormat = $this->getFormat($mimeType)) {
                return $this->preferredFormat;
            }
        }

        return $default;
 <\s>
"
"<s>[INST] get preferred language [/INST]         $preferredLanguages = $this->getLanguages();

        if (empty($locales)) {
            return $preferredLanguages[0] ?? null;
        }

        if (!$preferredLanguages) {
            return $locales[0];
        }

        $extendedPreferredLanguages = [];
        foreach ($preferredLanguages as $language) {
            $extendedPreferredLanguages[] = $language;
            if (false !== $position = strpos($language, '_')) {
                $superLanguage = substr($language, 0, $position);
                if (!\in_array($superLanguage, $preferredLanguages)) {
                    $extendedPreferredLanguages[] = $superLanguage;
                }
            }
        }

        $preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));

        return $preferredLanguages[0] ?? $locales[0];
 <\s>
"
"<s>[INST] get languages [/INST]         if (null !== $this->languages) {
            return $this->languages;
        }

        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();
        $this->languages = [];
        foreach ($languages as $acceptHeaderItem) {
            $lang = $acceptHeaderItem->getValue();
            if (str_contains($lang, '-')) {
                $codes = explode('-', $lang);
                if ('i' === $codes[0]) {
                    // Language not listed in ISO 639 that are not variants
                    // of any listed language, which can be registered with the
                    // i-prefix, such as i-cherokee
                    if (\count($codes) > 1) {
                        $lang = $codes[1];
                    }
                } else {
                    for ($i = 0, $max = \count($codes); $i < $max; ++$i) {
                        if (0 === $i) {
                            $lang = strtolower($codes[0]);
                        } else {
                            $lang .= '_'.strtoupper($codes[$i]);
                        }
                    }
                }
            }

            $this->languages[] = $lang;
        }

        return $this->languages;
 <\s>
"
"<s>[INST] get charsets [/INST]         if (null !== $this->charsets) {
            return $this->charsets;
        }

        return $this->charsets = array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all()));
 <\s>
"
"<s>[INST] get encodings [/INST]         if (null !== $this->encodings) {
            return $this->encodings;
        }

        return $this->encodings = array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all()));
 <\s>
"
"<s>[INST] get acceptable content types [/INST]         if (null !== $this->acceptableContentTypes) {
            return $this->acceptableContentTypes;
        }

        return $this->acceptableContentTypes = array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all()));
 <\s>
"
"<s>[INST] is xml http request [/INST]         return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');
 <\s>
"
"<s>[INST] prefer safe content [/INST]         if (isset($this->isSafeContentPreferred)) {
            return $this->isSafeContentPreferred;
        }

        if (!$this->isSecure()) {
            // see https://tools.ietf.org/html/rfc8674#section-3
            return $this->isSafeContentPreferred = false;
        }

        return $this->isSafeContentPreferred = AcceptHeader::fromString($this->headers->get('Prefer'))->has('safe');
 <\s>
"
"<s>[INST] prepare request uri [/INST]         $requestUri = '';

        if ('1' == $this->server->get('IIS_WasUrlRewritten') && '' != $this->server->get('UNENCODED_URL')) {
            // IIS7 with URL Rewrite: make sure we get the unencoded URL (double slash problem)
            $requestUri = $this->server->get('UNENCODED_URL');
            $this->server->remove('UNENCODED_URL');
            $this->server->remove('IIS_WasUrlRewritten');
        } elseif ($this->server->has('REQUEST_URI')) {
            $requestUri = $this->server->get('REQUEST_URI');

            if ('' !== $requestUri && '/' === $requestUri[0]) {
                // To only use path and query remove the fragment.
                if (false !== $pos = strpos($requestUri, '#')) {
                    $requestUri = substr($requestUri, 0, $pos);
                }
            } else {
                // HTTP proxy reqs setup request URI with scheme and host [and port] + the URL path,
                // only use URL path.
                $uriComponents = parse_url($requestUri);

                if (isset($uriComponents['path'])) {
                    $requestUri = $uriComponents['path'];
                }

                if (isset($uriComponents['query'])) {
                    $requestUri .= '?'.$uriComponents['query'];
                }
            }
        } elseif ($this->server->has('ORIG_PATH_INFO')) {
            // IIS 5.0, PHP as CGI
            $requestUri = $this->server->get('ORIG_PATH_INFO');
            if ('' != $this->server->get('QUERY_STRING')) {
                $requestUri .= '?'.$this->server->get('QUERY_STRING');
            }
            $this->server->remove('ORIG_PATH_INFO');
        }

        // normalize the request URI to ease creating sub-requests from this request
        $this->server->set('REQUEST_URI', $requestUri);

        return $requestUri;
 <\s>
"
"<s>[INST] prepare base url [/INST]         $filename = basename($this->server->get('SCRIPT_FILENAME', ''));

        if (basename($this->server->get('SCRIPT_NAME', '')) === $filename) {
            $baseUrl = $this->server->get('SCRIPT_NAME');
        } elseif (basename($this->server->get('PHP_SELF', '')) === $filename) {
            $baseUrl = $this->server->get('PHP_SELF');
        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME', '')) === $filename) {
            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); // 1and1 shared hosting compatibility
        } else {
            // Backtrack up the script_filename to find the portion matching
            // php_self
            $path = $this->server->get('PHP_SELF', '');
            $file = $this->server->get('SCRIPT_FILENAME', '');
            $segs = explode('/', trim($file, '/'));
            $segs = array_reverse($segs);
            $index = 0;
            $last = \count($segs);
            $baseUrl = '';
            do {
                $seg = $segs[$index];
                $baseUrl = '/'.$seg.$baseUrl;
                ++$index;
            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);
        }

        // Does the baseUrl have anything in common with the request_uri?
        $requestUri = $this->getRequestUri();
        if ('' !== $requestUri && '/' !== $requestUri[0]) {
            $requestUri = '/'.$requestUri;
        }

        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {
            // full $baseUrl matches
            return $prefix;
        }

        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, rtrim(\dirname($baseUrl), '/'.\DIRECTORY_SEPARATOR).'/')) {
            // directory portion of $baseUrl matches
            return rtrim($prefix, '/'.\DIRECTORY_SEPARATOR);
        }

        $truncatedRequestUri = $requestUri;
        if (false !== $pos = strpos($requestUri, '?')) {
            $truncatedRequestUri = substr($requestUri, 0, $pos);
        }

        $basename = basename($baseUrl ?? '');
        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {
            // no match whatsoever; set it blank
            return '';
        }

        // If using mod_rewrite or ISAPI_Rewrite strip the script filename
        // out of baseUrl. $pos !== 0 makes sure it is not matching a value
        // from PATH_INFO or QUERY_STRING
        if (\strlen($requestUri) >= \strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && 0 !== $pos) {
            $baseUrl = substr($requestUri, 0, $pos + \strlen($baseUrl));
        }

        return rtrim($baseUrl, '/'.\DIRECTORY_SEPARATOR);
 <\s>
"
"<s>[INST] prepare base path [/INST]         $baseUrl = $this->getBaseUrl();
        if (empty($baseUrl)) {
            return '';
        }

        $filename = basename($this->server->get('SCRIPT_FILENAME'));
        if (basename($baseUrl) === $filename) {
            $basePath = \dirname($baseUrl);
        } else {
            $basePath = $baseUrl;
        }

        if ('\\' === \DIRECTORY_SEPARATOR) {
            $basePath = str_replace('\\', '/', $basePath);
        }

        return rtrim($basePath, '/');
 <\s>
"
"<s>[INST] prepare path info [/INST]         if (null === ($requestUri = $this->getRequestUri())) {
            return '/';
        }

        // Remove the query string from REQUEST_URI
        if (false !== $pos = strpos($requestUri, '?')) {
            $requestUri = substr($requestUri, 0, $pos);
        }
        if ('' !== $requestUri && '/' !== $requestUri[0]) {
            $requestUri = '/'.$requestUri;
        }

        if (null === ($baseUrl = $this->getBaseUrlReal())) {
            return $requestUri;
        }

        $pathInfo = substr($requestUri, \strlen($baseUrl));
        if (false === $pathInfo || '' === $pathInfo) {
            // If substr() returns false then PATH_INFO is set to an empty string
            return '/';
        }

        return $pathInfo;
 <\s>
"
"<s>[INST] initialize formats [/INST]         static::$formats = [
            'html' => ['text/html', 'application/xhtml+xml'],
            'txt' => ['text/plain'],
            'js' => ['application/javascript', 'application/x-javascript', 'text/javascript'],
            'css' => ['text/css'],
            'json' => ['application/json', 'application/x-json'],
            'jsonld' => ['application/ld+json'],
            'xml' => ['text/xml', 'application/xml', 'application/x-xml'],
            'rdf' => ['application/rdf+xml'],
            'atom' => ['application/atom+xml'],
            'rss' => ['application/rss+xml'],
            'form' => ['application/x-www-form-urlencoded', 'multipart/form-data'],
        ];
 <\s>
"
"<s>[INST] is from trusted proxy [/INST]         return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR', ''), self::$trustedProxies);
 <\s>
"
"<s>[INST] get extra [/INST]         return (bool) $this->get(TleRequest::EXTRA_PARAM, false);
 <\s>
"
"<s>[INST] validate extra param [/INST]         return $validator->validate(
            $this->query->all(),
            new Assert\Collection(
                [
                    'allowExtraFields' => true,
                    'allowMissingFields' => true,
                    'fields' => [
                        TleRequest::EXTRA_PARAM => new Assert\Optional(new Assert\Choice(Filter::BOOLEAN_VALUES)),
                    ],
                ]
            )
        );
 <\s>
"
"<s>[INST] set repository [/INST]         $this->repository = $repository;
 <\s>
"
"<s>[INST] get id [/INST]         return $this->attributes->get('id');
 <\s>
"
"<s>[INST] validate [/INST]         $violations = $this->validateExtraParam($validator);
        $violations->addAll(parent::validate($validator));

        return $violations;
 <\s>
"
"<s>[INST] get tle [/INST]         /** @var Tle $tle */
        $tle = $this->repository->findOneBy(['id' => $this->getId()]);

        if (null === $tle) {
            throw new NotFoundHttpException(\sprintf('Unable to find record with id %s', $this->getId()));
        }

        return $tle;
 <\s>
"
"<s>[INST] __construct [/INST]         $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);
 <\s>
"
"<s>[INST] initialize [/INST]         $this->request = new InputBag($request);
        $this->query = new InputBag($query);
        $this->attributes = new ParameterBag($attributes);
        $this->cookies = new InputBag($cookies);
        $this->files = new FileBag($files);
        $this->server = new ServerBag($server);
        $this->headers = new HeaderBag($this->server->getHeaders());

        $this->content = $content;
        $this->languages = null;
        $this->charsets = null;
        $this->encodings = null;
        $this->acceptableContentTypes = null;
        $this->pathInfo = null;
        $this->requestUri = null;
        $this->baseUrl = null;
        $this->basePath = null;
        $this->method = null;
        $this->format = null;
 <\s>
"
"<s>[INST] create from globals [/INST]         $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $_SERVER);

        if (str_starts_with($request->headers->get('CONTENT_TYPE', ''), 'application/x-www-form-urlencoded')
            && \in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), ['PUT', 'DELETE', 'PATCH'])
        ) {
            parse_str($request->getContent(), $data);
            $request->request = new InputBag($data);
        }

        return $request;
 <\s>
"
"<s>[INST] create [/INST]         $server = array_replace([
            'SERVER_NAME' => 'localhost',
            'SERVER_PORT' => 80,
            'HTTP_HOST' => 'localhost',
            'HTTP_USER_AGENT' => 'Symfony',
            'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',
            'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',
            'REMOTE_ADDR' => '127.0.0.1',
            'SCRIPT_NAME' => '',
            'SCRIPT_FILENAME' => '',
            'SERVER_PROTOCOL' => 'HTTP/1.1',
            'REQUEST_TIME' => time(),
            'REQUEST_TIME_FLOAT' => microtime(true),
        ], $server);

        $server['PATH_INFO'] = '';
        $server['REQUEST_METHOD'] = strtoupper($method);

        $components = parse_url($uri);
        if (false === $components) {
            trigger_deprecation('symfony/http-foundation', '6.3', 'Calling ""%s()"" with an invalid URI is deprecated.', __METHOD__);
            $components = [];
        }
        if (isset($components['host'])) {
            $server['SERVER_NAME'] = $components['host'];
            $server['HTTP_HOST'] = $components['host'];
        }

        if (isset($components['scheme'])) {
            if ('https' === $components['scheme']) {
                $server['HTTPS'] = 'on';
                $server['SERVER_PORT'] = 443;
            } else {
                unset($server['HTTPS']);
                $server['SERVER_PORT'] = 80;
            }
        }

        if (isset($components['port'])) {
            $server['SERVER_PORT'] = $components['port'];
            $server['HTTP_HOST'] .= ':'.$components['port'];
        }

        if (isset($components['user'])) {
            $server['PHP_AUTH_USER'] = $components['user'];
        }

        if (isset($components['pass'])) {
            $server['PHP_AUTH_PW'] = $components['pass'];
        }

        if (!isset($components['path'])) {
            $components['path'] = '/';
        }

        switch (strtoupper($method)) {
            case 'POST':
            case 'PUT':
            case 'DELETE':
                if (!isset($server['CONTENT_TYPE'])) {
                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';
                }
                // no break
            case 'PATCH':
                $request = $parameters;
                $query = [];
                break;
            default:
                $request = [];
                $query = $parameters;
                break;
        }

        $queryString = '';
        if (isset($components['query'])) {
            parse_str(html_entity_decode($components['query']), $qs);

            if ($query) {
                $query = array_replace($qs, $query);
                $queryString = http_build_query($query, '', '&');
            } else {
                $query = $qs;
                $queryString = $components['query'];
            }
        } elseif ($query) {
            $queryString = http_build_query($query, '', '&');
        }

        $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');
        $server['QUERY_STRING'] = $queryString;

        return self::createRequestFromFactory($query, $request, [], $cookies, $files, $server, $content);
 <\s>
"
"<s>[INST] set factory [/INST]         self::$requestFactory = $callable;
 <\s>
"
"<s>[INST] duplicate [/INST]         $dup = clone $this;
        if (null !== $query) {
            $dup->query = new InputBag($query);
        }
        if (null !== $request) {
            $dup->request = new InputBag($request);
        }
        if (null !== $attributes) {
            $dup->attributes = new ParameterBag($attributes);
        }
        if (null !== $cookies) {
            $dup->cookies = new InputBag($cookies);
        }
        if (null !== $files) {
            $dup->files = new FileBag($files);
        }
        if (null !== $server) {
            $dup->server = new ServerBag($server);
            $dup->headers = new HeaderBag($dup->server->getHeaders());
        }
        $dup->languages = null;
        $dup->charsets = null;
        $dup->encodings = null;
        $dup->acceptableContentTypes = null;
        $dup->pathInfo = null;
        $dup->requestUri = null;
        $dup->baseUrl = null;
        $dup->basePath = null;
        $dup->method = null;
        $dup->format = null;

        if (!$dup->get('_format') && $this->get('_format')) {
            $dup->attributes->set('_format', $this->get('_format'));
        }

        if (!$dup->getRequestFormat(null)) {
            $dup->setRequestFormat($this->getRequestFormat(null));
        }

        return $dup;
 <\s>
"
"<s>[INST] __clone [/INST]         $this->query = clone $this->query;
        $this->request = clone $this->request;
        $this->attributes = clone $this->attributes;
        $this->cookies = clone $this->cookies;
        $this->files = clone $this->files;
        $this->server = clone $this->server;
        $this->headers = clone $this->headers;
 <\s>
"
"<s>[INST] __to string [/INST]         $content = $this->getContent();

        $cookieHeader = '';
        $cookies = [];

        foreach ($this->cookies as $k => $v) {
            $cookies[] = \is_array($v) ? http_build_query([$k => $v], '', '; ', \PHP_QUERY_RFC3986) : ""$k=$v"";
        }

        if ($cookies) {
            $cookieHeader = 'Cookie: '.implode('; ', $cookies).""\r\n"";
        }

        return
            sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).""\r\n"".
            $this->headers.
            $cookieHeader.""\r\n"".
            $content;
 <\s>
"
"<s>[INST] override globals [/INST]         $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));

        $_GET = $this->query->all();
        $_POST = $this->request->all();
        $_SERVER = $this->server->all();
        $_COOKIE = $this->cookies->all();

        foreach ($this->headers->all() as $key => $value) {
            $key = strtoupper(str_replace('-', '_', $key));
            if (\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true)) {
                $_SERVER[$key] = implode(', ', $value);
            } else {
                $_SERVER['HTTP_'.$key] = implode(', ', $value);
            }
        }

        $request = ['g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE];

        $requestOrder = \ini_get('request_order') ?: \ini_get('variables_order');
        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';

        $_REQUEST = [[]];

        foreach (str_split($requestOrder) as $order) {
            $_REQUEST[] = $request[$order];
        }

        $_REQUEST = array_merge(...$_REQUEST);
 <\s>
"
"<s>[INST] set trusted proxies [/INST]         self::$trustedProxies = array_reduce($proxies, function ($proxies, $proxy) {
            if ('REMOTE_ADDR' !== $proxy) {
                $proxies[] = $proxy;
            } elseif (isset($_SERVER['REMOTE_ADDR'])) {
                $proxies[] = $_SERVER['REMOTE_ADDR'];
            }

            return $proxies;
        }, []);
        self::$trustedHeaderSet = $trustedHeaderSet;
 <\s>
"
"<s>[INST] get trusted proxies [/INST]         return self::$trustedProxies;
 <\s>
"
"<s>[INST] get trusted header set [/INST]         return self::$trustedHeaderSet;
 <\s>
"
"<s>[INST] set trusted hosts [/INST]         self::$trustedHostPatterns = array_map(fn ($hostPattern) => sprintf('{%s}i', $hostPattern), $hostPatterns);
        // we need to reset trusted hosts on trusted host patterns change
        self::$trustedHosts = [];
 <\s>
"
"<s>[INST] get trusted hosts [/INST]         return self::$trustedHostPatterns;
 <\s>
"
"<s>[INST] normalize query string [/INST]         if ('' === ($qs ?? '')) {
            return '';
        }

        $qs = HeaderUtils::parseQuery($qs);
        ksort($qs);

        return http_build_query($qs, '', '&', \PHP_QUERY_RFC3986);
 <\s>
"
"<s>[INST] enable http method parameter override [/INST]         self::$httpMethodParameterOverride = true;
 <\s>
"
"<s>[INST] get http method parameter override [/INST]         return self::$httpMethodParameterOverride;
 <\s>
"
"<s>[INST] get [/INST]         if ($this !== $result = $this->attributes->get($key, $this)) {
            return $result;
        }

        if ($this->query->has($key)) {
            return $this->query->all()[$key];
        }

        if ($this->request->has($key)) {
            return $this->request->all()[$key];
        }

        return $default;
 <\s>
"
"<s>[INST] get session [/INST]         $session = $this->session;
        if (!$session instanceof SessionInterface && null !== $session) {
            $this->setSession($session = $session());
        }

        if (null === $session) {
            throw new SessionNotFoundException('Session has not been set.');
        }

        return $session;
 <\s>
"
"<s>[INST] has previous session [/INST]         // the check for $this->session avoids malicious users trying to fake a session cookie with proper name
        return $this->hasSession() && $this->cookies->has($this->getSession()->getName());
 <\s>
"
"<s>[INST] has session [/INST]         return null !== $this->session && (!$skipIfUninitialized || $this->session instanceof SessionInterface);
 <\s>
"
"<s>[INST] set session [/INST]         $this->session = $session;
 <\s>
"
"<s>[INST] set session factory [/INST]         $this->session = $factory;
 <\s>
"
"<s>[INST] get client ips [/INST]         $ip = $this->server->get('REMOTE_ADDR');

        if (!$this->isFromTrustedProxy()) {
            return [$ip];
        }

        return $this->getTrustedValues(self::HEADER_X_FORWARDED_FOR, $ip) ?: [$ip];
 <\s>
"
"<s>[INST] get client ip [/INST]         $ipAddresses = $this->getClientIps();

        return $ipAddresses[0];
 <\s>
"
"<s>[INST] get script name [/INST]         return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));
 <\s>
"
"<s>[INST] get path info [/INST]         return $this->pathInfo ??= $this->preparePathInfo();
 <\s>
"
"<s>[INST] get base path [/INST]         return $this->basePath ??= $this->prepareBasePath();
 <\s>
"
"<s>[INST] get base url [/INST]         $trustedPrefix = '';

        // the proxy prefix must be prepended to any prefix being needed at the webserver level
        if ($this->isFromTrustedProxy() && $trustedPrefixValues = $this->getTrustedValues(self::HEADER_X_FORWARDED_PREFIX)) {
            $trustedPrefix = rtrim($trustedPrefixValues[0], '/');
        }

        return $trustedPrefix.$this->getBaseUrlReal();
 <\s>
"
"<s>[INST] get scheme [/INST]         return $this->isSecure() ? 'https' : 'http';
 <\s>
"
"<s>[INST] get port [/INST]         if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_PORT)) {
            $host = $host[0];
        } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {
            $host = $host[0];
        } elseif (!$host = $this->headers->get('HOST')) {
            return $this->server->get('SERVER_PORT');
        }

        if ('[' === $host[0]) {
            $pos = strpos($host, ':', strrpos($host, ']'));
        } else {
            $pos = strrpos($host, ':');
        }

        if (false !== $pos && $port = substr($host, $pos + 1)) {
            return (int) $port;
        }

        return 'https' === $this->getScheme() ? 443 : 80;
 <\s>
"
"<s>[INST] get user [/INST]         return $this->headers->get('PHP_AUTH_USER');
 <\s>
"
"<s>[INST] get password [/INST]         return $this->headers->get('PHP_AUTH_PW');
 <\s>
"
"<s>[INST] get user info [/INST]         $userinfo = $this->getUser();

        $pass = $this->getPassword();
        if ('' != $pass) {
            $userinfo .= "":$pass"";
        }

        return $userinfo;
 <\s>
"
"<s>[INST] get http host [/INST]         $scheme = $this->getScheme();
        $port = $this->getPort();

        if (('http' === $scheme && 80 == $port) || ('https' === $scheme && 443 == $port)) {
            return $this->getHost();
        }

        return $this->getHost().':'.$port;
 <\s>
"
"<s>[INST] get request uri [/INST]         return $this->requestUri ??= $this->prepareRequestUri();
 <\s>
"
"<s>[INST] get scheme and http host [/INST]         return $this->getScheme().'://'.$this->getHttpHost();
 <\s>
"
"<s>[INST] get uri [/INST]         if (null !== $qs = $this->getQueryString()) {
            $qs = '?'.$qs;
        }

        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;
 <\s>
"
"<s>[INST] get uri for path [/INST]         return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;
 <\s>
"
"<s>[INST] get relative uri for path [/INST]         // be sure that we are dealing with an absolute path
        if (!isset($path[0]) || '/' !== $path[0]) {
            return $path;
        }

        if ($path === $basePath = $this->getPathInfo()) {
            return '';
        }

        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);
        $targetDirs = explode('/', substr($path, 1));
        array_pop($sourceDirs);
        $targetFile = array_pop($targetDirs);

        foreach ($sourceDirs as $i => $dir) {
            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {
                unset($sourceDirs[$i], $targetDirs[$i]);
            } else {
                break;
            }
        }

        $targetDirs[] = $targetFile;
        $path = str_repeat('../', \count($sourceDirs)).implode('/', $targetDirs);

        // A reference to the same base directory or an empty subdirectory must be prefixed with ""./"".
        // This also applies to a segment with a colon character (e.g., ""file:colon"") that cannot be used
        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name
        // (see https://tools.ietf.org/html/rfc3986#section-4.2).
        return !isset($path[0]) || '/' === $path[0]
            || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos)
            ? ""./$path"" : $path;
 <\s>
"
"<s>[INST] get query string [/INST]         $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));

        return '' === $qs ? null : $qs;
 <\s>
"
"<s>[INST] is secure [/INST]         if ($this->isFromTrustedProxy() && $proto = $this->getTrustedValues(self::HEADER_X_FORWARDED_PROTO)) {
            return \in_array(strtolower($proto[0]), ['https', 'on', 'ssl', '1'], true);
        }

        $https = $this->server->get('HTTPS');

        return !empty($https) && 'off' !== strtolower($https);
 <\s>
"
"<s>[INST] get host [/INST]         if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {
            $host = $host[0];
        } elseif (!$host = $this->headers->get('HOST')) {
            if (!$host = $this->server->get('SERVER_NAME')) {
                $host = $this->server->get('SERVER_ADDR', '');
            }
        }

        // trim and remove port number from host
        // host is lowercase as per RFC 952/2181
        $host = strtolower(preg_replace('/:\d+$/', '', trim($host)));

        // as the host can come from the user (HTTP_HOST and depending on the configuration, SERVER_NAME too can come from the user)
        // check that it does not contain forbidden characters (see RFC 952 and RFC 2181)
        // use preg_replace() instead of preg_match() to prevent DoS attacks with long host names
        if ($host && '' !== preg_replace('/(?:^\[)?[a-zA-Z0-9-:\]_]+\.?/', '', $host)) {
            if (!$this->isHostValid) {
                return '';
            }
            $this->isHostValid = false;

            throw new SuspiciousOperationException(sprintf('Invalid Host ""%s"".', $host));
        }

        if (\count(self::$trustedHostPatterns) > 0) {
            // to avoid host header injection attacks, you should provide a list of trusted host patterns

            if (\in_array($host, self::$trustedHosts)) {
                return $host;
            }

            foreach (self::$trustedHostPatterns as $pattern) {
                if (preg_match($pattern, $host)) {
                    self::$trustedHosts[] = $host;

                    return $host;
                }
            }

            if (!$this->isHostValid) {
                return '';
            }
            $this->isHostValid = false;

            throw new SuspiciousOperationException(sprintf('Untrusted Host ""%s"".', $host));
        }

        return $host;
 <\s>
"
"<s>[INST] set method [/INST]         $this->method = null;
        $this->server->set('REQUEST_METHOD', $method);
 <\s>
"
"<s>[INST] get method [/INST]         if (null !== $this->method) {
            return $this->method;
        }

        $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));

        if ('POST' !== $this->method) {
            return $this->method;
        }

        $method = $this->headers->get('X-HTTP-METHOD-OVERRIDE');

        if (!$method && self::$httpMethodParameterOverride) {
            $method = $this->request->get('_method', $this->query->get('_method', 'POST'));
        }

        if (!\is_string($method)) {
            return $this->method;
        }

        $method = strtoupper($method);

        if (\in_array($method, ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'PATCH', 'PURGE', 'TRACE'], true)) {
            return $this->method = $method;
        }

        if (!preg_match('/^[A-Z]++$/D', $method)) {
            throw new SuspiciousOperationException(sprintf('Invalid method override ""%s"".', $method));
        }

        return $this->method = $method;
 <\s>
"
"<s>[INST] get real method [/INST]         return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));
 <\s>
"
"<s>[INST] get mime type [/INST]         if (null === static::$formats) {
            static::initializeFormats();
        }

        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;
 <\s>
"
"<s>[INST] get mime types [/INST]         if (null === static::$formats) {
            static::initializeFormats();
        }

        return static::$formats[$format] ?? [];
 <\s>
"
"<s>[INST] get format [/INST]         $canonicalMimeType = null;
        if ($mimeType && false !== $pos = strpos($mimeType, ';')) {
            $canonicalMimeType = trim(substr($mimeType, 0, $pos));
        }

        if (null === static::$formats) {
            static::initializeFormats();
        }

        foreach (static::$formats as $format => $mimeTypes) {
            if (\in_array($mimeType, (array) $mimeTypes)) {
                return $format;
            }
            if (null !== $canonicalMimeType && \in_array($canonicalMimeType, (array) $mimeTypes)) {
                return $format;
            }
        }

        return null;
 <\s>
"
"<s>[INST] set format [/INST]         if (null === static::$formats) {
            static::initializeFormats();
        }

        static::$formats[$format] = \is_array($mimeTypes) ? $mimeTypes : [$mimeTypes];
 <\s>
"
"<s>[INST] get request format [/INST]         $this->format ??= $this->attributes->get('_format');

        return $this->format ?? $default;
 <\s>
"
"<s>[INST] set request format [/INST]         $this->format = $format;
 <\s>
"
"<s>[INST] get content type [/INST]         trigger_deprecation('symfony/http-foundation', '6.2', 'The ""%s()"" method is deprecated, use ""getContentTypeFormat()"" instead.', __METHOD__);

        return $this->getContentTypeFormat();
 <\s>
"
"<s>[INST] get content type format [/INST]         return $this->getFormat($this->headers->get('CONTENT_TYPE', ''));
 <\s>
"
"<s>[INST] set default locale [/INST]         $this->defaultLocale = $locale;

        if (null === $this->locale) {
            $this->setPhpDefaultLocale($locale);
        }
 <\s>
"
"<s>[INST] get default locale [/INST]         return $this->defaultLocale;
 <\s>
"
"<s>[INST] set locale [/INST]         $this->setPhpDefaultLocale($this->locale = $locale);
 <\s>
"
"<s>[INST] get locale [/INST]         return $this->locale ?? $this->defaultLocale;
 <\s>
"
"<s>[INST] is method [/INST]         return $this->getMethod() === strtoupper($method);
 <\s>
"
"<s>[INST] is method safe [/INST]         return \in_array($this->getMethod(), ['GET', 'HEAD', 'OPTIONS', 'TRACE']);
 <\s>
"
"<s>[INST] is method idempotent [/INST]         return \in_array($this->getMethod(), ['HEAD', 'GET', 'PUT', 'DELETE', 'TRACE', 'OPTIONS', 'PURGE']);
 <\s>
"
"<s>[INST] is method cacheable [/INST]         return \in_array($this->getMethod(), ['GET', 'HEAD']);
 <\s>
"
"<s>[INST] get protocol version [/INST]         if ($this->isFromTrustedProxy()) {
            preg_match('~^(HTTP/)?([1-9]\.[0-9]) ~', $this->headers->get('Via') ?? '', $matches);

            if ($matches) {
                return 'HTTP/'.$matches[2];
            }
        }

        return $this->server->get('SERVER_PROTOCOL');
 <\s>
"
"<s>[INST] get content [/INST]         $currentContentIsResource = \is_resource($this->content);

        if (true === $asResource) {
            if ($currentContentIsResource) {
                rewind($this->content);

                return $this->content;
            }

            // Content passed in parameter (test)
            if (\is_string($this->content)) {
                $resource = fopen('php://temp', 'r+');
                fwrite($resource, $this->content);
                rewind($resource);

                return $resource;
            }

            $this->content = false;

            return fopen('php://input', 'r');
        }

        if ($currentContentIsResource) {
            rewind($this->content);

            return stream_get_contents($this->content);
        }

        if (null === $this->content || false === $this->content) {
            $this->content = file_get_contents('php://input');
        }

        return $this->content;
 <\s>
"
"<s>[INST] get payload [/INST]         return $this->request->count() ? clone $this->request : new InputBag($this->toArray());
 <\s>
"
"<s>[INST] to array [/INST]         if ('' === $content = $this->getContent()) {
            throw new JsonException('Request body is empty.');
        }

        try {
            $content = json_decode($content, true, 512, \JSON_BIGINT_AS_STRING | \JSON_THROW_ON_ERROR);
        } catch (\JsonException $e) {
            throw new JsonException('Could not decode request body.', $e->getCode(), $e);
        }

        if (!\is_array($content)) {
            throw new JsonException(sprintf('JSON content was expected to decode to an array, ""%s"" returned.', get_debug_type($content)));
        }

        return $content;
 <\s>
"
"<s>[INST] get e tags [/INST]         return preg_split('/\s*,\s*/', $this->headers->get('If-None-Match', ''), -1, \PREG_SPLIT_NO_EMPTY);
 <\s>
"
"<s>[INST] is no cache [/INST]         return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');
 <\s>
"
"<s>[INST] get preferred format [/INST]         if (null !== $this->preferredFormat || null !== $this->preferredFormat = $this->getRequestFormat(null)) {
            return $this->preferredFormat;
        }

        foreach ($this->getAcceptableContentTypes() as $mimeType) {
            if ($this->preferredFormat = $this->getFormat($mimeType)) {
                return $this->preferredFormat;
            }
        }

        return $default;
 <\s>
"
"<s>[INST] get preferred language [/INST]         $preferredLanguages = $this->getLanguages();

        if (empty($locales)) {
            return $preferredLanguages[0] ?? null;
        }

        if (!$preferredLanguages) {
            return $locales[0];
        }

        $extendedPreferredLanguages = [];
        foreach ($preferredLanguages as $language) {
            $extendedPreferredLanguages[] = $language;
            if (false !== $position = strpos($language, '_')) {
                $superLanguage = substr($language, 0, $position);
                if (!\in_array($superLanguage, $preferredLanguages)) {
                    $extendedPreferredLanguages[] = $superLanguage;
                }
            }
        }

        $preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));

        return $preferredLanguages[0] ?? $locales[0];
 <\s>
"
"<s>[INST] get languages [/INST]         if (null !== $this->languages) {
            return $this->languages;
        }

        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();
        $this->languages = [];
        foreach ($languages as $acceptHeaderItem) {
            $lang = $acceptHeaderItem->getValue();
            if (str_contains($lang, '-')) {
                $codes = explode('-', $lang);
                if ('i' === $codes[0]) {
                    // Language not listed in ISO 639 that are not variants
                    // of any listed language, which can be registered with the
                    // i-prefix, such as i-cherokee
                    if (\count($codes) > 1) {
                        $lang = $codes[1];
                    }
                } else {
                    for ($i = 0, $max = \count($codes); $i < $max; ++$i) {
                        if (0 === $i) {
                            $lang = strtolower($codes[0]);
                        } else {
                            $lang .= '_'.strtoupper($codes[$i]);
                        }
                    }
                }
            }

            $this->languages[] = $lang;
        }

        return $this->languages;
 <\s>
"
"<s>[INST] get charsets [/INST]         if (null !== $this->charsets) {
            return $this->charsets;
        }

        return $this->charsets = array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all()));
 <\s>
"
"<s>[INST] get encodings [/INST]         if (null !== $this->encodings) {
            return $this->encodings;
        }

        return $this->encodings = array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all()));
 <\s>
"
"<s>[INST] get acceptable content types [/INST]         if (null !== $this->acceptableContentTypes) {
            return $this->acceptableContentTypes;
        }

        return $this->acceptableContentTypes = array_map('strval', array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all()));
 <\s>
"
"<s>[INST] is xml http request [/INST]         return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');
 <\s>
"
"<s>[INST] prefer safe content [/INST]         if (isset($this->isSafeContentPreferred)) {
            return $this->isSafeContentPreferred;
        }

        if (!$this->isSecure()) {
            // see https://tools.ietf.org/html/rfc8674#section-3
            return $this->isSafeContentPreferred = false;
        }

        return $this->isSafeContentPreferred = AcceptHeader::fromString($this->headers->get('Prefer'))->has('safe');
 <\s>
"
"<s>[INST] prepare request uri [/INST]         $requestUri = '';

        if ('1' == $this->server->get('IIS_WasUrlRewritten') && '' != $this->server->get('UNENCODED_URL')) {
            // IIS7 with URL Rewrite: make sure we get the unencoded URL (double slash problem)
            $requestUri = $this->server->get('UNENCODED_URL');
            $this->server->remove('UNENCODED_URL');
            $this->server->remove('IIS_WasUrlRewritten');
        } elseif ($this->server->has('REQUEST_URI')) {
            $requestUri = $this->server->get('REQUEST_URI');

            if ('' !== $requestUri && '/' === $requestUri[0]) {
                // To only use path and query remove the fragment.
                if (false !== $pos = strpos($requestUri, '#')) {
                    $requestUri = substr($requestUri, 0, $pos);
                }
            } else {
                // HTTP proxy reqs setup request URI with scheme and host [and port] + the URL path,
                // only use URL path.
                $uriComponents = parse_url($requestUri);

                if (isset($uriComponents['path'])) {
                    $requestUri = $uriComponents['path'];
                }

                if (isset($uriComponents['query'])) {
                    $requestUri .= '?'.$uriComponents['query'];
                }
            }
        } elseif ($this->server->has('ORIG_PATH_INFO')) {
            // IIS 5.0, PHP as CGI
            $requestUri = $this->server->get('ORIG_PATH_INFO');
            if ('' != $this->server->get('QUERY_STRING')) {
                $requestUri .= '?'.$this->server->get('QUERY_STRING');
            }
            $this->server->remove('ORIG_PATH_INFO');
        }

        // normalize the request URI to ease creating sub-requests from this request
        $this->server->set('REQUEST_URI', $requestUri);

        return $requestUri;
 <\s>
"
"<s>[INST] prepare base url [/INST]         $filename = basename($this->server->get('SCRIPT_FILENAME', ''));

        if (basename($this->server->get('SCRIPT_NAME', '')) === $filename) {
            $baseUrl = $this->server->get('SCRIPT_NAME');
        } elseif (basename($this->server->get('PHP_SELF', '')) === $filename) {
            $baseUrl = $this->server->get('PHP_SELF');
        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME', '')) === $filename) {
            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); // 1and1 shared hosting compatibility
        } else {
            // Backtrack up the script_filename to find the portion matching
            // php_self
            $path = $this->server->get('PHP_SELF', '');
            $file = $this->server->get('SCRIPT_FILENAME', '');
            $segs = explode('/', trim($file, '/'));
            $segs = array_reverse($segs);
            $index = 0;
            $last = \count($segs);
            $baseUrl = '';
            do {
                $seg = $segs[$index];
                $baseUrl = '/'.$seg.$baseUrl;
                ++$index;
            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);
        }

        // Does the baseUrl have anything in common with the request_uri?
        $requestUri = $this->getRequestUri();
        if ('' !== $requestUri && '/' !== $requestUri[0]) {
            $requestUri = '/'.$requestUri;
        }

        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {
            // full $baseUrl matches
            return $prefix;
        }

        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, rtrim(\dirname($baseUrl), '/'.\DIRECTORY_SEPARATOR).'/')) {
            // directory portion of $baseUrl matches
            return rtrim($prefix, '/'.\DIRECTORY_SEPARATOR);
        }

        $truncatedRequestUri = $requestUri;
        if (false !== $pos = strpos($requestUri, '?')) {
            $truncatedRequestUri = substr($requestUri, 0, $pos);
        }

        $basename = basename($baseUrl ?? '');
        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {
            // no match whatsoever; set it blank
            return '';
        }

        // If using mod_rewrite or ISAPI_Rewrite strip the script filename
        // out of baseUrl. $pos !== 0 makes sure it is not matching a value
        // from PATH_INFO or QUERY_STRING
        if (\strlen($requestUri) >= \strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && 0 !== $pos) {
            $baseUrl = substr($requestUri, 0, $pos + \strlen($baseUrl));
        }

        return rtrim($baseUrl, '/'.\DIRECTORY_SEPARATOR);
 <\s>
"
"<s>[INST] prepare base path [/INST]         $baseUrl = $this->getBaseUrl();
        if (empty($baseUrl)) {
            return '';
        }

        $filename = basename($this->server->get('SCRIPT_FILENAME'));
        if (basename($baseUrl) === $filename) {
            $basePath = \dirname($baseUrl);
        } else {
            $basePath = $baseUrl;
        }

        if ('\\' === \DIRECTORY_SEPARATOR) {
            $basePath = str_replace('\\', '/', $basePath);
        }

        return rtrim($basePath, '/');
 <\s>
"
"<s>[INST] prepare path info [/INST]         if (null === ($requestUri = $this->getRequestUri())) {
            return '/';
        }

        // Remove the query string from REQUEST_URI
        if (false !== $pos = strpos($requestUri, '?')) {
            $requestUri = substr($requestUri, 0, $pos);
        }
        if ('' !== $requestUri && '/' !== $requestUri[0]) {
            $requestUri = '/'.$requestUri;
        }

        if (null === ($baseUrl = $this->getBaseUrlReal())) {
            return $requestUri;
        }

        $pathInfo = substr($requestUri, \strlen($baseUrl));
        if (false === $pathInfo || '' === $pathInfo) {
            // If substr() returns false then PATH_INFO is set to an empty string
            return '/';
        }

        return $pathInfo;
 <\s>
"
"<s>[INST] initialize formats [/INST]         static::$formats = [
            'html' => ['text/html', 'application/xhtml+xml'],
            'txt' => ['text/plain'],
            'js' => ['application/javascript', 'application/x-javascript', 'text/javascript'],
            'css' => ['text/css'],
            'json' => ['application/json', 'application/x-json'],
            'jsonld' => ['application/ld+json'],
            'xml' => ['text/xml', 'application/xml', 'application/x-xml'],
            'rdf' => ['application/rdf+xml'],
            'atom' => ['application/atom+xml'],
            'rss' => ['application/rss+xml'],
            'form' => ['application/x-www-form-urlencoded', 'multipart/form-data'],
        ];
 <\s>
"
"<s>[INST] is from trusted proxy [/INST]         return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR', ''), self::$trustedProxies);
 <\s>
"
"<s>[INST] get extra [/INST]         return (bool) $this->get(TleRequest::EXTRA_PARAM, false);
 <\s>
"
"<s>[INST] validate extra param [/INST]         return $validator->validate(
            $this->query->all(),
            new Assert\Collection(
                [
                    'allowExtraFields' => true,
                    'allowMissingFields' => true,
                    'fields' => [
                        TleRequest::EXTRA_PARAM => new Assert\Optional(new Assert\Choice(Filter::BOOLEAN_VALUES)),
                    ],
                ]
            )
        );
 <\s>
"
"<s>[INST] __construct [/INST]         $this->cache = new FilesystemAdapter();
 <\s>
"
"<s>[INST] get [/INST]         $result = $this->cache->getItem('tle_api_doc');
        $result->expiresAfter(new \DateInterval('PT30M'));

        if ($result->isHit()) {
            return $result->get();
        }

        $data = $this->build($file);

        $result->set($data);

        return $data;
 <\s>
"
"<s>[INST] build [/INST]         $docs = json_decode(
            file_get_contents($this->getProjectDir().$file),
            true,
            JSON_THROW_ON_ERROR,
            JSON_THROW_ON_ERROR
        );

        $docs['info']['version'] = $this->bag->get('version');

        return $docs;
 <\s>
"
"<s>[INST] set parameter bag [/INST]         $this->parameters = $parameters;
 <\s>
"
"<s>[INST] get project dir [/INST]         return $this->parameters->get('kernel.project_dir');
 <\s>
"
"<s>[INST] __construct [/INST]         $this->predict = new \Predict();
        $this->qth = new \Predict_QTH();
 <\s>
"
"<s>[INST] set tle [/INST]         $this->sat = new \Predict_Sat(
            new \Predict_TLE($tle->getName(), $tle->getLine1(), $tle->getLine2())
        );

        return $this;
 <\s>
"
"<s>[INST] set observer [/INST]         $this->qth->lat = $observer->latitude;
        $this->qth->lon = $observer->longitude;
        $this->qth->alt = $observer->altitude;

        return $this;
 <\s>
"
"<s>[INST] get passes [/INST]         $this->predict->minEle = 10; // Minimum elevation for a pass
        $this->predict->timeRes = 10; // Pass details: time resolution in seconds
        $this->predict->numEntries = 20; // Pass details: number of entries per pass
        $this->predict->threshold = -6; // Twilight threshold (sun must be at this lat or lower)

        // Get the passes and filter visible only, takes about 4 seconds for 10 days
        $passes = $this->predict->get_passes($this->sat, $this->qth, \Predict_Time::unix2daynum($date->getTimestamp()), 10);

        if ($filterVisible) {
            return $this->predict->filterVisiblePasses($passes);
        }

        return $passes;
 <\s>
"
"<s>[INST] in array [/INST]         return in_array($request->get('_route'), $routes, false);
 <\s>
"
"<s>[INST] __invoke [/INST]         $exceptions = $event->getExceptions();

        foreach ($exceptions as $exception) {
            if (in_array($exception->getType(), self::SKIP)) {
                return null;
            }
        }

        return $event;
 <\s>
"
"<s>[INST] __construct [/INST]         $this->value = $this->validateValue($value);
        $this->sqlOperator = $this->validateOperator();
 <\s>
"
"<s>[INST] validate operator [/INST]         if (self::FILTER_TYPE_FLOAT === $this->type) {
            $operators = self::FILTER_FLOAT_OPERATORS[self::FILTER_TYPE_FLOAT];
            if (!array_key_exists($this->operator, $operators)) {
                throw new BadRequestHttpException(\sprintf('Operator for filter \'%s\' should be one of the following %s, \'%s\' provided', $this->filter, implode(', ', array_keys($operators)), $this->operator));
            }

            return $operators[$this->operator];
        }

        if (self::FILTER_TYPE_ARRAY === $this->type) {
            return self::OPERATOR_EQUAL;
        }

        return '';
 <\s>
"
"<s>[INST] validate value [/INST]         if (self::FILTER_TYPE_FLOAT === $this->type) {
            $value = (float) $value;

            if (!is_float($value)) {
                throw new \InvalidArgumentException(\sprintf('Filter %s value should be %s', $this->filter, $this->type));
            }

            return $value;
        }

        if (self::FILTER_TYPE_ARRAY === $this->type) {
            if (!is_array($value)) {
                throw new \InvalidArgumentException(\sprintf('Filter %s value should be %s', $this->filter, $this->type));
            }

            return $value;
        }

        return null;
 <\s>
"
"<s>[INST] __construct [/INST]         if ($this->latitude > 90 || $this->latitude < -90) {
            throw new \InvalidArgumentException('Invalid latitude value');
        }

        if ($this->longitude > 180 || $this->longitude < -180) {
            throw new \InvalidArgumentException('Invalid longitude value');
        }
 <\s>
"
"<s>[INST] get timezone [/INST]         $diffs = [];
        foreach (DateTimeZone::listIdentifiers() as $timezoneID) {
            $timezone = new DateTimeZone($timezoneID);
            $location = $timezone->getLocation();
            $tLat = $location['latitude'];
            $tLng = $location['longitude'];
            $diffLat = abs($this->latitude - $tLat);
            $diffLng = abs($this->longitude - $tLng);
            $diff = $diffLat + $diffLng;
            $diffs[$timezoneID] = $diff;
        }

        $timezone = array_keys($diffs, min($diffs));

        return $timezone[0] ?? null;
 <\s>
"
"<s>[INST] __construct [/INST]         parent::__construct($latitude, $longitude);

        $this->date = $dateTime ?? new \DateTime('now', new \DateTimeZone($this->getTimezone()));
 <\s>
"
"<s>[INST] get timezone [/INST]         $diffs = [];
        foreach (DateTimeZone::listIdentifiers() as $timezoneID) {
            $timezone = new DateTimeZone($timezoneID);
            $location = $timezone->getLocation();
            $tLat = $location['latitude'];
            $tLng = $location['longitude'];
            $diffLat = abs($this->latitude - $tLat);
            $diffLng = abs($this->longitude - $tLng);
            $diff = $diffLat + $diffLng;
            $diffs[$timezoneID] = $diff;
        }

        $timezone = array_keys($diffs, min($diffs));

        return $timezone[0] ?? null;
 <\s>
"
